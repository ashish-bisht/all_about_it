<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 5: Tree Mastery</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg: #f0f2f5;
            --card-bg: #ffffff;
            --text-main: #1a202c;
            --text-muted: #64748b;
            --primary: #16a34a; /* Green for "Trees/Nature" */
            --primary-light: #f0fdf4;
            --accent: #22c55e;
            --must: #dc2626;
            --must-bg: #fef2f2;
            --code-bg: #1e293b;
        }
        
        * { box-sizing: border-box; transition: all 0.2s ease; }
        body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text-main); margin: 0; padding: 40px 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }

        /* Header */
        .header-section { text-align: center; margin-bottom: 40px; }
        .header-section h1 { font-size: 2.5rem; margin-bottom: 10px; color: var(--text-main); letter-spacing: -1px; }
        
        /* Principal's Thinking Model */
        .pattern-card { background: linear-gradient(135deg, #14532d, #166534); color: white; padding: 30px; border-radius: 16px; margin-bottom: 40px; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2); }
        .pattern-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .pattern-col h4 { color: var(--accent); margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .code-snippet { font-family: 'Menlo', monospace; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; color: #fbbf24; font-size: 0.9em; }

        /* Question Cards */
        .flashcard { background: var(--card-bg); border-radius: 16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 30px; overflow: hidden; border: 1px solid #e2e8f0; position: relative; }
        
        .card-header { padding: 20px 25px; border-bottom: 1px solid #f1f5f9; display: flex; justify-content: space-between; align-items: center; background: #fff; }
        .q-title { font-weight: 800; font-size: 1.25rem; color: var(--text-main); display: flex; align-items: center; gap: 12px; }
        
        /* Badges */
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 6px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-must { background: var(--must-bg); color: var(--must); border: 1px solid #fecaca; }
        .tag { font-size: 0.85rem; color: var(--text-muted); background: #f1f5f9; padding: 4px 12px; border-radius: 20px; font-weight: 500; }

        .card-body { padding: 25px; }

        /* Metrics */
        .metrics { display: flex; gap: 20px; margin-bottom: 10px; font-family: 'Menlo', monospace; font-size: 0.85rem; }
        .metric-item { display: flex; align-items: center; gap: 6px; background: #f8fafc; padding: 8px 12px; border-radius: 6px; border: 1px solid #e2e8f0; color: var(--text-muted); cursor: pointer; }
        .metric-item:hover { border-color: var(--primary); color: var(--primary); background: var(--primary-light); }
        
        /* Hidden Explanation Box */
        .metric-explainer { 
            display: none; 
            background: #fffbeb; 
            border: 1px solid #fde68a; 
            padding: 15px; 
            border-radius: 8px; 
            font-size: 0.9rem; 
            margin-bottom: 20px; 
            color: #92400e;
            animation: fadeIn 0.3s ease;
        }

        /* Logic Boxes */
        .info-box { padding: 20px; border-radius: 8px; margin-bottom: 20px; font-size: 0.95rem; position: relative; margin-top: 15px; }
        .logic-box { background: var(--primary-light); border-left: 5px solid var(--primary); }
        .trap-box { background: var(--must-bg); border-left: 5px solid var(--must); color: #991b1b; }
        
        .box-label { position: absolute; top: -10px; left: 15px; background: inherit; padding: 0 8px; font-size: 0.75rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; border-radius: 4px; }

        /* Visual Placeholder */
        .visual-area { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 8px; padding: 20px; text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .visual-area i { font-size: 1.5rem; color: var(--primary); }

        /* Code Section */
        details { margin-top: 15px; background: var(--code-bg); border-radius: 8px; overflow: hidden; }
        summary { padding: 12px 20px; cursor: pointer; color: #e2e8f0; font-weight: 600; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; list-style: none; }
        summary:hover { background: rgba(255,255,255,0.05); }
        summary::after { content: 'Show Code \f121'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        details[open] summary::after { content: 'Hide Code \f128'; }
        
        pre { margin: 0; padding: 20px; overflow-x: auto; color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.9rem; line-height: 1.5; position: relative; border-top: 1px solid #334155; }
        .copy-btn { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* Responsive */
        @media (max-width: 600px) { .pattern-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div class="container">

    <div class="header-section">
        <h1>5Ô∏è‚É£ Tree Mastery</h1>
        <p style="color: var(--text-muted);">Principal Engineer DSA ‚Ä¢ Day 5</p>
    </div>

    <div class="pattern-card">
        <h3><i class="fas fa-tree"></i> Principal's Mental Model</h3>
        
        <div class="pattern-grid">
            <div class="pattern-col">
                <h4><i class="fas fa-praying-hands"></i> The Leap of Faith</h4>
                <p style="font-size: 0.9rem; opacity: 0.9;">
                    Do not trace the recursion. Trust it.
                    <br><strong>Assumption:</strong> "I assume <code>solve(root.left)</code> will magically give me exactly what I asked for."
                    <br>Your only job is to combine the Left Result and Right Result with the Current Node.
                </p>
            </div>
            <div class="pattern-col">
                <h4 style="color: #fbbf24;"><i class="fas fa-shield-alt"></i> The "10x" Safety Check</h4>
                <ul style="padding-left: 20px; line-height: 1.6; font-size: 0.9rem;">
                    <li><strong>Base Cases First:</strong> Always handle <code>if not root: return ...</code> before anything else.</li>
                    <li><strong>Global vs Local:</strong>
                        <br>Do you need to pass a value <em>down</em> (Parameter)?
                        <br>Or bubble a value <em>up</em> (Return)?
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <div class="flashcard" id="card-1">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-code-branch" style="color: var(--primary);"></i>
                <span>LCA in Binary Tree</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">DFS Pattern</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('lca-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('lca-space')">
                    <i class="fas fa-server"></i> O(H) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="lca-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                In the worst case (skewed tree or node not found), we visit every node exactly once using DFS.
            </div>
            <div id="lca-space-explainer" class="metric-explainer">
                <strong>Why O(H)?</strong> <br>
                Space is determined by the recursion stack height. <br>H = log N (Balanced) to N (Skewed).
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Meeting Point</strong><br>Imagine Node P and Node Q light up a path to the root.<br>The LCA is the <strong>first</strong> node (from bottom-up) where the paths merge.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Bubbling Up Logic:</strong>
                <br>1. If I am <code>None</code>, return <code>None</code>.
                <br>2. If I am <code>P</code> or <code>Q</code>, return <strong>Myself</strong> (I found a target!).
                <br>3. Ask Left and Right children.
                <br>4. <strong>Result:</strong> If both Left and Right returned something, <strong>I am the LCA</strong>. If only one returned something, pass that one up.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "One Missing" Edge Case:</strong> 
                <br>Standard algorithms assume both P and Q exist in the tree. If P exists but Q doesn't, this logic returns P (which is correct if we assume Q is in P's subtree, but incorrect if Q is truly missing).
                <br><em>Interview Tip:</em> Ask "Are P and Q guaranteed to exist?"
            </div>

            <details open>
                <summary>Python Solution (Standard DFS)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-lca')">Copy</button>
                    <pre id="code-lca">
def lowestCommonAncestor(root, p, q):
    # 1. Base Case: Reached null or found one of the targets
    if not root or root == p or root == q:
        return root
        
    # 2. Leap of Faith: Ask children "Did you find p or q?"
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    
    # 3. Logic Step:
    # If both returned a node, it means p is in one side 
    # and q is in the other. I am the split point (LCA).
    if left and right:
        return root
        
    # Otherwise, return the non-null result (bubbling up the find)
    return left if left else right</pre>
                </div>
            </details>
        </div>
    </div>


    <div class="flashcard" id="card-2">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-file-code" style="color: var(--must);"></i>
                <span>Serialize & Deserialize</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">System Design Core</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('ser-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('ser-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="ser-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We visit every node once to print it (Serialize) and process every value once to rebuild it (Deserialize).
            </div>
            <div id="ser-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We store the entire tree structure in a string/list. This requires linear space.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Flat" Tree</strong><br>A tree is 2D. To send it over a network (JSON/String), we flatten it to 1D.<br><strong>Critical:</strong> We must record the "Nulls" (Leaves' children) to preserve the shape.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Preorder Traversal (Root ‚Üí Left ‚Üí Right)</strong> is the easiest pattern.
                <br>1. <strong>Serialize:</strong> DFS. If Node, add "Val". If None, add "X" (Marker). Join with commas.
                <br>2. <strong>Deserialize:</strong> Split string into a stream/iterator. Pop the first item.
                <br>If "X", return None. Else, create Node(Val), then recursively build <code>node.left</code> and <code>node.right</code>.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Global Indexing:</strong> 
                <br>During deserialization, tracking the current index with a global integer is messy and error-prone.
                <br><strong>Pro Tip:</strong> Convert the list into an <strong>Iterator</strong> (`iter(values)`). Recursive calls can naturally `next()` the iterator to consume values without index math.
            </div>

            <details>
                <summary>Python Solution (Iterator Pattern)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-ser')">Copy</button>
                    <pre id="code-ser">
class Codec:
    def serialize(self, root):
        """Encodes a tree to a single string."""
        res = []
        
        def dfs(node):
            if not node:
                res.append("N") # Null Marker
                return
            res.append(str(node.val))
            dfs(node.left)
            dfs(node.right)
            
        dfs(root)
        return ",".join(res)

    def deserialize(self, data):
        """Decodes your encoded data to tree."""
        # Create an Iterator stream for O(1) consumption
        vals = iter(data.split(","))
        
        def build():
            try:
                val = next(vals)
            except StopIteration:
                return None
                
            if val == "N":
                return None
                
            # Preorder Logic: Build Root, then Left, then Right
            node = TreeNode(int(val))
            node.left = build()
            node.right = build()
            return node
            
        return build()</pre>
                </div>
            </details>
        </div>
    </div>


    <div class="flashcard" id="card-3">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-route" style="color: var(--must);"></i>
                <span>Maximum Path Sum</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Global vs Local</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('maxpath-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('maxpath-space')">
                    <i class="fas fa-server"></i> O(H) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="maxpath-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We traverse every node exactly once using post-order DFS to calculate the max path from the bottom up.
            </div>
            <div id="maxpath-space-explainer" class="metric-explainer">
                <strong>Why O(H)?</strong> <br>
                Recursion stack space depends on tree height.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Inverted V"</strong><br>At every node, you have two choices:<br>1. <strong>The Split (Global Update):</strong> Curve path (Left + Node + Right).<br>2. <strong>The Flow (Return Value):</strong> Straight path (Node + max(Left, Right)) to Parent.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                This requires a <strong>Global Variable</strong> to track the "Split" score, while the recursion returns the "Flow" score.
                <br>1. <strong>Left Gain:</strong> `max(dfs(root.left), 0)` (0 ignores negative paths).
                <br>2. <strong>Right Gain:</strong> `max(dfs(root.right), 0)`.
                <br>3. <strong>Update Global:</strong> `Score = root.val + Left + Right`.
                <br>4. <strong>Return Up:</strong> `root.val + max(Left, Right)`.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Negative Numbers:</strong> 
                <br>If a subtree sum is negative (e.g., -10), adding it to your path only hurts you.
                <br><strong>Fix:</strong> Always clamp the recursive result with 0: `max(gain, 0)`. This effectively "cuts off" the bad branch.
            </div>

            <details>
                <summary>Python Solution (The Split Logic)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-maxpath')">Copy</button>
                    <pre id="code-maxpath">
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        # Initialize with -infinity (not 0, because answer could be negative)
        self.global_max = float('-inf')
        
        def get_max_gain(node):
            if not node:
                return 0
                
            # Recursion: Get max path sum from left and right children
            # TRICK: Use max(0, ...) to ignore negative paths!
            left_gain = max(get_max_gain(node.left), 0)
            right_gain = max(get_max_gain(node.right), 0)
            
            # 1. THE SPLIT (Potential New Global Max)
            # Price of the "Arch" (Left + Node + Right)
            current_path_price = node.val + left_gain + right_gain
            self.global_max = max(self.global_max, current_path_price)
            
            # 2. THE FLOW (Return to Parent)
            # Can only extend ONE arm up to the parent
            return node.val + max(left_gain, right_gain)
            
        get_max_gain(root)
        return self.global_max</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-4">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-hammer" style="color: var(--must);"></i>
                <span>Construct Tree (Pre+In)</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Index Mastery</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('build-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('build-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="build-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                Using a HashMap for O(1) index lookup, we visit every node exactly once to construct it. <br><em>Note: Without the map, searching the array takes O(N) per node, leading to O(N¬≤).</em>
            </div>
            <div id="build-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We need O(N) for the HashMap and O(H) for recursion stack.
            </div>

            <div class="visual-area">
                 
                <br>
                <span><strong>Visual: The Knife</strong><br>1. <strong>Preorder</strong> tells you WHO is the Root (First element).<br>2. <strong>Inorder</strong> tells you the SIZE of Left/Right subtrees.<br>The Root acts as a knife, slicing the Inorder array into two halves.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Formula for Recursion:</strong>
                <br>1. Root = `preorder[pre_start]`.
                <br>2. Find Root's index in Inorder (`mid`).
                <br>3. <strong>Size of Left Subtree</strong> = `mid - in_start`.
                <br>4. <strong>Left Child:</strong> `pre_start + 1`.
                <br>5. <strong>Right Child:</strong> `pre_start + left_size + 1` (Jump over the entire left subtree).
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Python Slicing:</strong> 
                <br>Do not write `build(pre[1:], in[:mid])`. 
                <br>Array slicing creates a <strong>copy</strong> of the array (O(k) time). Doing this inside recursion explodes time complexity to O(N¬≤).
                <br><strong>Fix:</strong> Pass integer indices (`low`, `high`) pointers instead of slicing arrays.
            </div>

            <details>
                <summary>Python Solution (O(N) with Map)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-build')">Copy</button>
                    <pre id="code-build">
def buildTree(preorder, inorder):
    # Optimisation: Map Value -> Index for O(1) lookup
    in_map = {val: i for i, val in enumerate(inorder)}
    
    # We use 'pre_idx' as a global tracker or nonlocal
    # because it moves forward 1-by-1 naturally.
    pre_iter = iter(preorder)

    def build(left, right):
        # Base Case: No elements to construct subtree
        if left > right:
            return None
            
        # 1. Pick current root from Preorder
        root_val = next(pre_iter)
        root = TreeNode(root_val)
        
        # 2. Find split point in Inorder
        mid = in_map[root_val]
        
        # 3. Recurse (Preorder logic: Root->Left->Right)
        # We must build Left first because 'pre_iter' yields left children next
        root.left = build(left, mid - 1)
        root.right = build(mid + 1, right)
        
        return root
        
    return build(0, len(inorder) - 1)</pre>
                </div>
            </details>
        </div>
    </div>



    <div class="flashcard" id="card-5">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-arrows-alt-v" style="color: var(--good);"></i>
                <span>Vertical Order Traversal</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good">GOOD</span>
                <span class="tag">Coordinates + BFS</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('vert-time')">
                    <i class="far fa-clock"></i> O(N log N) <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('vert-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="vert-time-explainer" class="metric-explainer">
                <strong>Why O(N log N)?</strong> <br>
                Traversal is O(N), but the problem requires us to **Sort** the nodes that land on the same vertical line (and sometimes same row). Sorting dominates the complexity.
            </div>
            <div id="vert-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We store every node in a HashMap (Grouped by Column).
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Grid Overlay</strong><br>Map every node to <code>(row, col)</code>.<br>Root = <code>(0,0)</code>.<br>Left Child = <code>(row+1, col-1)</code>.<br>Right Child = <code>(row+1, col+1)</code>.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                This is a <strong>Grouping + Sorting</strong> problem.
                <br>1. <strong>Traverse (BFS):</strong> Assign `(row, col)` to every node.
                <br>2. <strong>Group:</strong> Store nodes in a Table: `Column -> List of (Row, Value)`.
                <br>3. <strong>Sort:</strong> For each column, sort the list by `Row` first, then by `Value` (for ties).
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "Shadow" Nodes:</strong> 
                <br>In complex trees, a node from the left branch <code>(2, 0)</code> and a node from the right branch <code>(2, 0)</code> can land on the exact same coordinate.
                <br><strong>Requirement:</strong> If Row and Col are same, sort by <strong>Node Value</strong>. You must store `(row, val)` tuples to handle this.
            </div>

            <details>
                <summary>Python Solution (BFS + Sorting)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-vert')">Copy</button>
                    <pre id="code-vert">
from collections import deque, defaultdict

def verticalTraversal(root):
    # Map: Column Index -> List of (Row, Val)
    column_table = defaultdict(list)
    
    # BFS Queue: (Node, Row, Col)
    queue = deque([(root, 0, 0)])
    
    # Track min/max col to iterate easily later
    min_col, max_col = 0, 0

    while queue:
        node, row, col = queue.popleft()
        
        if node:
            # Store data for sorting later
            column_table[col].append((row, node.val))
            
            min_col = min(min_col, col)
            max_col = max(max_col, col)
            
            # Add children with updated coordinates
            queue.append((node.left, row + 1, col - 1))
            queue.append((node.right, row + 1, col + 1))
            
    # Construct Result
    res = []
    # Iterate from left-most column to right-most
    for c in range(min_col, max_col + 1):
        # Sort Rule: 1. By Row (r), 2. By Value (v)
        sorted_nodes = sorted(column_table[c], key=lambda x: (x[0], x[1]))
        
        # Extract just the values
        res.append([val for row, val in sorted_nodes])
        
    return res</pre>
                </div>
            </details>
        </div>
    </div>


    <div class="flashcard" id="card-6">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-code-branch" style="color: var(--good);"></i>
                <span>LCA in BST</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good">GOOD</span>
                <span class="tag">BST Property</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('lcabst-time')">
                    <i class="far fa-clock"></i> O(H) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('lcabst-space')">
                    <i class="fas fa-server"></i> O(1) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="lcabst-time-explainer" class="metric-explainer">
                <strong>Why O(H)?</strong> <br>
                We don't need to visit every node. We just descend down a single path (Left or Right) based on values, similar to Binary Search. H = Height.
            </div>
            <div id="lcabst-space-explainer" class="metric-explainer">
                <strong>Why O(1)?</strong> <br>
                By using a <code>while</code> loop instead of recursion, we avoid the call stack overhead completely.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Fork in the Road</strong><br>1. If both targets are smaller than me: Go Left.<br>2. If both targets are larger than me: Go Right.<br>3. If they split (one small, one big) OR I am one of them: <strong>I am the Split Point (LCA).</strong></span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Don't use DFS. Use the Sort Order.</strong>
                <br>In a BST, the LCA is the <strong>first node</strong> (from top) that lies between the values `p` and `q`.
                <br>Condition: <code>min(p, q) <= Node.val <= max(p, q)</code>.
                <br>Once you find this node, you cannot go lower without losing one of the targets.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Over-Engineering:</strong> 
                <br>Many candidates instinctively write the O(N) generic Binary Tree solution. This is correct but "Senior-Level Fail". You ignored the BST property (Sorted), making your code slower and memory-heavy.
            </div>

            <details>
                <summary>Python Solution (Iterative O(1) Space)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-lcabst')">Copy</button>
                    <pre id="code-lcabst">
def lowestCommonAncestor(root, p, q):
    # Iterative Approach for O(1) Space
    # We treat 'root' as a pointer we move down
    curr = root
    
    while curr:
        # Case 1: Both P and Q are smaller -> Go Left
        if p.val < curr.val and q.val < curr.val:
            curr = curr.left
            
        # Case 2: Both P and Q are larger -> Go Right
        elif p.val > curr.val and q.val > curr.val:
            curr = curr.right
            
        # Case 3: The Split Point (LCA)
        # One is smaller, one is larger (or equal)
        else:
            return curr
            
    return None</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-7">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-search-plus" style="color: var(--accent);"></i>
                <span>Largest BST in BT</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good" style="background: #ecfdf5; color: #047857; border-color: #6ee7b7;">BONUS</span>
                <span class="tag">Bottom-Up DP</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('lrg-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('lrg-space')">
                    <i class="fas fa-server"></i> O(H) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="lrg-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We use Post-Order Traversal (Bottom-Up). We visit each node once, and perform constant-time comparisons with data returned from children. <br><em>Naive Top-Down approach would be O(N¬≤).</em>
            </div>
            <div id="lrg-space-explainer" class="metric-explainer">
                <strong>Why O(H)?</strong> <br>
                Recursion stack space.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Certificate" of Authenticity</strong><br>Every child sends a certificate up to its parent:<br><em>"I am a valid BST, my range is [10-20], and my size is 5."</em><br>The parent checks: "Does [10-20] fit my value?"</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Bottom-Up Intelligence:</strong>
                <br>To validate Node `X`, we need 4 pieces of info from Left and Right children:
                <br>1. <strong>Is BST?</strong> (Both children must be True).
                <br>2. <strong>Max of Left</strong> (Must be < X).
                <br>3. <strong>Min of Right</strong> (Must be > X).
                <br>4. <strong>Size</strong> (To update max size found so far).
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "None" Logic:</strong> 
                <br>Base case for `None` node must return:
                <br><code>Min = +Inf, Max = -Inf</code>.
                <br>Why? This forces the leaf node comparison `(-Inf < Leaf < +Inf)` to always be True. It simplifies the code massively.
            </div>

            <details>
                <summary>Python Solution (Post-Order Traversal)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-lrg')">Copy</button>
                    <pre id="code-lrg">
class NodeValue:
    def __init__(self, min_node, max_node, max_size):
        self.min_node = min_node
        self.max_node = max_node
        self.max_size = max_size

class Solution:
    def largestBST(self, root):
        self.ans = 0
        
        def post_order(node):
            if not node:
                # Base Case: An empty tree is a valid BST of size 0.
                # TRICK: Return min=inf, max=-inf to pass parent checks naturally
                return NodeValue(float('inf'), float('-inf'), 0)
            
            left = post_order(node.left)
            right = post_order(node.right)
            
            # Check if Current Node creates a valid BST
            # 1. Left Max < Node < Right Min
            if left.max_node < node.val < right.min_node:
                # It's a valid BST extension!
                # Update global max size
                curr_size = left.max_size + right.max_size + 1
                self.ans = max(self.ans, curr_size)
                
                # Pass range up (Min comes from left, Max from right)
                return NodeValue(min(node.val, left.min_node), 
                                 max(node.val, right.max_node), 
                                 curr_size)
            
            else:
                # Not a valid BST. 
                # Pass junk data up so parent cannot form a BST.
                return NodeValue(float('-inf'), float('inf'), max(left.max_size, right.max_size))
                
        post_order(root)
        return self.ans</pre>
                </div>
            </details>
        </div>
    </div>
    <div class="flashcard" id="card-8">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-fire" style="color: var(--must);"></i>
                <span>Burn a Binary Tree</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good" style="background: #ecfdf5; color: #047857; border-color: #6ee7b7;">BONUS</span>
                <span class="tag">Graph Conversion</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('burn-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('burn-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="burn-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                1. Pass 1: Map parents (DFS) -> O(N).<br>
                2. Pass 2: Burn Tree (BFS) -> O(N).<br>
                Total is Linear.
            </div>
            <div id="burn-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We store the Parent Map (HashMap of N nodes) and the BFS Queue.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Infection</strong><br>The fire starts at the <code>Target</code> node.<br>At <code>t=1</code>, it infects Parent, Left Child, and Right Child.<br>We treat the tree as an Undirected Graph.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>The "Upward" Block:</strong> Standard Trees only point down.
                <br><strong>Solution:</strong>
                <br>1. <strong>Map Parents:</strong> Run a DFS/BFS to store <code>{Node: Parent}</code> in a HashMap.
                <br>2. <strong>BFS from Target:</strong> Start a queue with the Target.
                <br>3. <strong>Spread:</strong> For every node popped, push its <code>Left</code>, <code>Right</code>, and <code>Parent</code> (if not visited) into the queue.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Starting BFS from Root:</strong> 
                <br>Many candidates instinctively start BFS from the Tree Root.
                <br><strong>Wrong!</strong> The fire starts at the <code>Target</code> Node. You must locate the target first (or be given its reference), then ripple outwards.
            </div>

            <details>
                <summary>Python Solution (Parent Map + BFS)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-burn')">Copy</button>
                    <pre id="code-burn">
from collections import deque

def minTime(root, target_val):
    # 1. Create Parent Pointers (Map Child -> Parent)
    # AND find the actual Target Node object
    parent_map = {}
    target_node = None
    
    def map_parents(node, parent):
        nonlocal target_node
        if not node: return
        
        if parent:
            parent_map[node] = parent
            
        if node.val == target_val:
            target_node = node
            
        map_parents(node.left, node)
        map_parents(node.right, node)
        
    map_parents(root, None)
    
    # 2. BFS from Target (Burn Logic)
    queue = deque([target_node])
    visited = {target_node}
    time = 0
    
    while queue:
        # Process level by level (one second of burning)
        burned_something = False
        
        for _ in range(len(queue)):
            curr = queue.popleft()
            
            # Try to burn Left, Right, Up (Parent)
            for neighbor in [curr.left, curr.right, parent_map.get(curr)]:
                if neighbor and neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)
                    burned_something = True
        
        if burned_something:
            time += 1
            
    return time</pre>
                </div>
            </details>
        </div>
    </div>



</div>

<script>
    function toggleExplainer(type) {
        document.querySelectorAll('.metric-explainer').forEach(el => el.style.display = 'none');
        const target = document.getElementById(`${type}-explainer`);
        if (target) target.style.display = 'block';
    }

    function copyCode(id) {
        const code = document.getElementById(id).innerText;
        navigator.clipboard.writeText(code).then(() => {
            alert('Code copied to clipboard!');
        });
    }
</script>

</body>
</html>