<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 3: Monotonic Stack Mastery</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg: #f0f2f5;
            --card-bg: #ffffff;
            --text-main: #1a202c;
            --text-muted: #64748b;
            --primary: #7c3aed; /* Purple for Stacks (Deep/Abstract) */
            --primary-light: #f5f3ff;
            --accent: #d946ef;
            --must: #dc2626;
            --must-bg: #fef2f2;
            --code-bg: #1e293b;
        }
        
        * { box-sizing: border-box; transition: all 0.2s ease; }
        body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text-main); margin: 0; padding: 40px 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }

        /* Header */
        .header-section { text-align: center; margin-bottom: 40px; }
        .header-section h1 { font-size: 2.5rem; margin-bottom: 10px; color: var(--text-main); letter-spacing: -1px; }
        
        /* Principal's Thinking Model */
        .pattern-card { background: linear-gradient(135deg, #1e1b4b, #312e81); color: white; padding: 30px; border-radius: 16px; margin-bottom: 40px; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2); }
        .pattern-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .pattern-col h4 { color: var(--accent); margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .code-snippet { font-family: 'Menlo', monospace; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; color: #fbbf24; font-size: 0.9em; }

        /* Question Cards */
        .flashcard { background: var(--card-bg); border-radius: 16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 30px; overflow: hidden; border: 1px solid #e2e8f0; position: relative; }
        
        .card-header { padding: 20px 25px; border-bottom: 1px solid #f1f5f9; display: flex; justify-content: space-between; align-items: center; background: #fff; }
        .q-title { font-weight: 800; font-size: 1.25rem; color: var(--text-main); display: flex; align-items: center; gap: 12px; }
        
        /* Badges */
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 6px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-must { background: var(--must-bg); color: var(--must); border: 1px solid #fecaca; }
        .tag { font-size: 0.85rem; color: var(--text-muted); background: #f1f5f9; padding: 4px 12px; border-radius: 20px; font-weight: 500; }

        .card-body { padding: 25px; }

        /* Metrics */
        .metrics { display: flex; gap: 20px; margin-bottom: 10px; font-family: 'Menlo', monospace; font-size: 0.85rem; }
        .metric-item { display: flex; align-items: center; gap: 6px; background: #f8fafc; padding: 8px 12px; border-radius: 6px; border: 1px solid #e2e8f0; color: var(--text-muted); cursor: pointer; }
        .metric-item:hover { border-color: var(--primary); color: var(--primary); background: var(--primary-light); }
        
        /* Hidden Explanation Box */
        .metric-explainer { 
            display: none; 
            background: #fffbeb; 
            border: 1px solid #fde68a; 
            padding: 15px; 
            border-radius: 8px; 
            font-size: 0.9rem; 
            margin-bottom: 20px; 
            color: #92400e;
            animation: fadeIn 0.3s ease;
        }

        /* Logic Boxes */
        .info-box { padding: 20px; border-radius: 8px; margin-bottom: 20px; font-size: 0.95rem; position: relative; margin-top: 15px; }
        .logic-box { background: var(--primary-light); border-left: 5px solid var(--primary); }
        .trap-box { background: var(--must-bg); border-left: 5px solid var(--must); color: #991b1b; }
        
        .box-label { position: absolute; top: -10px; left: 15px; background: inherit; padding: 0 8px; font-size: 0.75rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; border-radius: 4px; }

        /* Visual Placeholder */
        .visual-area { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 8px; padding: 20px; text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .visual-area i { font-size: 1.5rem; color: var(--primary); }

        /* Dry Run Section */
        .dry-run { background: #1e293b; color: #cbd5e1; padding: 20px; border-radius: 8px; font-family: 'Consolas', monospace; font-size: 0.85rem; margin-bottom: 20px; border-left: 4px solid #fbbf24; }
        .dry-step { margin-bottom: 10px; border-bottom: 1px solid #334155; padding-bottom: 10px; }
        .dry-step:last-child { border: none; margin: 0; padding: 0; }
        .var-highlight { color: #93c5fd; font-weight: bold; }

        /* Code Section */
        details { margin-top: 15px; background: var(--code-bg); border-radius: 8px; overflow: hidden; }
        summary { padding: 12px 20px; cursor: pointer; color: #e2e8f0; font-weight: 600; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; list-style: none; }
        summary:hover { background: rgba(255,255,255,0.05); }
        summary::after { content: 'Show Code \f121'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        details[open] summary::after { content: 'Hide Code \f128'; }
        
        pre { margin: 0; padding: 20px; overflow-x: auto; color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.9rem; line-height: 1.5; position: relative; border-top: 1px solid #334155; }
        .copy-btn { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* Responsive */
        @media (max-width: 600px) { .pattern-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div class="container">

    <div class="header-section">
        <h1>3Ô∏è‚É£ Monotonic Stack Mastery</h1>
        <p style="color: var(--text-muted);">Principal Engineer DSA ‚Ä¢ Day 3</p>
    </div>

    <div class="pattern-card">
        <h3><i class="fas fa-layer-group"></i> Principal's Mental Model</h3>
        
        <div class="pattern-grid">
            <div class="pattern-col">
                <h4><i class="fas fa-brain"></i> The "Delayed Processing" Concept</h4>
                <p style="font-size: 0.9rem; opacity: 0.9;">
                    We use a Stack when we can't solve the problem yet.
                    <br><strong>"Put it in the stack and wait for the right element to trigger the solution."</strong>
                    <br>Common Trigger: finding the "Next Greater" or "Next Smaller" element.
                </p>
            </div>
            <div class="pattern-col">
                <h4 style="color: #fbbf24;"><i class="fas fa-shield-alt"></i> The "10x" Safety Check</h4>
                <ul style="padding-left: 20px; line-height: 1.6; font-size: 0.9rem;">
                    <li><strong>Empty Stack:</strong> Always check `if stack:` before peeking/popping.</li>
                    <li><strong>Decreasing vs Increasing:</strong>
                        <br>Find Next Greater -> Use <span class="code-snippet">Decreasing Stack</span>
                        <br>Find Next Smaller -> Use <span class="code-snippet">Increasing Stack</span>
                    </li>
                </ul>
            </div>
        </div>
    </div>

    <div class="flashcard" id="card-1">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-arrow-right" style="color: var(--primary);"></i>
                <span>Next Greater Element</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Monotonic Stack</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                Even though we have a while loop inside the for loop, <strong>each element is pushed exactly once and popped at most once.</strong> Total operations ‚â§ 2N.
            </div>
            <div id="space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                In the worst case (a strictly decreasing array like `[5, 4, 3, 2, 1]`), nothing ever gets popped until the end, so the stack stores all N elements.
            </div>

            <div class="visual-area">
                 
                <br>
                <span><strong>Visual: The Horizon</strong><br>Imagine people standing in a line looking Right.<br>You can only see the first person taller than you. Everyone smaller than that person is "hidden" or blocked.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Maintain a Decreasing Stack.</strong>
                <br>As we iterate, if the `current` number is BIGGER than the `stack.top`, then `current` is the <strong>Next Greater Element</strong> for `stack.top`.
                <br>Pop the small guy, record the answer, and repeat.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Leftovers:</strong> 
                <br>Any elements remaining in the stack at the end have <strong>NO</strong> next greater element. Their answer is usually -1.
                <br>Don't forget to initialize your result array with -1s to handle this automatically.
            </div>

            <h4 style="margin: 0 0 10px 0; color: var(--text-muted); font-size: 0.9rem; text-transform: uppercase;">Step-by-Step Dry Run</h4>
            <div class="dry-run">
                <div><strong>Input:</strong> [2, 1, 5]</div>
                <br>
                <div class="dry-step">
                    1. <strong>Current: 2</strong>. Stack empty. <br>
                    -> Push 2. Stack: [2]
                </div>
                <div class="dry-step">
                    2. <strong>Current: 1</strong>. Is 1 > 2 (top)? No. <br>
                    -> Push 1. Stack: [2, 1] (Decreasing order maintained)
                </div>
                <div class="dry-step">
                    3. <strong>Current: 5</strong>. Is 5 > 1? <strong>YES!</strong><br>
                    -> NGE of 1 is 5. Pop 1.<br>
                    -> Is 5 > 2? <strong>YES!</strong><br>
                    -> NGE of 2 is 5. Pop 2.<br>
                    -> Push 5. Stack: [5].
                </div>
            </div>

            <details open>
                <summary>Python Solution (Template)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code1')">Copy</button>
                    <pre id="code1">
def nextGreaterElements(nums):
    # Initialize result with -1 (default for no greater element)
    res = [-1] * len(nums)
    stack = []  # Stores INDICES, not values
    
    for i, current_val in enumerate(nums):
        # While we found a number bigger than the stack top...
        while stack and current_val > nums[stack[-1]]:
            index_to_update = stack.pop()
            res[index_to_update] = current_val
            
        stack.append(i)
        
    return res</pre>
                </div>
            </details>
        </div>
    </div>


    <div class="flashcard" id="card-2">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-chart-bar" style="color: var(--must);"></i>
                <span>Largest Rectangle in Histogram</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">The "Boss" Problem</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('hist-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('hist-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="hist-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                Every bar is pushed onto the stack exactly once and popped exactly once. Linear time guaranteed.
            </div>
            <div id="hist-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                In the case of a strictly increasing array (e.g., [1, 2, 3, 4, 5]), the stack will hold all elements until the end.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Expansion Limits</strong><br>For every bar, ask: "How far Left and Right can I extend before I hit a shorter bar?"<br>That span is the width. The bar itself is the height.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>The "Pop" Moment is Key.</strong>
                <br>When we encounter a bar <strong>smaller</strong> than the stack top, we must resolve the stack top.
                <br>1. <strong>Height:</strong> The bar we just popped.
                <br>2. <strong>Right Boundary:</strong> The current index `i` (triggered the pop).
                <br>3. <strong>Left Boundary:</strong> The *new* stack top (after pop).
                <br><code>Width = Right - Left - 1</code>
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "Leftover" Stack:</strong> 
                <br>If the array is `[1, 2, 3]`, nothing gets popped, and the loop finishes. You'd need a second loop to clear the stack.
                <br><strong>Pro Trick:</strong> Append a `0` to the end of heights `heights.append(0)`. This forces every remaining element to pop automatically at the end.
            </div>

            <h4 style="margin: 0 0 10px 0; color: var(--text-muted); font-size: 0.9rem; text-transform: uppercase;">Step-by-Step Dry Run</h4>
            <div class="dry-run">
                <div><strong>Input:</strong> [2, 1, 5, 6, 2, 3] + (Dummy 0)</div>
                <br>
                <div class="dry-step">
                    1. Stack: [2]. Current: 1. (1 < 2). <strong>POP 2</strong>.<br>
                    Height=2. Width=1 (index 1 - (-1) - 1). Area=2.
                </div>
                <div class="dry-step">
                    2. Stack: [1, 5, 6]. Current: 2. (2 < 6). <strong>POP 6</strong>.<br>
                    Height=6. Left Boundary=5 (index 2). Width=1. Area=6.
                </div>
                <div class="dry-step">
                    3. Stack: [1, 5]. Current: 2. (2 < 5). <strong>POP 5</strong>.<br>
                    Height=5. Left Boundary=1 (index 1). Width=2 (idx 4 - 1 - 1). Area=10. <strong>(Max So Far)</strong>
                </div>
            </div>

            <details>
                <summary>Python Solution (The Dummy 0 Trick)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-hist')">Copy</button>
                    <pre id="code-hist">
def largestRectangleArea(heights):
    max_area = 0
    stack = [] # pair: (index, height)
    
    # TRICK: Append 0 to force pop everything at the end
    heights.append(0)
    
    for i, h in enumerate(heights):
        start = i
        
        # Maintain Monotonic Increasing Stack
        # If current h is smaller than top, pop & calculate area
        while stack and stack[-1][1] > h:
            index, height = stack.pop()
            
            # Width extends from the popped index to current i
            width = i - index
            max_area = max(max_area, height * width)
            
            # Key: The current bar 'h' can extend backwards 
            # to the index we just popped!
            start = index
            
        stack.append((start, h))
        
    return max_area</pre>
                </div>
            </details>
        </div>
    </div>


    <div class="flashcard" id="card-3">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-water" style="color: var(--accent);"></i>
                <span>Trapping Rain Water (Stack)</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good">GOOD</span>
                <span class="tag">Horizontal Slicing</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('rain-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('rain-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="rain-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                Similar to Histogram, we process each bar exactly twice (push once, pop once).
            </div>
            <div id="rain-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                The stack can store up to N/2 elements in a zigzag pattern (e.g., [5, 4, 3, 2, 1, ...]). <br>
                <em>Note: A "Two Pointer" solution exists with O(1) space, but the Stack approach is crucial for understanding bounded regions.</em>
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Bowl" Creation</strong><br>We don't fill columns. We fill <strong>horizontal layers</strong>.<br>When we find a Right Wall (taller bar), we look back at the Floor (stack top) and Left Wall (next in stack) to calculate the volume of that layer.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Trigger:</strong> When `current_h > stack.top`, we have found a right wall. A bowl might exist!
                <br>1. <strong>The Floor:</strong> Pop the top. This is the bottom of the pool.
                <br>2. <strong>The Left Wall:</strong> Peek at the *new* top.
                <br>3. <strong>The Right Wall:</strong> The current element `i`.
                <br><strong>Water = (min(Left, Right) - Floor) √ó Distance</strong>
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "Flat" Floor:</strong> 
                <br>If the stack has duplicate heights (e.g., `[4, 2, 2, 5]`), popping the first `2` gives a floor. The next `2` is the same height, so <code>(2 - 2) * width</code> results in 0 water. This is correct! The algorithm handles flat bottoms naturally.
            </div>

            <h4 style="margin: 0 0 10px 0; color: var(--text-muted); font-size: 0.9rem; text-transform: uppercase;">Step-by-Step Dry Run</h4>
            <div class="dry-run">
                <div><strong>Input:</strong> [3, 0, 0, 2, 0, 4]</div>
                <br>
                <div class="dry-step">
                    1. Push 3, 0, 0. Stack: [idx:0, 1, 2]. Current: 2.
                </div>
                <div class="dry-step">
                    2. 2 > 0 (top). <strong>Found Dip!</strong><br>
                    -> Floor=0 (pop idx 2). Left Wall=0 (idx 1). Right Wall=2.<br>
                    -> Height = min(0, 2) - 0 = 0. No water (flat bottom).
                </div>
                <div class="dry-step">
                    3. 2 > 0 (new top). <strong>Found Dip!</strong><br>
                    -> Floor=0 (pop idx 1). Left Wall=3 (idx 0). Right Wall=2.<br>
                    -> Height = min(3, 2) - 0 = 2. Width = (3 - 0 - 1) = 2.<br>
                    -> <strong>Water += 4</strong>. Push 2. Stack: [0, 3].
                </div>
            </div>

            <details>
                <summary>Python Solution (The Horizontal Slice)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-rain')">Copy</button>
                    <pre id="code-rain">
def trap(height):
    stack = []  # Stores INDICES
    water = 0
    
    for i, h in enumerate(height):
        # We need a monotonic decreasing stack.
        # If current h is taller, we found a "Right Wall".
        while stack and h > height[stack[-1]]:
            floor_idx = stack.pop()
            
            # If stack empty after pop, no Left Wall exists -> No water
            if not stack:
                break
                
            left_wall_idx = stack[-1]
            
            # Calculations
            w = i - left_wall_idx - 1
            bounded_height = min(height[left_wall_idx], h) - height[floor_idx]
            
            water += w * bounded_height
            
        stack.append(i)
        
    return water</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-4">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-meteor" style="color: var(--must);"></i>
                <span>Asteroid Collision</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good" style="background: #ecfdf5; color: #047857; border-color: #6ee7b7;">BONUS</span>
                <span class="tag">Simulation</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('ast-time')">
                    <i class="far fa-clock"></i> O(N) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('ast-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="ast-time-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                Every asteroid is pushed onto the stack at most once and popped (exploded) at most once. Operations are linear relative to the input size.
            </div>
            <div id="ast-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                In the worst case (e.g., all moving Right `[1, 2, 3, 4]`), no collisions occur, and we store all asteroids.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The One-Way Street</strong><br>Collision Condition: <code>StackTop = Right (‚Üí)</code> AND <code>Current = Left (‚Üê)</code>.<br>Any other combination (‚Üí ‚Üí, ‚Üê ‚Üê, ‚Üê ‚Üí) is peaceful.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                We only use the stack to store <strong>Right-Moving</strong> asteroids (and survivors).
                <br>When we encounter a <strong>Left-Moving</strong> asteroid, it battles the stack top.
                <br>1. <strong>Stack Top Small?</strong> Pop stack (Top dies). Repeat check.
                <br>2. <strong>Equal Size?</strong> Pop stack. Both die.
                <br>3. <strong>Stack Top Huge?</strong> Current asteroid dies. Stop check.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "Empty" Stack:</strong> 
                <br>If a Left asteroid destroys everyone in the stack (or stack was empty), <strong>it survives</strong>.
                <br>You must push this survivor onto the stack so it becomes part of the result (e.g., `[-5, 10]`).
            </div>

            <h4 style="margin: 0 0 10px 0; color: var(--text-muted); font-size: 0.9rem; text-transform: uppercase;">Step-by-Step Dry Run</h4>
            <div class="dry-run">
                <div><strong>Input:</strong> [5, 10, -15]</div>
                <br>
                <div class="dry-step">
                    1. <strong>5 (Right)</strong> -> Push. Stack: [5].
                </div>
                <div class="dry-step">
                    2. <strong>10 (Right)</strong> -> Push. Stack: [5, 10].
                </div>
                <div class="dry-step">
                    3. <strong>-15 (Left)</strong> vs Top (10).<br>
                    -> |-15| > 10. <strong>10 Explodes!</strong> Stack: [5]. (Keep checking -15)<br>
                    -> -15 vs Top (5).<br>
                    -> |-15| > 5. <strong>5 Explodes!</strong> Stack: []. (Keep checking -15)<br>
                    -> Stack Empty. <strong>-15 Survives.</strong> Push -15.
                </div>
                <div class="dry-step">
                    <strong>Result:</strong> [-15]
                </div>
            </div>

            <details>
                <summary>Python Solution (Clean Simulation)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-ast')">Copy</button>
                    <pre id="code-ast">
def asteroidCollision(asteroids):
    stack = []
    
    for ast in asteroids:
        # Collision loop: Only happens if stack has Right (>) 
        # and current is Left (<)
        while stack and ast < 0 and stack[-1] > 0:
            
            diff = ast + stack[-1]
            
            if diff < 0:
                # Top is smaller (e.g. 10 + -15 = -5)
                # Top explodes, continue checking current 'ast'
                stack.pop()
            elif diff > 0:
                # Top is bigger (e.g. 20 + -15 = 5)
                # Current 'ast' explodes, break loop
                ast = 0 # Mark as destroyed
                break
            else:
                # Same size (e.g. 10 + -10 = 0)
                # Both explode
                ast = 0
                stack.pop()
                break
        
        if ast != 0:
            stack.append(ast)
            
    return stack</pre>
                </div>
            </details>
        </div>
    </div>
</div>

<script>
    function toggleExplainer(type) {
        document.querySelectorAll('.metric-explainer').forEach(el => el.style.display = 'none');
        const target = document.getElementById(`${type}-explainer`);
        if (target) target.style.display = 'block';
    }

    function copyCode(id) {
        const code = document.getElementById(id).innerText;
        navigator.clipboard.writeText(code).then(() => {
            alert('Code copied to clipboard!');
        });
    }
</script>

</body>
</html>