<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Day 6: Graph Mastery</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg: #f0f2f5;
            --card-bg: #ffffff;
            --text-main: #1a202c;
            --text-muted: #64748b;
            --primary: #c026d3; /* Fuschia for Graphs (Nodes/Complex) */
            --primary-light: #fdf4ff;
            --accent: #d946ef;
            --must: #dc2626;
            --must-bg: #fef2f2;
            --code-bg: #1e293b;
        }
        
        * { box-sizing: border-box; transition: all 0.2s ease; }
        body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text-main); margin: 0; padding: 40px 20px; line-height: 1.6; }
        .container { max-width: 900px; margin: 0 auto; }

        /* Header */
        .header-section { text-align: center; margin-bottom: 40px; }
        .header-section h1 { font-size: 2.5rem; margin-bottom: 10px; color: var(--text-main); letter-spacing: -1px; }
        
        /* Principal's Thinking Model */
        .pattern-card { background: linear-gradient(135deg, #4a044e, #701a75); color: white; padding: 30px; border-radius: 16px; margin-bottom: 40px; box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.2); }
        .pattern-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .pattern-col h4 { color: var(--accent); margin-top: 0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .code-snippet { font-family: 'Menlo', monospace; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; color: #fbbf24; font-size: 0.9em; }

        /* Question Cards */
        .flashcard { background: var(--card-bg); border-radius: 16px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); margin-bottom: 30px; overflow: hidden; border: 1px solid #e2e8f0; position: relative; }
        
        .card-header { padding: 20px 25px; border-bottom: 1px solid #f1f5f9; display: flex; justify-content: space-between; align-items: center; background: #fff; }
        .q-title { font-weight: 800; font-size: 1.25rem; color: var(--text-main); display: flex; align-items: center; gap: 12px; }
        
        /* Badges */
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 6px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }
        .badge-must { background: var(--must-bg); color: var(--must); border: 1px solid #fecaca; }
        .tag { font-size: 0.85rem; color: var(--text-muted); background: #f1f5f9; padding: 4px 12px; border-radius: 20px; font-weight: 500; }

        .card-body { padding: 25px; }

        /* Metrics */
        .metrics { display: flex; gap: 20px; margin-bottom: 10px; font-family: 'Menlo', monospace; font-size: 0.85rem; }
        .metric-item { display: flex; align-items: center; gap: 6px; background: #f8fafc; padding: 8px 12px; border-radius: 6px; border: 1px solid #e2e8f0; color: var(--text-muted); cursor: pointer; }
        .metric-item:hover { border-color: var(--primary); color: var(--primary); background: var(--primary-light); }
        
        /* Hidden Explanation Box */
        .metric-explainer { 
            display: none; 
            background: #fffbeb; 
            border: 1px solid #fde68a; 
            padding: 15px; 
            border-radius: 8px; 
            font-size: 0.9rem; 
            margin-bottom: 20px; 
            color: #92400e;
            animation: fadeIn 0.3s ease;
        }

        /* Logic Boxes */
        .info-box { padding: 20px; border-radius: 8px; margin-bottom: 20px; font-size: 0.95rem; position: relative; margin-top: 15px; }
        .logic-box { background: var(--primary-light); border-left: 5px solid var(--primary); }
        .trap-box { background: var(--must-bg); border-left: 5px solid var(--must); color: #991b1b; }
        
        .box-label { position: absolute; top: -10px; left: 15px; background: inherit; padding: 0 8px; font-size: 0.75rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1px; border-radius: 4px; }

        /* Visual Placeholder */
        .visual-area { background: #f8fafc; border: 2px dashed #cbd5e1; border-radius: 8px; padding: 20px; text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .visual-area i { font-size: 1.5rem; color: var(--primary); }

        /* Code Section */
        details { margin-top: 15px; background: var(--code-bg); border-radius: 8px; overflow: hidden; }
        summary { padding: 12px 20px; cursor: pointer; color: #e2e8f0; font-weight: 600; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; list-style: none; }
        summary:hover { background: rgba(255,255,255,0.05); }
        summary::after { content: 'Show Code \f121'; font-family: 'Font Awesome 6 Free'; font-weight: 900; }
        details[open] summary::after { content: 'Hide Code \f128'; }
        
        pre { margin: 0; padding: 20px; overflow-x: auto; color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.9rem; line-height: 1.5; position: relative; border-top: 1px solid #334155; }
        .copy-btn { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.1); border: none; color: white; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 0.8rem; }
        
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        /* Responsive */
        @media (max-width: 600px) { .pattern-grid { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

<div class="container">

    <div class="header-section">
        <h1>6Ô∏è‚É£ Graph Mastery</h1>
        <p style="color: var(--text-muted);">Principal Engineer DSA ‚Ä¢ Day 6</p>
    </div>

    <div class="pattern-card">
        <h3><i class="fas fa-project-diagram"></i> Principal's Decision Matrix</h3>
        
        <div class="pattern-grid">
            <div class="pattern-col">
                <h4><i class="fas fa-traffic-light"></i> Algorithm Selector</h4>
                <ul style="padding-left: 20px; line-height: 1.6; font-size: 0.9rem;">
                    <li><strong>Shortest Path (No weights):</strong> <span class="code-snippet">BFS</span> (Layer by layer).</li>
                    <li><strong>Shortest Path (Weights):</strong> <span class="code-snippet">Dijkstra</span> (Priority Queue).</li>
                    <li><strong>Dependencies/Order:</strong> <span class="code-snippet">Topo Sort</span> (Kahn's Algo).</li>
                    <li><strong>Connectivity/Merging:</strong> <span class="code-snippet">Union-Find (DSU)</span>.</li>
                </ul>
            </div>
            <div class="pattern-col">
                <h4 style="color: #fbbf24;"><i class="fas fa-shield-alt"></i> The "10x" Safety Check</h4>
                <p style="font-size: 0.9rem; opacity: 0.9;">
                    <strong>Never use DFS for shortest path.</strong> DFS goes down rabbit holes. 
                    <br><strong>Always track 'visited'</strong> immediately upon pushing to queue (BFS) to prevent cycles and duplicate processing.
                </p>
            </div>
        </div>
    </div>

    <div class="flashcard" id="card-1">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-viruses" style="color: var(--must);"></i>
                <span>Rotten Oranges</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Multi-Source BFS</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('bfs-time')">
                    <i class="far fa-clock"></i> O(N*M) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('bfs-space')">
                    <i class="fas fa-server"></i> O(N*M) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="bfs-time-explainer" class="metric-explainer">
                <strong>Why O(N*M)?</strong> <br>
                In the worst case (all oranges rot), we touch every cell in the grid exactly once.
            </div>
            <div id="bfs-space-explainer" class="metric-explainer">
                <strong>Why O(N*M)?</strong> <br>
                The BFS queue can store up to O(N*M) elements if the whole grid rots simultaneously.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Infection Wave</strong><br>Imagine all rotten oranges exploding <em>at the same time</em>.<br>The infection spreads in concentric circles (Layers).<br>Layer 0 = Initial Rotten. Layer 1 = Neighbors. Layer 2 = Neighbors of Neighbors.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Why BFS?</strong> Because rotting happens <strong>simultaneously</strong>. DFS is wrong because it simulates one orange rotting everything in a line before the others start.
                <br>1. <strong>Init:</strong> Push ALL initially rotten oranges into Queue.
                <br>2. <strong>Loop:</strong> Process level-by-level (Time += 1 per level).
                <br>3. <strong>Check:</strong> Did we rot all fresh ones?
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>The "Lonely" Fresh Orange:</strong> 
                <br>BFS finishes, but some fresh oranges might be walled off (unreachable).
                <br><strong>Fix:</strong> Count `total_fresh` at start. Decrement `fresh_cnt` every time you rot one. If `fresh_cnt > 0` at end, return -1.
            </div>

            <details open>
                <summary>Python Solution (Multi-Source BFS)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-bfs')">Copy</button>
                    <pre id="code-bfs">
from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    queue = deque()
    fresh_cnt = 0
    
    # 1. Initialize Queue with ALL rotten sources
    for r in range(rows):
        for c in range(cols):
            if grid[r][c] == 2:
                queue.append((r, c))
            elif grid[r][c] == 1:
                fresh_cnt += 1
                
    if fresh_cnt == 0: return 0
    
    minutes = 0
    directions = [(0,1), (0,-1), (1,0), (-1,0)]
    
    # 2. BFS Loop
    while queue and fresh_cnt > 0:
        minutes += 1
        # Process entire level (simultaneous rotting)
        for _ in range(len(queue)):
            r, c = queue.popleft()
            
            for dr, dc in directions:
                nr, nc = r + dr, c + dc
                # Check bounds and if fresh
                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                    grid[nr][nc] = 2 # Mark visited/rotten
                    fresh_cnt -= 1
                    queue.append((nr, nc))
                    
    return minutes if fresh_cnt == 0 else -1</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-2">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-list-ol" style="color: var(--must);"></i>
                <span>Course Schedule</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Topo Sort</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('topo-time')">
                    <i class="far fa-clock"></i> O(V + E) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('topo-space')">
                    <i class="fas fa-server"></i> O(V + E) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="topo-time-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                V = Courses, E = Prerequisites. <br>
                We visit every Vertex once and process every Edge (dependency) exactly once.
            </div>
            <div id="topo-space-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                We store the Adjacency List (Graph) and the Indegree array.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Unlock" Mechanism</strong><br>Arrows point FROM prerequisite TO course (Pre -> Course).<br><strong>Indegree 0:</strong> No requirements. Unlocked. Add to Queue.<br>When you finish a course, you remove its arrows. If a neighbor's arrows hit 0, it unlocks!</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Kahn's Algorithm (BFS):</strong>
                <br>1. <strong>Build Graph:</strong> `AdjList` and `Indegree Array`.
                <br>2. <strong>Start:</strong> Push all nodes with `Indegree == 0` (No prereqs) to Queue.
                <br>3. <strong>Process:</strong> Pop course, increment `completed_count`. For each neighbor, decrement their Indegree.
                <br>4. <strong>Unlock:</strong> If neighbor's Indegree becomes 0, push to Queue.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Cycle Detection:</strong> 
                <br>If `completed_count < numCourses` at the end, it means some nodes still have `Indegree > 0` and were never added to the queue.
                <br>This confirms a <strong>Cycle</strong> (Deadlock) exists. You cannot finish all courses.
            </div>

            <details>
                <summary>Python Solution (Kahn's Algo)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-topo')">Copy</button>
                    <pre id="code-topo">
from collections import deque, defaultdict

def canFinish(numCourses, prerequisites):
    # 1. Build Graph & Indegree
    # Graph: Prereq -> [Course A, Course B]
    adj = defaultdict(list)
    indegree = [0] * numCourses
    
    for course, pre in prerequisites:
        adj[pre].append(course)
        indegree[course] += 1
        
    # 2. Add "Unlocked" courses to Queue
    queue = deque()
    for i in range(numCourses):
        if indegree[i] == 0:
            queue.append(i)
            
    # 3. Process Queue
    completed_count = 0
    
    while queue:
        curr = queue.popleft()
        completed_count += 1
        
        # "Unlock" neighbors
        for neighbor in adj[curr]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
                
    # If we finished exactly 'numCourses', possible. Else, Cycle exists.
    return completed_count == numCourses</pre>
                </div>
            </details>
        </div>
    </div>
    <div class="flashcard" id="card-3">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-plane-departure" style="color: var(--must);"></i>
                <span>Network Delay Time</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Dijkstra's Algo</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('dij-time')">
                    <i class="far fa-clock"></i> O(E log V) <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('dij-space')">
                    <i class="fas fa-server"></i> O(V + E) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="dij-time-explainer" class="metric-explainer">
                <strong>Why O(E log V)?</strong> <br>
                We traverse every Edge (E). For each edge, we might push to the Priority Queue. Inserting into a Heap takes O(log V).
            </div>
            <div id="dij-space-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                Standard Adjacency List storage + Heap space.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The "Smart" Ripple</strong><br>Standard BFS spreads equally (1, 1, 1).<br>Dijkstra spreads based on Cost. It's a greedy ripple that always expands the <strong>cheapest known node</strong> first.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>BFS + Priority Queue = Dijkstra</strong>
                <br>1. <strong>State:</strong> `(Current_Cost, Node)`.
                <br>2. <strong>Min-Heap:</strong> Always pops the node with the lowest cumulative cost.
                <br>3. <strong>Relaxation:</strong> If `curr_cost + weight < dist[neighbor]`, update the distance and push to Heap.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Re-visiting Nodes:</strong> 
                <br>A node might be added to the Heap multiple times (via different paths).
                <br><strong>Optimization:</strong> When you pop `(cost, node)`, check `if cost > dist[node]: continue`. This skips "stale" or worse paths immediately.
            </div>

            <details>
                <summary>Python Solution (Dijkstra Template)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-dij')">Copy</button>
                    <pre id="code-dij">
import heapq
from collections import defaultdict

def networkDelayTime(times, n, k):
    # 1. Build Graph: Source -> (Target, Weight)
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))
        
    # 2. Priority Queue: (Total_Time, Node)
    # Start at node K with time 0
    pq = [(0, k)]
    
    # 3. Track Min Distances (Visited)
    # Initialize with Infinity
    min_time = {}
    
    while pq:
        curr_time, u = heapq.heappop(pq)
        
        # If we already found a faster way to 'u', skip
        if u in min_time:
            continue
            
        # "Visit" the node
        min_time[u] = curr_time
        
        # Explore Neighbors
        for v, time in graph[u]:
            if v not in min_time:
                # Push new path: Current accumulated time + edge weight
                heapq.heappush(pq, (curr_time + time, v))
                
    # If we visited all N nodes, return max time. Else -1.
    return max(min_time.values()) if len(min_time) == n else -1</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-4">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-link" style="color: var(--must);"></i>
                <span>Number of Provinces</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-must">MUST DO</span>
                <span class="tag">Union-Find</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('dsu-time')">
                    <i class="far fa-clock"></i> O(Œ±(N)) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('dsu-space')">
                    <i class="fas fa-server"></i> O(N) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="dsu-time-explainer" class="metric-explainer">
                <strong>Why O(Œ±(N))?</strong> <br>
                Inverse Ackermann Function. For all practical purposes, it is <strong>O(1)</strong> (amortized). <br>Path Compression makes the trees extremely flat, so finding the root is nearly instant.
            </div>
            <div id="dsu-space-explainer" class="metric-explainer">
                <strong>Why O(N)?</strong> <br>
                We store the <code>parent</code> array of size N and the <code>rank/size</code> array of size N.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Corporate Merger</strong><br>Initially, everyone is their own CEO (Self Loop).<br><strong>Union:</strong> Company A acquires Company B. B's CEO now reports to A's CEO.<br><strong>Path Compression:</strong> If you ask an intern who the CEO is, they go straight to the top and <em>remember</em> it for next time.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Find & Union Logic:</strong>
                <br>1. <strong>Find(x):</strong> Recursively find the parent. <strong>Optimization:</strong> Update `parent[x] = result` on the way back. This "flattens" the tree.
                <br>2. <strong>Union(x, y):</strong> Find `rootX` and `rootY`. If they are different, make one point to the other (`parent[rootY] = rootX`).
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Direct Assignment:</strong> 
                <br>Do NOT write `parent[x] = y`. This creates a long chain (O(N)).
                <br><strong>Correct:</strong> You MUST find the <strong>Roots</strong> first. `parent[rootX] = rootY`. Only the CEOs negotiate the merger!
            </div>

            <details>
                <summary>Python Solution (DSU Template)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-dsu')">Copy</button>
                    <pre id="code-dsu">
class DSU:
    def __init__(self, n):
        # Initially, everyone is their own parent
        self.parent = list(range(n))
        # Rank is used to keep tree flat (attach small tree to big tree)
        self.rank = [1] * n
        self.count = n # Track number of disconnected components

    def find(self, x):
        # Path Compression: Point directly to the ultimate root
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)

        if rootX != rootY:
            # Union by Rank: Attach smaller tree to bigger tree
            if self.rank[rootX] > self.rank[rootY]:
                self.parent[rootY] = rootX
            elif self.rank[rootX] < self.rank[rootY]:
                self.parent[rootX] = rootY
            else:
                self.parent[rootY] = rootX
                self.rank[rootX] += 1
            
            self.count -= 1 # Successful merge reduces components
            return True
        return False

def findCircleNum(isConnected):
    n = len(isConnected)
    dsu = DSU(n)
    
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j] == 1:
                dsu.union(i, j)
                
    return dsu.count</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-5">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-clone" style="color: var(--good);"></i>
                <span>Clone Graph</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good">GOOD</span>
                <span class="tag">DFS + HashMap</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('cloneg-time')">
                    <i class="far fa-clock"></i> O(V + E) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('cloneg-space')">
                    <i class="fas fa-server"></i> O(V) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="cloneg-time-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                We visit every Vertex once to create a copy, and we iterate over every Edge to link the neighbors.
            </div>
            <div id="cloneg-space-explainer" class="metric-explainer">
                <strong>Why O(V)?</strong> <br>
                The HashMap stores a reference for every vertex in the graph. Recursion stack takes O(H).
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Mirror Map</strong><br>We traverse the Original Graph.<br>Every time we see a Node, we check the Map: <code>{Original -> Clone}</code>.<br>If it exists in Map, link to it. If not, create New, add to Map, and recurse.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Deep Copy via Recursion:</strong>
                <br>1. <strong>Input:</strong> A node from the original graph.
                <br>2. <strong>Check Map:</strong> If `node` is already in `visited`, return `visited[node]`.
                <br>3. <strong>Create:</strong> Make `copy = Node(node.val)`.
                <br>4. <strong>Register:</strong> `visited[node] = copy` (CRITICAL: do this *before* looping neighbors to handle cycles).
                <br>5. <strong>Link:</strong> Loop through `node.neighbors`, recursively clone them, and append to `copy.neighbors`.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Infinite Cycles:</strong> 
                <br>If you try to clone neighbors *before* putting the current node in the map, you will crash with Stack Overflow on the first cycle (A -> B -> A).
                <br><strong>Rule:</strong> Create -> Map -> Recurse.
            </div>

            <details>
                <summary>Python Solution (DFS Template)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-cloneg')">Copy</button>
                    <pre id="code-cloneg">
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        if not node: return None
        
        # Map: Original_Node -> Cloned_Node
        old_to_new = {}
        
        def dfs(curr):
            # 1. Base Case: If already cloned, return the clone
            if curr in old_to_new:
                return old_to_new[curr]
            
            # 2. Create Clone
            copy = Node(curr.val)
            
            # 3. Map IT (Before recursion to prevent cycles)
            old_to_new[curr] = copy
            
            # 4. Populate Neighbors
            for neighbor in curr.neighbors:
                copy.neighbors.append(dfs(neighbor))
                
            return copy
            
        return dfs(node)</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-6">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-undo" style="color: var(--good);"></i>
                <span>Detect Cycle (Directed)</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good">GOOD</span>
                <span class="tag">DFS + Recursion Stack</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('cycled-time')">
                    <i class="far fa-clock"></i> O(V + E) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('cycled-space')">
                    <i class="fas fa-server"></i> O(V) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="cycled-time-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                Standard DFS. We visit every node and edge once.
            </div>
            <div id="cycled-space-explainer" class="metric-explainer">
                <strong>Why O(V)?</strong> <br>
                We store two boolean arrays: `visited` and `pathVisited` (recursion stack).
            </div>

            <div class="visual-area">
                [Image of directed graph cycle detection visualization with recursion stack]
                <br>
                <span><strong>Visual: The "Snake" Game</strong><br>Think of the recursion path as a Snake.<br>If the snake bites its own body (a node currently in `pathVisited`), it's a Cycle.<br>If it bites a dead snake (a node visited in the past but not active), it's safe.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>Two Arrays Strategy:</strong>
                <br>1. <strong>Visited:</strong> "I have finished processing this node forever."
                <br>2. <strong>PathVisited (Stack):</strong> "I am currently visiting this node (or its descendants)."
                <br><strong>Cycle Condition:</strong> If neighbor is `Visited` AND `PathVisited`, we found a back-edge to an ancestor. Cycle!
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Undirected Logic Fail:</strong> 
                <br>In undirected graphs, `visited` is enough (just check `neighbor != parent`). 
                <br>In directed graphs, that fails. You must backtrack: when DFS returns from a node, remove it from `pathVisited` to unmark the current path.
            </div>

            <details>
                <summary>Python Solution (DFS with Path Tracker)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-cycled')">Copy</button>
                    <pre id="code-cycled">
def canFinish(numCourses, prerequisites):
    # Note: This is functionally similar to Course Schedule
    # but strictly implementing the DFS Cycle Detection pattern.
    
    adj = [[] for _ in range(numCourses)]
    for course, pre in prerequisites:
        adj[pre].append(course)
        
    visited = [False] * numCourses
    path_visited = [False] * numCourses
    
    def dfs(node):
        visited[node] = True
        path_visited[node] = True
        
        for neighbor in adj[node]:
            if not visited[neighbor]:
                if dfs(neighbor): return True # Cycle detected deep down
            elif path_visited[neighbor]:
                return True # Cycle detected: Back edge to active path
                
        # BACKTRACK: Remove from current path before returning
        path_visited[node] = False
        return False
        
    for i in range(numCourses):
        if not visited[i]:
            if dfs(i): return False # Cycle found -> Can't finish
            
    return True</pre>
                </div>
            </details>
        </div>
    </div>

    <div class="flashcard" id="card-7">
        <div class="card-header">
            <div class="q-title">
                <i class="fas fa-palette" style="color: var(--accent);"></i>
                <span>Is Graph Bipartite?</span>
            </div>
            <div style="display:flex; gap:10px; align-items:center;">
                <span class="badge badge-good" style="background: #ecfdf5; color: #047857; border-color: #6ee7b7;">BONUS</span>
                <span class="tag">2-Coloring BFS</span>
            </div>
        </div>
        <div class="card-body">
            
            <div class="metrics">
                <div class="metric-item" onclick="toggleExplainer('bip-time')">
                    <i class="far fa-clock"></i> O(V + E) Time <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
                <div class="metric-item" onclick="toggleExplainer('bip-space')">
                    <i class="fas fa-server"></i> O(V) Space <i class="fas fa-info-circle" style="font-size:0.8em; margin-left:5px;"></i>
                </div>
            </div>

            <div id="bip-time-explainer" class="metric-explainer">
                <strong>Why O(V + E)?</strong> <br>
                Standard BFS traversal.
            </div>
            <div id="bip-space-explainer" class="metric-explainer">
                <strong>Why O(V)?</strong> <br>
                We store the `color` array of size V.
            </div>

            <div class="visual-area">
                
                <br>
                <span><strong>Visual: The Odd Cycle Check</strong><br>If a graph has a cycle of Odd Length (e.g., triangle), it cannot be Bipartite.<br>BFS naturally detects this. If an edge connects two nodes at the same Level (Color), it's a conflict.</span>
            </div>

            <div class="info-box logic-box">
                <span class="box-label" style="color: var(--primary)">üí° The Crux</span>
                <strong>The Coloring Rule:</strong>
                <br>1. Assign start node Color 0.
                <br>2. Push to Queue.
                <br>3. For every neighbor:
                <br>&nbsp;&nbsp;-> If <strong>Uncolored</strong>: Paint it `1 - current_color` (flip color) and Push.
                <br>&nbsp;&nbsp;-> If <strong>Colored</strong>: Check if `neighbor_color == current_color`. If yes, Conflict! Return False.
            </div>

            <div class="info-box trap-box">
                <span class="box-label" style="color: #991b1b">‚ö†Ô∏è The Trap</span>
                <strong>Disconnected Components:</strong> 
                <br>The graph might be split into islands. If you only run BFS from Node 0, you might miss a conflict in Node 50.
                <br><strong>Fix:</strong> Loop through `range(n)` and start a BFS for every uncolored node found.
            </div>

            <details>
                <summary>Python Solution (BFS Coloring)</summary>
                <div style="position: relative;">
                    <button class="copy-btn" onclick="copyCode('code-bip')">Copy</button>
                    <pre id="code-bip">
from collections import deque

def isBipartite(graph):
    n = len(graph)
    # 0: Uncolored, 1: Red, -1: Blue
    colors = [0] * n 
    
    for i in range(n):
        # Handle disconnected components
        if colors[i] != 0: continue
            
        queue = deque([i])
        colors[i] = 1 # Start with Red
        
        while queue:
            curr = queue.popleft()
            
            for neighbor in graph[curr]:
                if colors[neighbor] == 0:
                    # Paint opposite color
                    colors[neighbor] = -colors[curr]
                    queue.append(neighbor)
                elif colors[neighbor] == colors[curr]:
                    # Conflict found! Same color neighbors.
                    return False
                    
    return True</pre>
                </div>
            </details>
        </div>
    </div>


</div>

<script>
    function toggleExplainer(type) {
        document.querySelectorAll('.metric-explainer').forEach(el => el.style.display = 'none');
        const target = document.getElementById(`${type}-explainer`);
        if (target) target.style.display = 'block';
    }

    function copyCode(id) {
        const code = document.getElementById(id).innerText;
        navigator.clipboard.writeText(code).then(() => {
            alert('Code copied to clipboard!');
        });
    }
</script>

</body>
</html>