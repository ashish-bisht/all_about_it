// Auto-generated from data/ folder
// Run `python3 build_data.py` to regenerate
// DO NOT EDIT THIS FILE DIRECTLY - Edit files in data/ folder instead!


// ========== data/dsa/arrays.js ==========
// Arrays data
// Extracted from data.js

const topic_arrays = {
    id: "arrays",
    title: "Arrays & Sliding Window",
    description: "Principal Engineer DSA â€¢ Day 1",
    color: "var(--primary)", // #6366f1
    icon: "fas fa-layer-group",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ” Fast Lookup", desc: "Need O(1) lookup? â†’ HashMap (Two Sum, Subarray Sum K)" },
            { label: "ğŸ“Š Sorted Data", desc: "Array sorted? â†’ Two Pointers from ends (3Sum, Container Water)" },
            { label: "ğŸ“ Contiguous Subarray", desc: "Max/Min subarray? â†’ Kadane's or Sliding Window" },
            { label: "ğŸªŸ K Window", desc: "Fixed/variable window? â†’ Sliding Window technique" },
            { label: "â†”ï¸ Prefix/Suffix", desc: "Need left+right info? â†’ Prefix/Suffix arrays (Product Except Self)" },
            { label: "ğŸ“… Intervals", desc: "Overlapping ranges? â†’ Sort by start, track end (Merge Intervals)" }
        ],
        patterns: [
            { algo: "HashMap Lookup", use: "Find pair/triplet with sum", time: "O(N)", space: "O(N)", template: "if target-num in map: found!" },
            { algo: "Two Pointers", use: "Sorted array pair finding", time: "O(N)", space: "O(1)", template: "left=0, right=n-1, move based on sum" },
            { algo: "Sliding Window (Fixed)", use: "Max sum of k elements", time: "O(N)", space: "O(1)", template: "add right, remove left when size>k" },
            { algo: "Sliding Window (Variable)", use: "Longest/shortest with condition", time: "O(N)", space: "O(K)", template: "expand right, shrink left while invalid" },
            { algo: "Kadane's Algorithm", use: "Max subarray sum", time: "O(N)", space: "O(1)", template: "curr = max(num, curr+num)" },
            { algo: "Prefix Sum", use: "Subarray sum queries", time: "O(N)", space: "O(N)", template: "prefix[i] = prefix[i-1] + arr[i]" },
            { algo: "Dutch National Flag", use: "3-way partition (0,1,2)", time: "O(N)", space: "O(1)", template: "low, mid, high pointers" },
            { algo: "Interval Merge", use: "Overlapping intervals", time: "O(N log N)", space: "O(N)", template: "sort by start, merge if overlap" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Arrays Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ "Array problem type?"   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                           â–¼                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FIND PAIR  â”‚          â”‚  SUBARRAY   â”‚          â”‚  INTERVALS   â”‚
â”‚ with sum   â”‚          â”‚  max/min    â”‚          â”‚  overlapping â”‚
â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                        â”‚                        â”‚
      â–¼                        â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Sorted?       â”‚      â”‚ Contiguous?     â”‚      â”‚ Sort by startâ”‚
â”‚ â†’ Two Pointer â”‚      â”‚ â†’ Kadane's      â”‚      â”‚ Track max endâ”‚
â”‚ Unsorted?     â”‚      â”‚ Fixed window?   â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â†’ HashMap     â”‚      â”‚ â†’ Sliding Windowâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         "Need left AND right info?"        "3-way partition?"
              â”‚                                   â”‚
              â–¼                                   â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Prefix/Suffix â”‚                   â”‚ Dutch National â”‚
      â”‚ Two passes    â”‚                   â”‚ Flag Algorithm â”‚
      â”‚ leftâ†’ then â†  â”‚                   â”‚ 0,1,2 sorting  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Arrays Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ Two Sum (HashMap)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def twoSum(nums, target):
    seen = {}
    for index, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], index]
        seen[num] = index
    return []
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Sliding Window (Variable)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def lengthOfLongestSubstring(s):
    char_set = set()
    left = max_len = 0
    for right in range(len(s)):
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(s[right])
        max_len = max(max_len, right - left + 1)
    return max_len
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Kadane's Algorithm
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def maxSubArray(nums):
    max_sum = current_sum = nums[0]
    for num in nums[1:]:
        current_sum = max(num, current_sum + num)
        max_sum = max(max_sum, current_sum)
    return max_sum
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Merge Intervals
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def merge(intervals):
    intervals.sort(key=lambda x: x[0])
    merged = [intervals[0]]
    for start, end in intervals[1:]:
        if start <= merged[-1][1]:
            merged[-1][1] = max(merged[-1][1], end)
        else:
            merged.append([start, end])
    return merged
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ” Empty array!", desc: "<code>if not nums: return</code> â€” Always check first!" },
            { label: "ğŸ“ Index bounds!", desc: "Two pointers: <code>while left < right</code> not <code><=</code>" },
            { label: "ğŸ”„ Duplicate skip!", desc: "3Sum: <code>while left < right and nums[left] == nums[left-1]: left += 1</code>" },
            { label: "ğŸ“‹ Copy issue!", desc: "When storing result, use <code>result.append(nums[:])</code>" },
            { label: "âš¡ Shrink window!", desc: "Sliding window: shrink with <code>while</code> not <code>if</code>" },
            { label: "ğŸ”¢ Overflow!", desc: "Product problems: track both max and min (negatives flip sign)" }
        ]
    },
    questions: [
        {
            id: "two-sum",
            title: "Two Sum",
            leetcodeUrl: "https://leetcode.com/problems/two-sum/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["HashMap"],
            quiz: {
                description: "Given an array and target, find two numbers that add up to target. What's the optimal approach?",
                options: [
                    "Brute Force O(nÂ²) - Check all pairs",
                    "HashMap O(n) - Store complements as you iterate",
                    "Two Pointers O(n log n) - Sort then scan",
                    "Binary Search O(n log n) - Sort and search for each element"
                ],
                correct: 1,
                explanation: "HashMap is KING! As you iterate, check if (target - current) exists in map. If yes, found! If no, store current. One pass: O(n) time, O(n) space. Warm-up in 20% of interviews!"
            },
            learn: null // Not present in arrays.html, only game
        },
        {
            id: "3sum",
            title: "3Sum",
            leetcodeUrl: "https://leetcode.com/problems/3sum/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Two Pointers"],
            quiz: {
                description: "Find all triplets that sum to zero. Best approach to avoid duplicates?",
                options: [
                    "Three nested loops O(nÂ³)",
                    "HashMap with pair sums O(nÂ²) space",
                    "Sort + Two Pointers O(nÂ²) time, O(1) space",
                    "Backtracking O(2â¿)"
                ],
                correct: 2,
                explanation: "Sort first! Fix one element, use two pointers on rest. Skip duplicates by checking if current == previous. This is THE standard pattern for multi-pointer problems. O(nÂ²) time!"
            },
            learn: {
                quickAlgo: [
                    "nums.sort()                                  # ğŸ¯ MUST sort first!",
                    "ans = []",
                    "for index in range(len(nums) - 2):           # âš¡ Fix first num (Anchor)",
                    "    if index > 0 and nums[index] == nums[index-1]: continue  # Skip dup anchor",
                    "    left, right = index + 1, len(nums) - 1   # ğŸ”„ Two Pointers on rest",
                    "    while left < right:",
                    "        total = nums[index] + nums[left] + nums[right]",
                    "        if total < 0: left += 1              # Need bigger sum",
                    "        elif total > 0: right -= 1           # Need smaller sum",
                    "        else:                                 # âœ… Found triplet!",
                    "            ans.append([nums[index], nums[left], nums[right]])",
                    "            left += 1; right -= 1",
                    "            while left < right and nums[left] == nums[left-1]: left += 1",
                    "            while left < right and nums[right] == nums[right+1]: right -= 1",
                    "return ans"
                ],
                metrics: { time: "O(NÂ²)", space: "O(1)" },
                timeExplainer: "<strong>Time: O(NÂ²)</strong><br>â€¢ Sorting takes O(N log N).<br>â€¢ We iterate N times (Anchor).<br>â€¢ Inside loop, max O(N) work (Two Pointers).<br>Total = N * N = O(NÂ²).",
                spaceExplainer: "<strong>Space: O(1)</strong><br>We only use pointers (left, right, index). Ignoring output array space.",
                visual: `<span><strong>Visual: Anchor & Squeeze</strong><br>Array ko sort karo. First element <code>anchor</code> fix karo. Remaining array mein do pointers se target dhundo.<br>
<pre style="background:none; border:none; padding:10px; font-size:0.8rem; line-height:1.2;">
 Sorted: [-4, -1, -1, 0, 1, 2]
          ^   ^             ^
      Anchor  L             R
 Target for (L, R) = -Anchor
</pre>
</span>`,
                crux: "3Sum = 1 Fixed Number + 2Sum (Sorted).<br><strong>Formula:</strong> <code>nums[L] + nums[R] + Anchor = 0</code>",
                strategy: "Sort First. Fix <code>i</code>, then solve 2Sum on <code>nums[i+1:]</code>.",
                trap: "<strong>Duplicates:</strong><br>1. Anchor duplicates: <code>if i > 0 and nums[i] == nums[i-1]: continue</code><br>2. Pointer duplicates: <code>while nums[L] == nums[L-1]: L++</code>",
                dryRun: [
                    "<strong>Input:</strong> nums = [-1, 0, 1, 2, -1, -4]",
                    "1. Sort: [-4, -1, -1, 0, 1, 2]",
                    "2. Anchor=-4. Target=4. (L=-1, R=2) -> Sum=1 (Small). L++",
                    "3. Anchor=-1. Target=1. (L=-1, R=2) -> Sum=1. FOUND! [-1, -1, 2].",
                    "4. Skip duplicates for L. Move L to 0."
                ],
                codeTitle: "Python Solution (Clean)",
                code: `def three_sum(nums):
    nums.sort()
    ans = []

    for index in range(len(nums) - 2):
        # Skip duplicate anchors
        if index > 0 and nums[index] == nums[index - 1]:
            continue

        left = index + 1
        right = len(nums) - 1

        while left < right:
            total = nums[index] + nums[left] + nums[right]

            if total == 0:
                ans.append([nums[index], nums[left], nums[right]])
                left += 1
                right -= 1
                
                # Skip duplicate left
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                # Skip duplicate right
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1
                    
            elif total < 0:
                left += 1
            else:
                right -= 1

    return ans`,
                codeDetailed: `def three_sum(nums):
    """
    3Sum - Finding triplets that sum to zero
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CRUX: Sort + Fix Anchor + Two Pointers
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    STRATEGY: Reduce 3Sum to 2Sum
    1. SORT the array (Essential for Two Pointers)
    2. Loop 'i' as the ANCHOR (the first element)
    3. Treat the rest (i+1 to end) as a 2Sum Sorted problem
       Goal: Find (Left + Right) = -Anchor
    
    Time: O(NÂ²), Space: O(1)
    """
    nums.sort()  # Step 1: Sort is mandatory
    ans = []

    # Iterate with Anchor
    # stop at len-2 because we need at least 2 more elements (Left, Right)
    for index in range(len(nums) - 2):
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # STEP 1: Handle Anchor Duplicates
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # If current number is same as previous, we've already done 
        # the work for this value. Skip to avoid duplicate triplets.
        if index > 0 and nums[index] == nums[index - 1]:
            continue

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # STEP 2: Set Two Pointers
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        left = index + 1
        right = len(nums) - 1

        # Visual:
        # [-4, -1, -1, 0, 1, 2]
        #   ^   ^            ^
        #  Anc  L            R
        
        while left < right:
            total = nums[index] + nums[left] + nums[right]

            if total == 0:
                # Found a Triplet!
                ans.append([nums[index], nums[left], nums[right]])

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # STEP 3: Handle Pointer Duplicates (Internal)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # We need to move BOTH pointers inward after finding a match
                left += 1
                right -= 1

                # SKIP same values to avoid duplicate triplets like [-1, -1, 2] again
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1

            elif total < 0:
                # Sum is too small -> Need bigger number -> Move Left forward
                left += 1
            else:
                # Sum is too big -> Need smaller number -> Move Right backward
                right -= 1

    return ans`
            }
        },
        {
            id: "max-subarray",
            title: "Kadane's Algorithm",
            leetcodeUrl: "https://leetcode.com/problems/maximum-subarray/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["DP"],
            quiz: {
                description: "Find maximum sum of contiguous subarray. What's the DP optimization?",
                options: [
                    "Check all subarrays O(nÂ³)",
                    "Prefix sums O(nÂ²)",
                    "Kadane's: currSum = max(arr[i], currSum + arr[i])",
                    "Divide and Conquer O(n log n)"
                ],
                correct: 2,
                explanation: "Kadane's is GENIUS! Keep running sum. If it goes negative, reset to 0 (or current element). Track global max. O(n) time, O(1) space. Foundation for many DP problems!"
            },
            learn: {
                quickAlgo: [
                    "curr = max_sum = nums[0]         # ğŸ¯ Init with first element (handle all negs)",
                    "for n in nums[1:]:               # âš¡ Iterate rest",
                    "    if curr < 0: curr = 0        # ğŸ”„ Reset: Negative sum is a burden",
                    "    curr += n                    # ğŸ’¡ Add current element",
                    "    max_sum = max(max_sum, curr) # âœ… Track global maximum",
                    "return max_sum"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Time Complexity: O(N)</strong><br>We iterate through the array exactly once (Single Pass). Each element is visited and processed in constant time.",
                spaceExplainer: "<strong>Space Complexity: O(1)</strong><br>We only use two variables (`current_sum` and `global_max`) to track the state, regardless of the input array size.",
                visual: "<span><strong>Visual: The Reset Button</strong><br>Jab tak <code>current_sum</code> positive hai, wo aage kaam aayega. Jaise hi wo negative hua, wo 'bojh' ban gaya. Use turant 0 karke naya safar shuru karo.</span>",
                crux: "Contiguous subarray dhoondna hai. Agar pichla sum negative hai, toh wo current number ki value ko kam à¨¹à©€ karega.<br><strong>Strategy:</strong><br>1. <code>current_sum</code> ko track karo.<br>2. DECISION: Kya <code>current + nums[i]</code> better hai ya fresh start <code>nums[i]</code> better hai?<br>3. Har step pe <code>global_max</code> update karo.",
                trap: "<strong>All Negatives:</strong> Agar array <code>[-5, -2, -3]</code> hai aur tumne <code>max_sum = 0</code> se start kiya, toh answer 0 aayega jo galat hai.<br><strong>Fix:</strong> <code>global_max</code> ko hamesha pehle element (<code>nums[0]</code>) se initialize karo.",
                dryRun: [
                    "<strong>Input:</strong> nums = [-2, 1, -3, 4]",
                    "1. n=-2: current_sum=-2. global_max=-2. <br><span class='var-highlight'>current_sum < 0</span> -> Reset logic triggers implicitly next step.",
                    "2. n=1: max(1, -2+1) = 1. current_sum=1. global_max=max(-2, 1) = <span class='var-highlight'>1</span>.",
                    "3. n=-3: max(-3, 1-3) = -2. current_sum=-2. global_max=1.",
                    "4. n=4: max(4, -2+4) = 4. current_sum=4. global_max=4."
                ],
                codeTitle: "Python Solution (Clean)",
                code: `def max_sub_array(nums):
    # Initialize with first element
    max_sum = nums[0]
    current_sum = nums[0]
    
    # Iterate starting from the second element
    for current_num in nums[1:]:
        # If current_sum is negative, reset it (start fresh)
        # Because adding a negative sum to current_num will only make it smaller
        if current_sum < 0:
            current_sum = 0
            
        current_sum += current_num
        
        if current_sum > max_sum:
            max_sum = current_sum
            
    return max_sum`,
                codeDetailed: `def max_sub_array(nums):
    """
    Kadane's Algorithm - Maximum Subarray Sum
    
    CRUX: Track TWO things separately:
    1. current_sum: Current subarray sum (can go negative!)
    2. global_max: Overall best answer found so far (peak value)
    """
    
    # Initialize with first element
    global_max = nums[0]      # Best answer found so far
    current_sum = nums[0]     # Current subarray sum
    
    # Iterate from second element
    for current_num in nums[1:]:
        # DECISION POINT: Fresh start ya continue?
        # If adding current element makes sum worse, start fresh
        current_sum = max(current_num, current_sum + current_num)
        #                 \\_________/  \\_______________________/
        #                Fresh          Continue previous
        #                start          subarray
        
        # Track the peak! (CRUX of Kadane's)
        # This ensures we don't lose the best answer
        # even if current_sum becomes negative later
        global_max = max(global_max, current_sum)
    
    return global_max  # Return peak, not current!`
            }
        },
        {
            id: "product-except-self",
            title: "Product Except Self",
            leetcodeUrl: "https://leetcode.com/problems/product-of-array-except-self/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Prefix & Suffix"],
            quiz: {
                description: "Return array where output[i] = product of all except nums[i], WITHOUT division. How?",
                options: [
                    "Divide total product by nums[i]",
                    "Prefix product from left Ã— Suffix product from right",
                    "Nested loops O(nÂ²)",
                    "Use logarithms to convert to addition"
                ],
                correct: 1,
                explanation: "Prefix Ã— Suffix magic! First pass: prefix[i] = product of all left elements. Second pass: suffix from right. Result[i] = prefix[i] Ã— suffix[i]. O(n) time! Microsoft/Amazon favorite."
            },
            learn: {
                quickAlgo: [
                    "n = len(nums); res = [1] * n",
                    "prefix = 1                         # ğŸ¯ Running product from LEFT",
                    "for i in range(n):",
                    "    res[i] = prefix               # âš¡ Store product of all LEFT elements",
                    "    prefix *= nums[i]",
                    "suffix = 1                         # ğŸ”„ Running product from RIGHT",
                    "for i in range(n-1, -1, -1):",
                    "    res[i] *= suffix              # âœ… Multiply with RIGHT product",
                    "    suffix *= nums[i]             # ğŸ’¡ Update suffix",
                    "return res"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Time: O(N)</strong><br>â€¢ <code>2 passes</code> through the array<br>â€¢ First pass: Build prefix products<br>â€¢ Second pass: Multiply with suffix products<br><br><strong>Total:</strong> <code>O(2N)</code> = <code>O(N)</code>",
                spaceExplainer: "<strong>Space: O(1)</strong><br>â€¢ Output array not counted as extra space<br>â€¢ Only one variable <code>suffix_product</code> used<br><br><strong>Result:</strong> <code>O(1)</code> auxiliary space",
                visual: "<span><strong>Visual: The Sandwich Logic</strong><br>Index <code>i</code> ke liye: (Left se sabka product) Ã— (Right se sabka product). Hum result array mein pehle left side ka maal bharte hain, phir right side se aate waqt subtract kar dete hain.</span>",
                crux: "Division operator banned hai.<br><strong>Strategy:</strong><br>1. <strong>Left Pass:</strong> <code>result[i]</code> mein 0 se <code>i-1</code> tak ka product store karo.<br>2. <strong>Right Pass:</strong> Ek variable <code>suffix_product</code> maintain karo aur piche se aate waqt <code>result[i]</code> ko usse multiply karo.",
                trap: "<strong>Zero Handling:</strong> Agar array mein ek <code>0</code> hai, toh baaki sab index zero ho jayenge except the zero's index. Fix: Prefix/Suffix logic handles this naturally.",
                dryRun: [
                    "<strong>Input:</strong> nums = [1, 2, 3, 4]",
                    "1. <strong>Prefix Pass:</strong> result = [1, 1, 2, 6] <br>(e.g., index 3 stores 1*2*3)",
                    "2. <strong>Suffix Pass:</strong> suffix_product start = 1 <br>- i=3: res[3]*1=6. suffix=4. <br>- i=2: res[2]*4=8. suffix=12. <br>- i=1: res[1]*12=12. suffix=24. <br>- i=0: res[0]*24=24",
                    "<strong>Final:</strong> [24, 12, 8, 6]"
                ],
                codeTitle: "Python Solution (Clean)",
                code: `def product_except_self(nums):
    n = len(nums)
    result = [1] * n
    
    # Pass 1: Left to Right
    left_product = 1
    for index, num in enumerate(nums):
        result[index] = left_product
        left_product *= num
        
    # Pass 2: Right to Left
    right_product = 1
    for index in range(n - 1, -1, -1):
        result[index] *= right_product
        right_product *= nums[index]
        
    return result`,
                codeDetailed: `def product_except_self(nums):
    """
    Product of Array Except Self (Without Division)
    
    CRUX: Break the problem into LEFT and RIGHT products
    - result[index] = (product of all left elements) * (product of all right elements)
    """
    
    n = len(nums)
    result = [1] * n
    
    # PASS 1: Left to Right (Store Left Products)
    left_product = 1
    for index, num in enumerate(nums):
        result[index] = left_product      # Direct assignment (clearer!)
        left_product *= num               # Update for next iteration
    
    # PASS 2: Right to Left (Multiply with Right Products)
    right_product = 1
    for index in range(n - 1, -1, -1):
        result[index] *= right_product    # Multiply karna padega (combining left * right)
        right_product *= nums[index]
    
    return result`
            }
        },
        {
            id: "trapping-rain-water",
            title: "Trapping Rain Water",
            leetcodeUrl: "https://leetcode.com/problems/trapping-rain-water/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Two Pointers"],
            quiz: {
                description: "Calculate water trapped between bars. What's the optimal pattern?",
                options: [
                    "For each bar, find max left & right O(nÂ²)",
                    "Pre-compute max arrays O(n) space",
                    "Two pointers from both ends O(1) space",
                    "Stack-based approach O(n)"
                ],
                correct: 2,
                explanation: "Two pointers is ELITE! Start from both ends with left_max, right_max. Water at position = min(left_max, right_max) - height. Move smaller pointer inward. O(n) time, O(1) space!"
            },
            learn: {
                quickAlgo: [
                    "L, R = 0, len(height) - 1          # ğŸ¯ Two Pointers from ends",
                    "L_max, R_max = 0, 0                # âš¡ Track max heights seen",
                    "water = 0",
                    "while L < R:",
                    "    if height[L] < height[R]:      # ğŸ”„ Process SMALLER side",
                    "        if height[L] >= L_max:",
                    "            L_max = height[L]      # New wall, no water",
                    "        else:",
                    "            water += L_max - height[L] # âœ… Valley! Add water",
                    "        L += 1",
                    "    else:",
                    "        if height[R] >= R_max:",
                    "            R_max = height[R]      # New wall",
                    "        else:",
                    "            water += R_max - height[R] # ğŸ’¡ Water trapped",
                    "        R -= 1",
                    "return water"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Time: O(N)</strong><br>We process each element exactly once using two pointers meeting in the middle.",
                spaceExplainer: "<strong>Space: O(1)</strong><br>Only constant extra space used for pointers and max height variables.",
                visual: `<span><strong>Visual: The Water Level</strong><br>Water at position <code>i</code> = <code>min(left_max, right_max) - height[i]</code>.<br>
<pre style="background:none; border:none; padding:10px; font-size:0.8rem; line-height:1.2;">
   LEFT_MAX        RIGHT_MAX
      |               |
      â–ˆ               â–ˆ
      â–ˆ       ?       â–ˆ
      â–ˆ   â–ˆ   i   â–ˆ   â–ˆ
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
</pre>
Smaller wall decides the water level! Kyunki pani MIN height tak hi bharega.</span>`,
                crux: "Water level choti height se decide hota hai.<br><strong>Strategy:</strong><br>Process the <strong>SMALLER</strong> side (water is guaranteed there!).<br>1. Agar <code>height[left] < height[right]</code>, toh left side ka water confirm hai (kyunki right mein badi wall hai).<br>2. Same logic for right side.",
                trap: "<strong>Wall vs Valley:</strong><br>Agar current height <code>> max_height</code>, toh wo <strong>Wall</strong> hai (pani nahi rukega, max update karo).<br>Agar choti hai, toh wo <strong>Valley</strong> hai (pani calculate karo).",
                dryRun: [
                    "<strong>Input:</strong> height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]",
                    "1. L=0, R=11. 0 < 1. Process Left. L_max=0. New Wall. Move L.",
                    "2. L=1. 1 < 1. Process Left. L_max=1. New Wall. Move L.",
                    "3. L=2. 0 < 1. Process Left. L_max=1. Valley! Water += 1-0 = 1. Move L.",
                    "4. ... (Continuing logic where smaller side moves) ...",
                    "<strong>Final Water:</strong> 6 units"
                ],
                codeTitle: "Python Solution (Clean)",
                code: `def trapping_rain_water(height):
    if not height: return 0
    
    left_pointer = 0
    right_pointer = len(height) - 1

    left_max_height = height[left_pointer]
    right_max_height = height[right_pointer]

    trapped_water = 0

    while left_pointer < right_pointer:
        # Process the SMALLER side
        if height[left_pointer] < height[right_pointer]:
            if height[left_pointer] > left_max_height:
                left_max_height = height[left_pointer]
            else:
                trapped_water += min(left_max_height, right_max_height) - height[left_pointer]
            left_pointer += 1
        else:
            if height[right_pointer] > right_max_height:
                right_max_height = height[right_pointer]
            else:
                trapped_water += min(left_max_height, right_max_height) - height[right_pointer]
            right_pointer -= 1

    return trapped_water`,
                codeDetailed: `def trapping_rain_water(height):
    """
    Trapping Rain Water - Two Pointers Approach
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CRUX: Water at position i = min(left_max, right_max) - height[i]
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    STRATEGY: Process the SMALLER side (water is guaranteed there!)
    
    Why? Kyunki pani MIN height tak hi bharega:
         LEFT_MAX        RIGHT_MAX
            |               |
            â–ˆ               â–ˆ
            â–ˆ       ?       â–ˆ
            â–ˆ   â–ˆ   i   â–ˆ   â–ˆ
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        Water level = min(LEFT_MAX, RIGHT_MAX)
        Smaller wall decides the water level!
    
    Time: O(n), Space: O(1)
    """
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 1: Initialize Two Pointers
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    left_pointer = 0                    # Start from left end
    right_pointer = len(height) - 1    # Start from right end
    
    # Visual:
    # height = [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]
    #           â†‘                                â†‘
    #      left_pointer                   right_pointer
    
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 2: Track Maximum Heights from Both Sides
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    left_max_height = height[left_pointer]    # Tallest wall on left so far
    right_max_height = height[right_pointer]  # Tallest wall on right so far
    
    # Initially:
    # left_max_height = 0 (height at index 0)
    # right_max_height = 1 (height at index 11)
    
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 3: Initialize Water Counter
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    trapped_water = 0
    
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 4: Process Elements Until Pointers Meet
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    while left_pointer < right_pointer:
        
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # DECISION: Which side to process?
        # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Rule: Process the SMALLER side
        # Why? Because water level is decided by smaller wall
        
        if height[left_pointer] < height[right_pointer]:
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ LEFT SIDE IS SMALLER - Process Left!          â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            # Visual:
            #     â–ˆ                   â–ˆ
            #     â–ˆ       ?           â–ˆ
            #     â–ˆ   â–ˆ   L   â–ˆ       â–ˆ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            #         â†‘               â†‘
            #    left (small)    right (big)
            #
            # LEFT chhota hai, so RIGHT side pe definitely
            # koi bada wall hai. LEFT ka water CONFIRM hai!
            
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ Check: Is current bar a NEW WALL or VALLEY?   â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            if height[left_pointer] > left_max_height:
                # Current bar is TALLER - it's a NEW WALL!
                # Update the left boundary
                left_max_height = height[left_pointer]
                
                # Visual:
                # Old max:  â–ˆ
                # New max:  â–ˆ â–ˆ  â† Update!
                
                # No water trapped here (it's a wall, not valley)
            
            else:
                # Current bar is SHORTER - it's a VALLEY!
                # Water will be trapped here
                
                # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                # â”‚ WATER FORMULA:                             â”‚
                # â”‚ water = min(left_max, right_max) - height  â”‚
                # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                
                # Visual:
                #     LEFT_MAX                RIGHT_MAX
                #        |                       |
                #        â–ˆ                       â–ˆ
                #        â–ˆ â–‘â–‘â–‘                   â–ˆ
                #        â–ˆ â–‘iâ–‘   â†â”€â”€ water!      â–ˆ
                #        â–ˆ_â–ˆ_____________________â–ˆ
                #
                # Water level = min(left_max, right_max)
                # Water at i = water_level - current_height
                
                trapped_water += min(left_max_height, right_max_height) - height[left_pointer]
                
                # Example:
                # left_max = 2, right_max = 3, height[i] = 0
                # water = min(2,3) - 0 = 2 - 0 = 2 units âœ…
            
            # Move left pointer forward
            left_pointer += 1
            
        else:
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ RIGHT SIDE IS SMALLER/EQUAL - Process Right!  â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            
            # Visual:
            #         â–ˆ                   â–ˆ
            #         â–ˆ       ?           â–ˆ
            #         â–ˆ   â–ˆ       â–ˆ   R   â–ˆ
            # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            #         â†‘                   â†‘
            #    left (big)          right (small)
            #
            # RIGHT chhota hai, so LEFT side pe definitely
            # koi bada wall hai. RIGHT ka water CONFIRM hai!
            
            # â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            # â”‚ Check: Is current bar a NEW WALL or VALLEY?   â”‚
            # â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            if height[right_pointer] > right_max_height:
                # Current bar is TALLER - it's a NEW WALL!
                right_max_height = height[right_pointer]
                
                # No water trapped (it's a wall)
            
            else:
                # Current bar is SHORTER - it's a VALLEY!
                # Water will be trapped here
                
                # Visual:
                #  LEFT_MAX                RIGHT_MAX
                #     |                       |
                #     â–ˆ                       â–ˆ
                #     â–ˆ                   â–‘â–‘â–‘ â–ˆ
                #     â–ˆ       â†â”€â”€ water! â–‘iâ–‘ â–ˆ
                #     â–ˆ_______________________â–ˆ
                
                trapped_water += min(left_max_height, right_max_height) - height[right_pointer]
            
            # Move right pointer backward
            right_pointer -= 1
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 5: Return Total Trapped Water
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    return trapped_water

print(trapping_rain_water([0,1,0,2,1,0,1,3,2,1,2,1]))`
            }
        },
        {
            id: "merge-intervals",
            title: "Merge Intervals",
            leetcodeUrl: "https://leetcode.com/problems/merge-intervals/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Sorting", "Greedy"],
            quiz: {
                description: "Merge all overlapping intervals. What's the first critical step?",
                options: [
                    "Use Union-Find",
                    "Sort by start time, then merge linearly",
                    "Build interval tree",
                    "Check every pair O(nÂ²)"
                ],
                correct: 1,
                explanation: "SORT FIRST by start time! Then iterate: if current.start <= last.end, they overlap - merge. Else, add current to result. O(n log n) for sort, O(n) for merge. Standard interval pattern!"
            },
            learn: {
                quickAlgo: [
                    "intervals.sort(key=lambda x: x[0]) # ğŸ¯ Sort by Start Time",
                    "merged = [intervals[0]]",
                    "for curr in intervals[1:]:         # âš¡ Iterate sorted intervals",
                    "    last = merged[-1]",
                    "    if curr[0] <= last[1]:         # ğŸ”„ Overlap detected! (curr.start <= last.end)",
                    "        last[1] = max(last[1], curr[1]) # âœ… Merge: Extend end time",
                    "    else:",
                    "        merged.append(curr)        # ğŸ’¡ No overlap: Add new interval",
                    "return merged"
                ],
                metrics: { time: "O(N log N)", space: "O(N)" },
                timeExplainer: "<strong>Time Breakdown:</strong><br>â€¢ Sorting: <code>O(N log N)</code><br>â€¢ Single pass to merge: <code>O(N)</code><br><br><strong>Total:</strong> <code>O(N log N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Result array to store merged intervals<br>â€¢ Worst case: no merges = <code>O(N)</code>",
                visual: "<span><strong>Visual: The Number Line</strong><br>Intervals ko unke start_time se sort karo. Check overlap with previous.</span>",
                crux: "Bina sorting ke overlap check karna impossible hai.<br><strong>Strategy:</strong><br>1. Sort by start.<br>2. Check if <code>current_start <= last_end</code>.<br>3. Merge by taking <code>max(last_end, current_end)</code>.",
                trap: "<strong>The Subset Interval:</strong> [1, 10] and [2, 5]. End should stay 10. Always use max().",
                dryRun: [
                    "<strong>Input:</strong> [[1, 3], [2, 6], [8, 10]]",
                    "1. Merged = [[1, 3]]",
                    "2. [2, 6]: 2 <= 3. Overlap! End = max(3, 6) = 6. Merged=[[1, 6]]",
                    "3. [8, 10]: 8 > 6. No overlap. Append."
                ],
                codeTitle: "Python Solution",
                code: `def merge_intervals(intervals):
if not intervals: return []
intervals.sort(key=lambda x: x[0])
merged = [intervals[0]]

for i in range(1, len(intervals)):
    start, end = intervals[i]
    last_end = merged[-1][1]
    
    if start <= last_end:
        merged[-1][1] = max(last_end, end)
    else:
        merged.append([start, end])
return merged`
            }
        },
        {
            id: "meeting-rooms-ii",
            title: "Meeting Rooms II",
            leetcodeUrl: "https://leetcode.com/problems/meeting-rooms-ii/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Min-Heap"],
            quiz: {
                description: "Find minimum meeting rooms needed. Best data structure?",
                options: [
                    "Sort by start time, count overlaps",
                    "Min Heap of end times",
                    "Interval tree",
                    "Greedy with sorting both start and end arrays"
                ],
                correct: 1,
                explanation: "Min Heap FTW! Sort by start time. For each meeting, if heap top (earliest end) < current start, reuse room (pop heap). Always push current end time. Heap size = rooms needed. O(n log n)!"
            },
            learn: {
                quickAlgo: [
                    "intervals.sort(key=lambda x: x[0]) # ğŸ¯ Sort by START time",
                    "heap = []                          # âš¡ Min-Heap of END times",
                    "for start, end in intervals:",
                    "    if heap and heap[0] <= start:  # ğŸ”„ Room available! (meeting ended)",
                    "        heappop(heap)              # âœ… Reuse room",
                    "    heappush(heap, end)            # ğŸ’¡ Always push current end time",
                    "return len(heap)                   # Heap size = rooms needed"
                ],
                metrics: { time: "O(N log N)", space: "O(N)" },
                timeExplainer: "<strong>Time Breakdown:</strong><br>â€¢ Sorting: <code>O(N log N)</code><br>â€¢ Heap operations: <code>O(N log N)</code><br><br><strong>Total:</strong> <code>O(N log N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Min-Heap stores end times<br>â€¢ Worst case: all meetings overlap = <code>O(N)</code>",
                visual: "<span><strong>Visual: Room Re-use</strong><br>Heap batata hai kaunsi meeting sabse pehle khatam hogi. Agar nayi meeting uske baad shuru ho rahi hai, toh room reuse karo.</span>",
                crux: "Track occupied rooms.<br><strong>Strategy:</strong><br>1. Sort by Start Time.<br>2. Min-Heap stores End Times.<br>3. If <code>start >= heap[0]</code>, pop (room freed).<br>4. Push new end time.",
                trap: "<strong>Just Finished:</strong> [1, 5] and [5, 10]. Reuse is allowed.",
                dryRun: [
                    "<strong>Input:</strong> [[0, 30], [5, 10], [15, 20]]",
                    "1. [0, 30]: Heap=[30]",
                    "2. [5, 10]: 5 < 30. New room. Heap=[10, 30]",
                    "3. [15, 20]: 15 >= 10. Reuse. Pop 10, Push 20. Heap=[20, 30]",
                    "Size=2"
                ],
                codeTitle: "Python Solution",
                code: `import heapq
def min_meeting_rooms(intervals):
if not intervals: return 0
intervals.sort(key=lambda x: x[0])
heap = [] # Stores end times
heapq.heappush(heap, intervals[0][1])

for i in range(1, len(intervals)):
    if intervals[i][0] >= heap[0]:
        heapq.heappop(heap)
    heapq.heappush(heap, intervals[i][1])
    
return len(heap)`
            }
        },
        {
            id: "longest-substring",
            title: "Longest Substring Without Repeating",
            leetcodeUrl: "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Sliding Window"],
            quiz: {
                description: "Find longest substring with all unique characters. What's the sliding window logic?",
                options: [
                    "Try all substrings O(nÂ³)",
                    "HashMap + Sliding window with left pointer jump",
                    "Set + Two pointers expanding right",
                    "Binary search on length"
                ],
                correct: 1,
                explanation: "HashMap + Sliding Window! Store char â†’ index. When duplicate found, jump LEFT pointer to max(left, map[char] + 1). Track max length. This is THE 'Hello World' of sliding window! O(n)."
            },
            learn: {
                quickAlgo: [
                    "char_set = set(); L = 0            # ğŸ¯ Set for O(1) duplicate check",
                    "for R in range(len(s)):",
                    "    while s[R] in char_set:        # âš¡ Duplicate found!",
                    "        char_set.remove(s[L])      # ğŸ”„ Shrink window from Left",
                    "        L += 1",
                    "    char_set.add(s[R])             # âœ… Add new char",
                    "    max_len = max(max_len, R-L+1)  # ğŸ’¡ R-L+1 is current window size",
                    "return max_len"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Time: O(N)</strong><br>We traverse the string once. Each character is added to the Set once and removed at most once (2N ops = O(N)).",
                spaceExplainer: "<strong>Space: O(N)</strong><br>In worst case (all unique), the Set stores all N characters.",
                visual: `<span><strong>Visual: Elastic Window</strong><br>Expand Right. If duplicate found, shrink Left until unique.<br>
<pre style="background:none; border:none; padding:10px; font-size:0.8rem; line-height:1.2;">
 "ppwkew"
   ^  ^
   L  R
 Window: [w, k, e] -> Valid
</pre>
</span>`,
                crux: "No Duplicates allowed.<br><strong>Formula:</strong> <code>max_len = max(max_len, R - L + 1)</code>",
                strategy: "Use a <strong>Set</strong>. If <code>s[right]</code> exists in Set, <code>remove(s[left])</code> and <code>left++</code> until valid.",
                trap: "<strong>While Loop:</strong> Don't use `if`. Use `while` to remove characters until the duplicate is gone.",
                dryRun: [
                    "<strong>Input:</strong> 'abcabcbb'",
                    "1. R=0('a'): Set={'a'}, Len=1",
                    "2. R=1('b'): Set={'a','b'}, Len=2",
                    "3. R=2('c'): Set={'a','b','c'}, Len=3",
                    "4. R=3('a'): Duplicate 'a'! Remove s[L]('a'), L=1. Set={'b','c'}. Add 'a'. Set={'b','c','a'}. Len=3"
                ],
                codeTitle: "Python Solution (Clean)",
                code: `def length_of_longest_substring(s):
    char_set = set()
    left = 0
    max_length = 0

    for right in range(len(s)):
        # Shrink window if duplicate found
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1

        char_set.add(s[right])
        max_length = max(max_length, right - left + 1)

    return max_length`,
                codeDetailed: `def length_of_longest_substring(s):
    """
    Longest Substring Without Repeating Characters
    
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    CRUX: Sliding Window + HashSet
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    STRATEGY: Expand Right, Shrink Left if Invalid
    1. Maintain a Window [left, right]
    2. Use a SET to track characters in the current window
    3. If new char is in Set -> Shrink Left until it's gone
    4. Update max_length at every valid step
    
    Time: O(N), Space: O(N)
    """
    char_set = set()
    left = 0
    max_length = 0

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 1: Expand Window (Move Right Pointer)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for right in range(len(s)):
        
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # STEP 2: Handle Duplicates (Shrink Phase)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # WARNING: Use 'while', not 'if'. We might need to remove 
        # multiple characters to clear the duplicate.
        # Example: "abcc", right at second 'c', we remove 'a', 'b', then 'c'.
        
        while s[right] in char_set:
            # Remove from logic (Set)
            char_set.remove(s[left])
            # Remove from window (Pointer)
            left += 1

            # Visual:
            # [a, b, c, a] -> Duplicate 'a'!
            #  ^        ^
            #  L        R
            # Remove 'a', Move L -> [b, c, a] (Valid now)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # STEP 3: Add New Character & Update Max
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        char_set.add(s[right])  # Add current char to tracking
        
        # Window size = right - left + 1
        max_length = max(max_length, right - left + 1)

    return max_length`
            }
        },
        {
            id: "sort-colors",
            title: "Sort Colors",
            leetcodeUrl: "https://leetcode.com/problems/sort-colors/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Two Pointers"],
            quiz: {
                description: "Sort array of 0s, 1s, 2s in one pass. Method?",
                options: ["Merge Sort", "Counting Sort (2 pass)", "Dutch National Flag (1 pass)", "Quick Sort"],
                correct: 2,
                explanation: "Dutch National Flag Algorithm! 3 Pointers: Low (0 boundary), Mid (Scanner), High (2 boundary). If 0: swap(low, mid), low++, mid++. If 1: mid++. If 2: swap(mid, high), high--."
            },
            learn: {
                quickAlgo: [
                    "L, mid, R = 0, 0, len(nums)-1      # ğŸ¯ 3 Pointers: 0s, 1s, 2s boundaries",
                    "while mid <= R:",
                    "    if nums[mid] == 0:             # âš¡ Found 0: Move to Front",
                    "        swap(nums[L], nums[mid])",
                    "        L += 1; mid += 1",
                    "    elif nums[mid] == 1:           # ğŸ”„ Found 1: Skip",
                    "        mid += 1",
                    "    else:                          # ğŸ’¡ Found 2: Move to Back",
                    "        swap(nums[mid], nums[R])",
                    "        R -= 1                     # âœ… Don't move mid (check swapped val)"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                code: `def sortColors(nums):
l, r = 0, len(nums)-1
i = 0
while i <= r:
    if nums[i] == 0:
        nums[l], nums[i] = nums[i], nums[l]
        l += 1
        i += 1
    elif nums[i] == 2:
        nums[r], nums[i] = nums[i], nums[r]
        r -= 1
    else:
        i += 1`
            }
        },

        {
            id: "subarray-sum-xor-k",
            title: "Subarrays with XOR K",
            leetcodeUrl: "https://www.interviewbit.com/problems/subarray-with-given-xor/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["HashMap"],
            quiz: {
                description: "Count subarrays with XOR = K. Pattern?",
                options: ["Sliding Window", "Prefix XOR + HashMap", "Trie", "DP"],
                correct: 1,
                explanation: "XR = Prefix XOR. We want subarray ending at i with XOR K. So `XR ^ K` must exist previously? Yes. like Two Sum: Check map for `XR ^ K`. Add count."
            },
            learn: {
                quickAlgo: [
                    "count = 0; xor = 0",
                    "map = {0: 1}                       # ğŸ¯ Base case: XOR 0 seen once (empty prefix)",
                    "for n in nums:",
                    "    xor ^= n                       # âš¡ Current Prefix XOR",
                    "    target = xor ^ K               # ğŸ”„ Formula: Prefix[i] ^ Prefix[j] = K",
                    "    if target in map:",
                    "        count += map[target]       # âœ… Add occurrences of required prefix",
                    "    map[xor] = map.get(xor,0) + 1  # ğŸ’¡ Store current XOR frequency",
                    "return count"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                code: `def solve(A, B):
cnt = 0
xor = 0
map = {0: 1}
for n in A:
    xor ^= n
    if (xor ^ B) in map:
        cnt += map[xor ^ B]
    map[xor] = map.get(xor, 0) + 1
return cnt`
            }
        },
        {
            id: "longest-substring-k-distinct",
            title: "Longest Substring K Distinct",
            leetcodeUrl: "https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Sliding Window"],
            quiz: {
                description: "Max substring with at most K distinct chars.",
                options: ["DP", "Sliding Window + HashMap", "Recursion", "Greedy"],
                correct: 1,
                explanation: "Standard variable sliding window! Expand right, add to Map. While len(Map) > K, shrink left (decrement/remove from Map). Update max_len."
            },
            learn: {
                quickAlgo: [
                    "char_map = {}; L = 0; max_len = 0",
                    "for R in range(len(s)):           # ğŸ¯ Expand Right",
                    "    char_map[s[R]] = char_map.get(s[R], 0) + 1",
                    "    while len(char_map) > K:      # âš¡ Too many distinct chars!",
                    "        char_map[s[L]] -= 1       # ğŸ”„ Shrink Left",
                    "        if char_map[s[L]] == 0:",
                    "            del char_map[s[L]]    # âœ… Remove from tracking",
                    "        L += 1",
                    "    max_len = max(max_len, R-L+1) # ğŸ’¡ Valid window size",
                    "return max_len"
                ],
                metrics: { time: "O(N)", space: "O(K)" },
                code: `def lengthOfLongestSubstringKDistinct(s, k):
map = {}
l = 0
res = 0
for r, c in enumerate(s):
    map[c] = map.get(c, 0) + 1
    while len(map) > k:
        map[s[l]] -= 1
        if map[s[l]] == 0: del map[s[l]]
        l += 1
    res = max(res, r - l + 1)
return res`
            }
        }
    ]
}


// ========== data/dsa/binary_search.js ==========
// Binary Search data
// Extracted from data.js

const topic_binary_search = {
    id: "binary_search",
    title: "Binary Search Patterns",
    description: "Principal Engineer DSA â€¢ Day 2",
    color: "#2563eb",
    icon: "fas fa-search",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ” Sorted Data", desc: "Array sorted? â†’ Classic Binary Search" },
            { label: "ğŸ“ˆ Monotonic Function", desc: "F(x) goes F,F,F,T,T,T? â†’ Binary Search on Answer" },
            { label: "ğŸ”„ Rotated Array", desc: "Sorted but rotated? â†’ Find which half is sorted" },
            { label: "âš–ï¸ Min-Max / Max-Min", desc: "Optimize extremes? â†’ BS on Answer + Greedy check" },
            { label: "âœ‚ï¸ Partition", desc: "Split 2 arrays optimally? â†’ BS on smaller + auto-calc other" }
        ],
        patterns: [
            { algo: "Classic BS", use: "Find target in sorted array", time: "O(log N)", space: "O(1)", template: "while l<=r: mid=(l+r)//2" },
            { algo: "Rotated Array BS", use: "Search in rotated sorted", time: "O(log N)", space: "O(1)", template: "Find sorted half, check target range" },
            { algo: "BS on Answer", use: "Min speed, max distance", time: "O(N log M)", space: "O(1)", template: "Search [lo, hi], check if feasible(mid)" },
            { algo: "Min-Max / Max-Min", use: "Aggressive Cows, Books", time: "O(N log D)", space: "O(1)", template: "BS distance + greedy placement" },
            { algo: "Partition BS", use: "Median of 2 sorted", time: "O(log min(m,n))", space: "O(1)", template: "Cut smaller, calc j automatically" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Binary Search Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                 â”‚ "What are you searching?"â”‚
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â–¼                      â–¼                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TARGET in   â”‚        â”‚ ANSWER/     â”‚        â”‚ PARTITION   â”‚
â”‚ sorted arrayâ”‚        â”‚ SPEED/DIST  â”‚        â”‚ 2 arrays    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚                      â”‚                      â”‚
       â–¼                      â–¼                      â–¼
 "Is it rotated?"       "Can you check         "Use smaller for
       â”‚               if answer works?"         BS, calc other"
       â”‚                      â”‚                      â”‚
  â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                 â–¼                      â–¼
  â–¼         â–¼         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”‚ BS on range â”‚        â”‚ Median of   â”‚
â”‚ NO  â”‚ â”‚  YES  â”‚     â”‚ [lo, hi]    â”‚        â”‚ 2 sorted    â”‚
â”‚     â”‚ â”‚       â”‚     â”‚ is_feasible â”‚        â”‚ arrays      â”‚
â””â”€â”€â”¬â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚        â”‚
   â–¼        â–¼
Classic  Rotated
  BS       BS
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ nums[l]==nums[m]== â”‚
         â”‚ nums[r]? â†’ Shrink! â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Binary Search Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ Classic Binary Search
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def binary_search(nums, target):
    left, right = 0, len(nums) - 1
    while left <= right:
        mid = left + (right - left) // 2  # Prevent overflow!
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ BS on Answer (Koko Bananas)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def minEatingSpeed(piles, h):
    def can_finish(speed):
        return sum((p + speed - 1) // speed for p in piles) <= h
    
    left, right = 1, max(piles)
    while left <= right:
        mid = left + (right - left) // 2
        if can_finish(mid):
            right = mid - 1  # Try slower
        else:
            left = mid + 1   # Need faster
    return left
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Rotated Array Search
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def search(nums, target):
    low, high = 0, len(nums) - 1
    while low <= high:
        mid = low + (high - low) // 2
        if nums[mid] == target: return True
        # Handle duplicates (fog)
        if nums[low] == nums[mid] == nums[high]:
            low += 1; high -= 1
            continue
        # Left sorted
        if nums[low] <= nums[mid]:
            if nums[low] <= target < nums[mid]:
                high = mid - 1
            else:
                low = mid + 1
        # Right sorted
        else:
            if nums[mid] < target <= nums[high]:
                low = mid + 1
            else:
                high = mid - 1
    return False
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Maximize Minimum (Aggressive Cows)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def aggressiveCows(stalls, k):
    stalls.sort()  # MUST SORT!
    def can_place(min_dist):
        count, last = 1, stalls[0]
        for s in stalls[1:]:
            if s - last >= min_dist:
                count += 1
                last = s
        return count >= k
    
    left, right, ans = 1, stalls[-1] - stalls[0], 1
    while left <= right:
        mid = left + (right - left) // 2
        if can_place(mid):
            ans = mid
            left = mid + 1  # Try larger
        else:
            right = mid - 1
    return ans
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "âš ï¸ Overflow!", desc: "<code>mid = left + (right - left) // 2</code> NOT <code>(left + right) // 2</code>" },
            { label: "ğŸ”„ Infinite Loop!", desc: "If <code>high = mid</code>, use <code>while left < right</code> not <code><=</code>" },
            { label: "ğŸŒ«ï¸ Duplicates Fog!", desc: "When <code>nums[l]==nums[m]==nums[r]</code>, shrink: <code>l++, r--</code>" },
            { label: "ğŸ“Š Sort First!", desc: "Aggressive Cows: <code>stalls.sort()</code> before BS!" },
            { label: "ğŸ¯ Answer vs Index!", desc: "BS on Answer: return <code>left</code> (answer). Classic: return <code>mid</code> (index)" },
            { label: "â™¾ï¸ Virtual Infinity!", desc: "Partition problems: Use <code>float('-inf')</code> and <code>float('inf')</code> for edges" }
        ]
    },
    questions: [
        {
            id: "search-rotated-sorted-array-ii",
            title: "Search Rotated Sorted Array II",
            leetcodeUrl: "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Duplicates"],
            quiz: {
                description: "Array has duplicates. What breaks normal binary search?",
                options: [
                    "Nothing, works normally",
                    "When nums[low] == nums[mid] == nums[high], can't determine sorted half",
                    "Pivot point becomes undefined",
                    "Multiple targets possible"
                ],
                correct: 1,
                explanation: "Duplicates create 'fog'! When nums[low] == nums[mid] == nums[high], we can't tell which side is sorted. Solution: Shrink window (low++, high--) until fog clears. Worst case O(n)!"
            },
            learn: {
                quickAlgo: [
                    "L, R = 0, len(nums)-1",
                    "while L <= R:",
                    "    mid = L + (R-L)//2",
                    "    if nums[mid] == target: return True # ğŸ¯ Found",
                    "    if nums[L] == nums[mid] == nums[R]: # âš¡ Foggy Duplicates",
                    "        L += 1; R -= 1; continue        # ğŸ”„ Shrink window",
                    "    if nums[L] <= nums[mid]:            # âœ… Left Sorted",
                    "        if nums[L] <= target < nums[mid]: R = mid - 1",
                    "        else: L = mid + 1",
                    "    else:                               # ğŸ’¡ Right Sorted",
                    "        if nums[mid] < target <= nums[R]: L = mid + 1",
                    "        else: R = mid - 1",
                    "return False"
                ],
                metrics: { time: "Avg O(log N)", space: "O(1)" },
                timeExplainer: "<strong>Time Analysis:</strong><br>â€¢ <strong>Best/Avg:</strong> <code>O(log N)</code> - Standard binary search<br>â€¢ <strong>Worst:</strong> <code>O(N)</code> - All duplicates<br><br><strong>Why?</strong> Duplicates create 'fog' requiring linear scan",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Iterative approach with 3 pointers<br>â€¢ No recursion stack<br><br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Visual: The Foggy Cliff</strong><br>Imagine two slopes. When duplicates appear (1,1,1...), the slopes merge into a flat line ('fog'). You must walk blindly until the fog clears.</span>",
                crux: "If <code>nums[low] == nums[mid] == nums[high]</code>, we cannot determine which side is sorted.<br><strong>Strategy:</strong> Treat this as 'noise'. Shrink the window from both ends (<code>low++</code>, <code>high--</code>) until the unique numbers appear.",
                trap: "<strong>Worst Case O(N):</strong> If all elements are duplicates, we end up scanning the whole array linearly.",
                dryRun: [
                    "<strong>Input:</strong> [1, 0, 1, 1, 1], target = 0",
                    "1. L=0(1), R=4(1), M=2(1). <strong>Collision!</strong> 1==1==1. Action: L++, R--.",
                    "2. L=1(0), R=3(1), M=2(1). Left sorted? Yes. Target in range? Yes. Action: R = M - 1.",
                    "3. L=1(0), R=1(0). Match! Return True."
                ],
                codeTitle: "Python Solution (Principal Grade)",
                code: `def search(nums, target):
low, high = 0, len(nums) - 1

while low <= high:
    # Principal Habit: Prevent Overflow
    mid = low + (high - low) // 2
    
    if nums[mid] == target: return True
    
    # KEY: Handle Duplicates (The Fog)
    if nums[low] == nums[mid] == nums[high]:
        low += 1
        high -= 1
        continue
        
    # Standard Rotated Logic
    # Left side is sorted
    if nums[low] <= nums[mid]:
        if nums[low] <= target < nums[mid]:
            high = mid - 1
        else:
            low = mid + 1
    # Right side is sorted
    else:
        if nums[mid] < target <= nums[high]:
            low = mid + 1
        else:
            high = mid - 1
return False`
            }
        },
        {
            id: "koko-eating-bananas",
            title: "Koko Eating Bananas",
            leetcodeUrl: "https://leetcode.com/problems/koko-eating-bananas/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["BS on Answer"],
            quiz: {
                description: "Find minimum eating speed. What do we binary search on?",
                options: [
                    "Binary search the piles array",
                    "Binary search the ANSWER (speed range [1, max_pile])",
                    "Greedy selection",
                    "DP on remaining piles"
                ],
                correct: 1,
                explanation: "Binary Search on ANSWER! Search space = [1, max(piles)]. For each speed, calculate hours. If â‰¤ h, try slower (right = mid - 1). If > h, must go faster (left = mid + 1). Classic pattern!"
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>BS on Answer kyun?</strong> Speed 1 to Max ho sakti hai (Monotonic Range)",
                    "âš¡ Predicate: <code>can_eat(speed) <= H</code> hours check karo",
                    "ğŸ”„ Binary Search Speed: <code>[1, max(piles)]</code>",
                    "âœ… If feasible (<= H), try slower (store ans, go Left). Else go Right.",
                    "ğŸ’¡ Formula: <code>ceil(p / speed)</code> is equivalent to <code>(p + s - 1) // s</code>"
                ],
                metrics: { time: "O(N log M)", space: "O(1)" },
                timeExplainer: "<strong>Time Analysis:</strong><br>â€¢ Binary search range: <code>log M</code> iterations<br>â€¢ Each check: <code>O(N)</code> to sum hours<br><br><strong>Total:</strong> <code>O(N log M)</code> where M = max(piles)",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Only variables for binary search<br>â€¢ No extra arrays<br><br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Visual: The Inverse Curve</strong><br>As Speed (x-axis) increases, Hours (y-axis) decreases. <br>We want the <strong>Left-most</strong> point where Hours <= H.</span>",
                crux: "<strong>1. Search Space:</strong> We don't search the array. We search the range <code>[1, max(piles)]</code>.<br><strong>2. Decision:</strong> If Koko finishes in time, try slower (Left). If fails, go faster (Right).",
                trap: "<strong>Floating Point Math:</strong> Using `math.ceil` is slow. Use integer ceiling: <code>(p + s - 1) // s</code>.",
                dryRun: [
                    "<strong>Input:</strong> piles=[3, 6, 7, 11], h=8. Range [1, 11].",
                    "1. Mid=6. Hours=6. (OK). Try Slower [1-5].",
                    "2. Mid=3. Hours=10. (Too Slow). Try Faster [4-5].",
                    "3. Mid=4. Hours=8. (OK). Try Slower [4-3]. End."
                ],
                codeTitle: "Python Solution (Production Grade)",
                code: `def minEatingSpeed(piles: List[int], h: int) -> int:
min_speed, max_speed = 1, max(piles)

def get_hours(speed):
    return sum((p + speed - 1) // speed for p in piles)
    
while min_speed <= max_speed:
    mid_speed = min_speed + (max_speed - min_speed) // 2
    
    if get_hours(mid_speed) <= h:
        max_speed = mid_speed - 1
    else:
        min_speed = mid_speed + 1
        
return min_speed`
            }
        },
        {
            id: "aggressive-cows",
            title: "Aggressive Cows",
            leetcodeUrl: "https://www.spoj.com/problems/AGGRCOW/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Min-Max"],
            quiz: {
                description: "Maximize minimum distance between cows. What's the first step?",
                options: [
                    "Greedy placement",
                    "SORT stalls first! Then BS on distance",
                    "DP on positions",
                    "Try all combinations"
                ],
                correct: 1,
                explanation: "SORT + BS on Answer! Sort stalls. Binary search on distance [1, max-min]. For each distance, greedily try to place K cows. If successful, try larger distance (left = mid + 1). Min-Max pattern!"
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Max-Min logic?</strong> Hamesha 'Maximize the Minimum distance' = BS on Answer",
                    "âš¡ Sort Stalls: Distances check karne ke liye order zaroori hai",
                    "ğŸ”„ Range: <code>[1, max-min]</code>. Check: <code>can_place(min_dist)</code>",
                    "âœ… Greedy Check: Place first cow, then next if <code>dist >= mid</code>",
                    "ğŸ’¡ Valid? Try bigger gap (Right). Invalid? Shrink gap (Left)."
                ],
                metrics: { time: "O(N log N)", space: "O(1)" },
                timeExplainer: "<strong>Time Breakdown:</strong><br>â€¢ Sorting stalls: <code>O(N log N)</code><br>â€¢ Binary search Ã— greedy check: <code>O(N log D)</code><br><br><strong>Total:</strong> <code>O(N log N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ In-place sorting possible<br>â€¢ Only variables for counting<br><br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>System Design Mapping:</strong> Load Balancing.<br>Imagine Stalls are IP Addresses and Cows are Microservices. Check max safety buffer.</span>",
                crux: "<strong>'Maximize the Minimum'</strong><br>1. Sort stalls.<br>2. BS on Distance.<br>3. Greedy Check: Can we place K cows with gap >= mid?",
                trap: "<strong>The Unsorted Array:</strong> The Greedy Check requires stalls to be sorted. Don't forget <code>stalls.sort()</code>.",
                dryRun: [
                    "<strong>Input:</strong> Stalls=[1, 2, 8, 4, 9], K=3.",
                    "Step 0: SORT -> [1, 2, 4, 8, 9].",
                    "1. Mid=4. Place@1. Next@8. Count=2. FAIL. Gap too big.",
                    "2. Mid=2. Place@1. Next@4. Next@8. Count=3. SUCCESS.",
                    "3. Mid=3. Place@1. Next@4. Next@8. Count=3. SUCCESS."
                ],
                codeTitle: "Python Solution",
                code: `def aggressiveCows(stalls: List[int], k: int) -> int:
stalls.sort()

def can_place(min_dist):
    count = 1
    last_pos = stalls[0]
    for i in range(1, len(stalls)):
        if stalls[i] - last_pos >= min_dist:
            count += 1
            last_pos = stalls[i]
            if count == k: return True
    return False

low, high = 1, stalls[-1] - stalls[0]
ans = 1

while low <= high:
    mid = low + (high - low) // 2
    if can_place(mid):
        ans = mid
        low = mid + 1
    else:
        high = mid - 1
return ans`
            }
        },
        {
            id: "median-of-two-sorted-arrays",
            title: "Median of 2 Sorted Arrays",
            leetcodeUrl: "https://leetcode.com/problems/median-of-two-sorted-arrays/",
            difficulty: "HARD",
            priority: "ğŸŸ¡",
            tags: ["Partitioning"],
            quiz: {
                description: "Find median in O(log(min(m,n))). What's the trick?",
                options: [
                    "Merge both arrays O(m+n)",
                    "Partition smaller array, calculate j automatically",
                    "Binary search both arrays",
                    "Two pointers"
                ],
                correct: 1,
                explanation: "Partition + Virtual Infinity! BS on smaller array (cut at i). Calculate j for larger array: j = (m+n+1)/2 - i. Valid when maxLeft_X â‰¤ minRight_Y and maxLeft_Y â‰¤ minRight_X. Handle edges with Â±âˆ!"
            },
            learn: {
                quickAlgo: [
                    "A, B = nums1, nums2",
                    "total = len(A) + len(B); half = total // 2",
                    "if len(A) > len(B): A, B = B, A    # ğŸ¯ BS on smaller array",
                    "L, R = 0, len(A)-1",
                    "while True:",
                    "    i = (L + R) // 2               # âš¡ A's partition",
                    "    j = half - i - 2               # ğŸ”„ B's partition",
                    "    Aleft = A[i] if i >= 0 else float('-inf')",
                    "    Aright = A[i+1] if i+1 < len(A) else float('inf')",
                    "    Bleft = B[j] if j >= 0 else float('-inf')",
                    "    Bright = B[j+1] if j+1 < len(B) else float('inf')",
                    "    if Aleft <= Bright and Bleft <= Aright: # âœ… Valid Partition",
                    "        if total % 2: return min(Aright, Bright)",
                    "        else: return (max(Aleft, Bleft) + min(Aright, Bright)) / 2",
                    "    elif Aleft > Bright: R = i - 1 # ğŸ’¡ A too big, move left",
                    "    else: L = i + 1                # ğŸ’¡ A too small, move right"
                ],
                metrics: { time: "O(log min(N,M))", space: "O(1)" },
                timeExplainer: "<strong>Time Analysis:</strong><br>â€¢ Binary search on smaller array<br>â€¢ Always pick smaller for partitioning<br><br><strong>Total:</strong> <code>O(log min(N, M))</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Only partition pointers<br>â€¢ No extra arrays<br><br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Mental Model: The Perfect Cut</strong><br>Slice both arrays such that elements on Left <= elements on Right.</span>",
                crux: "Don't merge! Partition array A at `i`. Partition B at `j` is auto-calculated.<br>Goal: `maxLeftA <= minRightB` & `maxLeftB <= minRightA`.",
                trap: "<strong>Edge Cases:</strong> What if cut is at 0 or N? Use <code>-âˆ</code> and <code>+âˆ</code>.",
                dryRun: [
                    "<strong>Input:</strong> X=[1, 3], Y=[2].",
                    "1. Cut X at 1 (Left: {1}, Right: {3}). Cut Y at 1 (Left: {2}, Right: {Inf}).",
                    "Check: 1 <= Inf? OK. 2 <= 3? OK.",
                    "Found! Median = max(1, 2) = 2."
                ],
                codeTitle: "Python Solution (Virtual Infinity)",
                code: `def findMedianSortedArrays(nums1, nums2):
if len(nums1) > len(nums2): 
    nums1, nums2 = nums2, nums1

m, n = len(nums1), len(nums2)
low, high = 0, m

while low <= high:
    partitionX = low + (high - low) // 2
    partitionY = (m + n + 1) // 2 - partitionX
    
    maxLeftX = float('-inf') if partitionX == 0 else nums1[partitionX - 1]
    minRightX = float('inf') if partitionX == m else nums1[partitionX]
    
    maxLeftY = float('-inf') if partitionY == 0 else nums2[partitionY - 1]
    minRightY = float('inf') if partitionY == n else nums2[partitionY]
    
    if maxLeftX <= minRightY and maxLeftY <= minRightX:
        if (m + n) % 2 == 0:
            return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2
        else:
            return max(maxLeftX, maxLeftY)
    elif maxLeftX > minRightY:
        high = partitionX - 1
    else:
        low = partitionX + 1`
            }
        }
    ]
}


// ========== data/dsa/linked_list.js ==========
// Linked List data
// Extracted from data.js

const topic_linked_list = {
    id: "linked_list",
    title: "Linked List Mastery",
    description: "Principal Engineer DSA â€¢ Day 4",
    color: "#059669",
    icon: "fas fa-network-wired",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ¯ O(1) Cache", desc: "LRU/LFU Cache â†’ HashMap + Doubly Linked List" },
            { label: "ğŸ”„ Cycle Detection", desc: "Find loop â†’ Floyd's Slow/Fast pointers" },
            { label: "âœ‚ï¸ Reversal", desc: "Reverse K groups, halves â†’ Use prev/curr/next pointers" },
            { label: "ğŸ“‹ Deep Copy", desc: "Clone with random â†’ HashMap or Interleaving" },
            { label: "ğŸƒ Two Pointers", desc: "Find middle, palindrome â†’ Slow/Fast technique" }
        ],
        patterns: [
            { algo: "LRU Cache", use: "O(1) get/put with eviction", time: "O(1)", space: "O(N)", template: "HashMap{keyâ†’node} + DLL (head=recent, tail=old)" },
            { algo: "Floyd's Algorithm", use: "Cycle detection + start", time: "O(N)", space: "O(1)", template: "slow/fast meet, reset slow to head, both move 1" },
            { algo: "K-Group Reversal", use: "Reverse every K nodes", time: "O(N)", space: "O(1)", template: "get_kth, reverse inner, rewire anchors" },
            { algo: "Interleaving Clone", use: "Deep copy O(1) space", time: "O(N)", space: "O(1)", template: "Weave copies â†’ link randoms â†’ unweave" },
            { algo: "Palindrome Check", use: "O(1) space check", time: "O(N)", space: "O(1)", template: "Find mid â†’ reverse 2nd half â†’ compare" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Linked List Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "Linked List problem type?"  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CYCLE/LOOP   â”‚      â”‚  REVERSAL    â”‚      â”‚  CACHE/      â”‚
â”‚  Problems    â”‚      â”‚  Problems    â”‚      â”‚  DESIGN      â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚                     â”‚
       â–¼                     â–¼                     â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Floyd's Algo  â”‚    â”‚ Use DUMMY!    â”‚    â”‚ HashMap +     â”‚
 â”‚               â”‚    â”‚               â”‚    â”‚ Doubly LL     â”‚
 â”‚ Slow = 1 step â”‚    â”‚ prev=None     â”‚    â”‚               â”‚
 â”‚ Fast = 2 step â”‚    â”‚ curr=head     â”‚    â”‚ _add() _del() â”‚
 â”‚               â”‚    â”‚ loop: swap    â”‚    â”‚ helpers       â”‚
 â”‚ Meet? â†’ Reset â”‚    â”‚               â”‚    â”‚               â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         "Need to find middle?"
              â”‚
              â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ SLOW/FAST pointers    â”‚
      â”‚ When fast reaches end â”‚
      â”‚ slow is at middle!    â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Linked List Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ LRU Cache (DLL + HashMap)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
class LRUCache:
    def __init__(self, cap):
        self.cap, self.cache = cap, {}
        self.head, self.tail = Node(0,0), Node(0,0)
        self.head.next, self.tail.prev = self.tail, self.head
    def _remove(self, node):
        node.prev.next, node.next.prev = node.next, node.prev
    def _add(self, node):
        node.prev, node.next = self.head, self.head.next
        self.head.next.prev = node
        self.head.next = node
    def get(self, key):
        if key in self.cache:
            self._remove(self.cache[key])
            self._add(self.cache[key])
            return self.cache[key].val
        return -1
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Floyd's Cycle Detection
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def detectCycle(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
        if slow == fast:
            slow = head  # Reset!
            while slow != fast:
                slow = slow.next
                fast = fast.next
            return slow  # Cycle start
    return None
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Reverse Linked List
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def reverse(head):
    prev, curr = None, head
    while curr:
        next_temp = curr.next
        curr.next = prev
        prev = curr
        curr = next_temp
    return prev
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Find Middle (Slow/Fast)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def findMiddle(head):
    slow, fast = head, head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    return slow  # Middle node
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ”— Use DUMMY!", desc: "<code>dummy = ListNode(0, head)</code> â€” Handles edge cases at head" },
            { label: "ğŸ“ Save next first!", desc: "Before changing <code>curr.next</code>, save <code>temp = curr.next</code>" },
            { label: "ğŸ”„ Check null!", desc: "<code>while fast and fast.next</code> â€” Both conditions needed!" },
            { label: "âš ï¸ Delete from map!", desc: "LRU: When evicting, <code>del cache[lru.key]</code> â€” Often forgotten!" },
            { label: "ğŸ” Phase 2 reset!", desc: "Floyd's: Reset <code>slow = head</code> AFTER meeting, not before" },
            { label: "â†©ï¸ Restore list!", desc: "After palindrome check, reverse back to restore original" }
        ]
    },
    questions: [
        {
            id: "lru-cache",
            title: "LRU Cache",
            leetcodeUrl: "https://leetcode.com/problems/lru-cache/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Design #1"],
            quiz: {
                description: "Implement get() and put() in O(1). Which data structures?",
                options: [
                    "HashMap only",
                    "Doubly Linked List + HashMap (key â†’ node)",
                    "Array + HashMap",
                    "Queue + HashMap"
                ],
                correct: 1,
                explanation: "Doubly LL + HashMap! HashMap for O(1) lookup. DLL for O(1) removal/insertion at head/tail. Get: move to head. Put: if full, remove tail. Add to head. #1 design question!"
            },
            learn: {
                quickAlgo: [
                    "class Node: prev, next, key, val",
                    "def get(key):",
                    "    if key in map:",
                    "        node = map[key]; remove(node); add(node) # âš¡ Move to Head (Most Recent)",
                    "        return node.val",
                    "    return -1",
                    "def put(key, val):",
                    "    if key in map: remove(map[key])    # ğŸ”„ Update existing",
                    "    node = Node(key, val); add(node)   # âœ… Add new to Head",
                    "    map[key] = node",
                    "    if len(map) > cap:",
                    "        lru = head.next; remove(lru)   # ğŸ’¡ Evict Tail (Least Recent)",
                    "        del map[lru.key]"
                ],
                metrics: { time: "O(1)", space: "O(N)" },
                timeExplainer: "<strong>Time Analysis:</strong><br>â€¢ <code>get()</code>: HashMap lookup = <code>O(1)</code><br>â€¢ <code>put()</code>: Map + DLL operations = <code>O(1)</code><br><br><strong>All operations:</strong> <code>O(1)</code> average",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ HashMap: <code>O(N)</code> for N key-value pairs<br>â€¢ Doubly Linked List: <code>O(N)</code> nodes<br><br><strong>Total:</strong> <code>O(N)</code>",
                visual: "<span><strong>Visual: The Hybrid Engine</strong><br>HashMap stores <code>{Key -> Node}</code> for speed.<br>DLL stores <code>Order</code> (Head=Recent, Tail=Old).</span>",
                crux: "<strong>The Wire-Splicing Strategy:</strong><br>Helpers: <code>_remove(node)</code> (Unplug) and <code>_add(node)</code> (Plug at front).<br>Get: Remove -> Add.<br>Put: Remove Old -> Add New. If Full: Remove Tail.",
                trap: "<strong>Phantom Pointer:</strong> When evicting tail, you MUST delete it from the HashMap too! Often forgotten.",
                dryRun: [
                    "1. Put(1, 1): Map={1:N1}, List=[1].",
                    "2. Put(2, 2): Map={1:N1, 2:N2}, List=[2, 1].",
                    "3. Get(1): Remove 1, Add 1. List=[1, 2].",
                    "4. Put(3, 3) Cap=2: Evict Tail(2). Map={1:N1, 3:N3}. List=[3, 1]."
                ],
                codeTitle: "Python Solution",
                code: `class LRUCache:
def __init__(self, capacity: int):
    self.cap = capacity
    self.cache = {} 
    self.head, self.tail = Node(0, 0), Node(0, 0)
    self.head.next = self.tail
    self.tail.prev = self.head

def _remove(self, node):
    prev, nxt = node.prev, node.next
    prev.next, nxt.prev = nxt, prev

def _add(self, node):
    node.prev, node.next = self.head, self.head.next
    self.head.next.prev = node
    self.head.next = node

def get(self, key):
    if key in self.cache:
        self._remove(self.cache[key])
        self._add(self.cache[key])
        return self.cache[key].val
    return -1

def put(self, key, value):
    if key in self.cache:
        self._remove(self.cache[key])
    new_node = Node(key, value)
    self._add(new_node)
    self.cache[key] = new_node
    if len(self.cache) > self.cap:
        lru = self.tail.prev
        self._remove(lru)
        del self.cache[lru.key]`
            }
        },
        {
            id: "reverse-linked-list-k-group",
            title: "Reverse in K Groups",
            leetcodeUrl: "https://leetcode.com/problems/reverse-nodes-in-k-group/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Pointer Mastery"],
            quiz: {
                description: "Reverse every K nodes. What's the challenge?",
                options: [
                    "Standard reversal works",
                    "Need to track: prev_group_end, curr_group, next_group_start",
                    "Use recursion only",
                    "Convert to array"
                ],
                correct: 1,
                explanation: "Pointer management! For each group: connect prev_group.next to new head. Connect new tail to next_group. Edge cases: < K nodes at end (don't reverse)."
            },
            learn: {
                quickAlgo: [
                    "dummy = ListNode(0, head)",
                    "groupPrev = dummy",
                    "while True:",
                    "    kth = getKth(groupPrev, k)     # ğŸ¯ Check if K nodes exist",
                    "    if not kth: break",
                    "    groupNext = kth.next",
                    "    # âš¡ Reverse K nodes [curr ... kth]",
                    "    prev, curr = kth.next, groupPrev.next",
                    "    while curr != groupNext:",
                    "        tmp = curr.next; curr.next = prev; prev = curr; curr = tmp",
                    "    # ğŸ”„ Connect reversed group",
                    "    tmp = groupPrev.next           # Old start is now end",
                    "    groupPrev.next = prev          # âœ… Connect start",
                    "    groupPrev = tmp                # ğŸ’¡ Move pointer for next group"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Time Analysis:</strong><br>â€¢ Visit each node once<br>â€¢ Reversal within groups is O(K)<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Only pointers for manipulation<br>â€¢ No extra data structures<br><br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Visual: The Surgery</strong><br>1. Identify K segment.<br>2. Snip wires.<br>3. Flip.<br>4. Reconnect Anchors.</span>",
                crux: "<strong>Don't get lost.</strong><br>Use `get_kth` to find group end.<br>After reverse, your `groupPrev` is broken. Update it to the NEW tail.",
                trap: "<strong>Losing the Anchor:</strong> `groupPrev` must point to the new tail after each reversal to be ready for the next group.",
                dryRun: [
                    "Input: 1->2->3->4->5, K=2",
                    "1. Group [1,2]. Rev -> 2->1. Link dummy->2, 1->3. Prev=1.",
                    "2. Group [3,4]. Rev -> 4->3. Link 1->4, 3->5. Prev=3.",
                    "3. Group [5]. Len < K. Stop."
                ],
                codeTitle: "Python Solution",
                code: `def reverseKGroup(head, k):
dummy = ListNode(0, head)
groupPrev = dummy

while True:
    kth = get_kth(groupPrev, k)
    if not kth: break
    groupNext = kth.next
    
    # Reverse inner
    prev, curr = kth.next, groupPrev.next
    while curr != groupNext:
        tmp = curr.next
        curr.next = prev
        prev = curr
        curr = tmp
        
    # Re-wire
    tmp = groupPrev.next # Old start (new tail)
    groupPrev.next = prev # New head
    groupPrev = tmp # Move anchor
    
return dummy.next`
            }
        },
        {
            id: "linked-list-cycle-ii",
            title: "Detect Loop Start",
            leetcodeUrl: "https://leetcode.com/problems/linked-list-cycle-ii/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Floyd's Algo"],
            quiz: {
                description: "Find WHERE the cycle starts. What's the math?",
                options: [
                    "HashMap to find first revisited node",
                    "Slow/Fast meet, then reset slow to head, move both by 1",
                    "Mark nodes",
                    "Count nodes in cycle"
                ],
                correct: 1,
                explanation: "Floyd's Math! After slow/fast meet, reset slow to head. Move both by 1 step. They meet AT cycle start! Proven by math."
            },
            learn: {
                quickAlgo: [
                    "slow, fast = head, head",
                    "while fast and fast.next:",
                    "    slow = slow.next",
                    "    fast = fast.next.next",
                    "    if slow == fast:               # âš¡ Cycle Detected",
                    "        slow = head                # ğŸ”„ Reset Slow to Head",
                    "        while slow != fast:        # ğŸ¯ Move both 1 step",
                    "            slow = slow.next",
                    "            fast = fast.next",
                    "        return slow                # âœ… Meeting point is Start of Cycle",
                    "return None"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Floyd's Algorithm:</strong><br>â€¢ Phase 1: Detect cycle = <code>O(N)</code><br>â€¢ Phase 2: Find start = <code>O(N)</code><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Only 2 pointers: slow, fast<br>â€¢ No HashSet needed!<br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Visual: The P Shape</strong><br>Distance(Head to Start) = Distance(Meeting to Start).</span>",
                crux: "<strong>Phase 1:</strong> Intercept (do they collide?).<br><strong>Phase 2:</strong> Reset slow to head. Move both 1 step. Collision = Start.",
                trap: "<strong>The False Start:</strong> `slow` and `fast` equal at head initially. Don't return true immediately!",
                dryRun: [
                    "1. Slow moves 1, Fast 2.",
                    "2. Collision! Cycle found.",
                    "3. Slow = Head. Move both 1 step.",
                    "4. Second Collision = Loop Entry."
                ],
                codeTitle: "Python Solution",
                code: `def detectCycle(head):
slow, fast = head, head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next
    if slow == fast:
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
return None`
            }
        },
        {
            id: "copy-list-with-random-pointer",
            title: "Clone with Random Pointer",
            leetcodeUrl: "https://leetcode.com/problems/copy-list-with-random-pointer/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Deep Copy"],
            quiz: {
                description: "Deep copy with random pointers. Best approach?",
                options: [
                    "HashMap: old_node â†’ new_node, then copy random",
                    "Interleaving: insert copies between originals",
                    "Recursion with memo",
                    "Modify original structure"
                ],
                correct: 0,
                explanation: "HashMap is cleaner! Interleaving works (O(1) space) but is trickier. Both are accepted."
            },
            learn: {
                quickAlgo: [
                    "map = {None: None}                 # ğŸ¯ Map old_node -> new_node",
                    "cur = head",
                    "while cur:                         # âš¡ 1st Pass: Create copies",
                    "    map[cur] = Node(cur.val)",
                    "    cur = cur.next",
                    "cur = head",
                    "while cur:                         # ğŸ”„ 2nd Pass: Link pointers",
                    "    copy = map[cur]",
                    "    copy.next = map[cur.next]      # âœ… Link Next",
                    "    copy.random = map[cur.random]  # âœ… Link Random",
                    "    cur = cur.next",
                    "return map[head]"
                ],
                metrics: { time: "O(N)", space: "O(1) (Interleaving)" },
                timeExplainer: "<strong>3-Pass Algorithm:</strong><br>â€¢ Pass 1: Weave copies = <code>O(N)</code><br>â€¢ Pass 2: Link randoms = <code>O(N)</code><br>â€¢ Pass 3: Unweave = <code>O(N)</code><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Interleaving Method:</strong><br>â€¢ Insert copies inline<br>â€¢ No HashMap needed<br><strong>Result:</strong> <code>O(1)</code> extra space",
                visual: "<span><strong>Visual: DNA Replication</strong><br>Pass 1: Weave A->A'->B->B'.<br>Pass 2: Link Randoms.<br>Pass 3: Unweave.</span>",
                crux: "<strong>Interleaving Strategy:</strong><br>1. Insert Copy next to Original.<br>2. `copy.random = original.random.next`.<br>3. Extract Copy list.",
                trap: "<strong>Null Crash:</strong> Check `if curr.random:` before accessing `next`.",
                dryRun: ["1. Weave: 1->1'->2->2'.", "2. Rand: 1'.rand = 1.rand.next.", "3. Split: 1->2, 1'->2'."],
                codeTitle: "Python Solution",
                code: `def copyRandomList(head):
if not head: return None
curr = head
while curr: # Weave
    new_node = Node(curr.val, next=curr.next)
    curr.next = new_node
    curr = new_node.next
curr = head
while curr: # Random
    if curr.random:
        curr.next.random = curr.random.next
    curr = curr.next.next
old_head = head
new_head = head.next
curr_old = old_head
curr_new = new_head
while curr_old: # Unweave
    curr_old.next = curr_old.next.next
    if curr_new.next:
        curr_new.next = curr_new.next.next
    curr_old = curr_old.next
    curr_new = curr_new.next
return new_head`
            }
        },
        {
            id: "palindrome-linked-list",
            title: "Palindrome Linked List",
            leetcodeUrl: "https://leetcode.com/problems/palindrome-linked-list/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¢",
            tags: ["Half-Reversal"],
            quiz: {
                description: "Check palindrome in O(n) time, O(1) space. How?",
                options: [
                    "Convert to array O(n) space",
                    "Find mid (slow/fast), reverse second half, compare",
                    "Recursion O(n) stack",
                    "Use stack O(n) space"
                ],
                correct: 1,
                explanation: "Find mid + Reverse! Use slow/fast to find middle. Reverse second half. Compare halves. Optional: reverse back."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Middle Reverse kyun?</strong> Array mein convert kiya toh O(N) space lagega",
                    "âš¡ <code>fast/slow</code> se mid find karo",
                    "ğŸ”„ Reverse <code>slow.next</code> (second half)",
                    "âœ… 2 pointers: <code>left=head, right=tail</code> â€” match karo",
                    "ğŸ’¡ Restore list (optional) â€” dobara reverse karke original state laao"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: "<strong>Time Breakdown:</strong><br>â€¢ Find middle: <code>O(N/2)</code><br>â€¢ Reverse second half: <code>O(N/2)</code><br>â€¢ Compare: <code>O(N/2)</code><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ No extra array for reversal<br>â€¢ In-place manipulation<br><strong>Result:</strong> <code>O(1)</code>",
                visual: "<span><strong>Visual: The Butterfly</strong><br>1. Find Body (Mid).<br>2. Flip Right Wing.<br>3. Compare Wings.</span>",
                crux: "Singly lists only go forward. To read backward, we must <strong>Reverse the Second Half</strong>.",
                trap: "<strong>Destructive Read:</strong> You broke the list! Good engineers restore the list before returning.",
                dryRun: ["1. 1->2->2->1. Slow at 2nd 2.", "2. Reverse 2->1 to 1->2.", "3. Compare 1->2 with 1->2. Match."],
                codeTitle: "Python Solution",
                code: `def isPalindrome(head):
slow, fast = head, head
while fast and fast.next:
    slow = slow.next
    fast = fast.next.next

prev = None
curr = slow
while curr: # Reverse 2nd half
    tmp = curr.next
    curr.next = prev
    prev = curr
    curr = tmp
    
left, right = head, prev
while right:
    if left.val != right.val: return False
    left = left.next
    right = right.next
return True`
            }
        }
    ]
}


// ========== data/dsa/stack.js ==========
// Stack data
// Extracted from data.js

const topic_stack = {
    id: "stack",
    title: "Monotonic Stack Mastery",
    description: "Principal Engineer DSA â€¢ Day 3",
    color: "#7c3aed",
    icon: "fas fa-layer-group",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ“ˆ Next Greater/Smaller", desc: "Find next larger or smaller element â†’ Monotonic Stack" },
            { label: "ğŸ“Š Rectangle Area", desc: "Max rectangle in histogram â†’ Monotonic Increasing Stack" },
            { label: "ğŸ’§ Trapping Water", desc: "Water between bars â†’ Decreasing Stack (horizontal slicing)" },
            { label: "ğŸ’¥ Collision/Matching", desc: "Parentheses, Asteroids â†’ Stack simulation" },
            { label: "â³ Delayed Processing", desc: "Wait for future info to resolve current element" }
        ],
        patterns: [
            { algo: "NGE (Decreasing Stack)", use: "Next Greater Element", time: "O(N)", space: "O(N)", template: "while stack and arr[top] < curr: pop, resolve" },
            { algo: "NSE (Increasing Stack)", use: "Next Smaller Element", time: "O(N)", space: "O(N)", template: "while stack and arr[top] > curr: pop, resolve" },
            { algo: "Histogram Rectangle", use: "Max rectangle area", time: "O(N)", space: "O(N)", template: "Increasing stack + sentinel, width = i - stack[-1] - 1" },
            { algo: "Trapping Rain Water", use: "Water between bars", time: "O(N)", space: "O(N)", template: "Decreasing stack, floor = pop, water = min(L,R) - floor" },
            { algo: "Stack Simulation", use: "Collisions, matching", time: "O(N)", space: "O(N)", template: "Push stable, battle on conflict" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Stack Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "What are you looking for?"  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ NEXT GREATER â”‚      â”‚ AREA/RANGE   â”‚      â”‚  MATCHING/   â”‚
â”‚    ELEMENT   â”‚      â”‚  PROBLEMS    â”‚      â”‚  COLLISION   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚                     â”‚
       â–¼                     â–¼                     â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ DECREASING    â”‚    â”‚ Histogram?    â”‚    â”‚ Parentheses?  â”‚
 â”‚ Stack         â”‚    â”‚ â†’ INCREASING  â”‚    â”‚ Asteroids?    â”‚
 â”‚               â”‚    â”‚ Stack         â”‚    â”‚ â†’ Simulate!   â”‚
 â”‚ Pop when      â”‚    â”‚               â”‚    â”‚               â”‚
 â”‚ curr > top    â”‚    â”‚ Water Trap?   â”‚    â”‚ Push stable,  â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â†’ DECREASING  â”‚    â”‚ battle on     â”‚
                      â”‚ Stack         â”‚    â”‚ conflict      â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ğŸ”‘ KEY INSIGHT: Stack stores UNRESOLVED elements        â”‚
  â”‚    When conflict occurs â†’ POP and RESOLVE!             â”‚
  â”‚    Remaining in stack â†’ No answer (-1 or default)       â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Stack Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ Next Greater Element (NGE)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def nextGreaterElement(arr):
    n = len(arr)
    result = [-1] * n
    stack = []  # Store INDICES
    
    for current_index in range(n):
        # Pop all smaller elements
        while stack and arr[stack[-1]] < arr[current_index]:
            smaller_index = stack.pop()
            result[smaller_index] = arr[current_index]
        stack.append(current_index)
    return result
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Largest Rectangle in Histogram
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def largestRectangleArea(heights):
    heights.append(0)  # Sentinel to clear stack
    stack = [-1]       # Sentinel for left boundary
    max_area = 0
    
    for i, h in enumerate(heights):
        while stack[-1] != -1 and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1
            max_area = max(max_area, height * width)
        stack.append(i)
    return max_area
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Trapping Rain Water (Stack)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def trap(height):
    stack = []  # Decreasing stack
    water = 0
    
    for i, h in enumerate(height):
        while stack and h > height[stack[-1]]:
            floor = stack.pop()
            if not stack: break  # No left wall
            left = stack[-1]
            width = i - left - 1
            bounded_h = min(height[left], h) - height[floor]
            water += width * bounded_h
        stack.append(i)
    return water
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Asteroid Collision
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def asteroidCollision(asteroids):
    stack = []
    for current in asteroids:
        while stack and current < 0 < stack[-1]:
            if abs(current) > stack[-1]:
                stack.pop(); continue
            elif abs(current) == stack[-1]:
                stack.pop(); break
            else:
                break
        else:
            stack.append(current)
    return stack
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ“‹ Store INDICES!", desc: "Always store indices in stack, not values: <code>stack.append(i)</code>" },
            { label: "ğŸ” Check empty!", desc: "<code>if stack</code> before <code>stack[-1]</code> or <code>stack.pop()</code>" },
            { label: "ğŸ“‰ Decreasing = NGE!", desc: "Next GREATER â†’ Decreasing stack (pop when curr > top)" },
            { label: "ğŸ“ˆ Increasing = NSE!", desc: "Next SMALLER â†’ Increasing stack (pop when curr < top)" },
            { label: "ğŸš¨ Sentinel trick!", desc: "Append 0 to force-clear stack at end (Histogram)" },
            { label: "âš ï¸ Width formula!", desc: "Rectangle width = <code>i - stack[-1] - 1</code> (not i - popped)" }
        ]
    },
    questions: [
        {
            id: "next-greater-element",
            title: "Next Greater Element",
            leetcodeUrl: "https://leetcode.com/problems/next-greater-element-i/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Monotonic Stack"],
            quiz: {
                description: "For each element, find next greater to the right. Pattern?",
                options: [
                    "Nested loops O(nÂ²)",
                    "Monotonic Decreasing Stack (traverse right to left)",
                    "Binary search O(n log n)",
                    "Heap-based"
                ],
                correct: 1,
                explanation: "Monotonic Stack! Traverse right to left (or store indices). If current > stack.top, current is NGE for top. Stack maintains decreasing order. O(n)!"
            },
            learn: {
                quickAlgo: [
                    "res = [-1] * n",
                    "stack = []                     # ğŸ¯ Store INDICES",
                    "for i in range(len(nums)):",
                    "    while stack and nums[stack[-1]] < nums[i]: # âš¡ Found NGE!",
                    "        idx = stack.pop()",
                    "        res[idx] = nums[i]     # âœ… Map NGE for popped index",
                    "    stack.append(i)            # ğŸ’¡ Push current index",
                    "return res"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Monotonic Stack:</strong><br>â€¢ Each element pushed ONCE<br>â€¢ Each element popped ONCE<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Stack stores indices<br>â€¢ Worst Case: Decreasing order [5,4,3,2,1] -> Stack holds all N elements.<br><strong>Aux:</strong> <code>O(N)</code>",
                visual: `<div style="text-align:center;">
                    <div style="font-size:3rem; margin-bottom:10px;">ğŸ“‰ â¡ï¸ ğŸ“ˆ</div>
                    <div><strong>Visual: The Horizon</strong></div>
                    <div style="font-size:0.9rem; color:var(--text-muted); margin-top:5px;">
                        Imagine looking to the right. You can only see the first person <strong>taller</strong> than you.<br>
                        Smaller people get hidden (popped) by taller ones.
                    </div>
                </div>`,
                crux: "<strong>Framework (Monotonic Decreasing Stack):</strong><br>1. Store <strong>Indices</strong> (better than values).<br>2. Loop `i` from `0` to `N-1`.<br>3. <strong>Resolving Conflict:</strong> While `arr[stack.top] < arr[i]`: We found the Next Greater for stack.top! <br>â¡ `pop()` and record result.<br><br><strong>Logic Ek Line Mein:</strong><br>Jab bhi koi BADA element aata hai, toh stack se sab CHOTE elements pop karke unka answer set kar do!",
                trap: "<strong>Leftovers:</strong><br>Elements remaining in stack have NO next greater element. Their result remains `-1` (default).",
                dryRun: [
                    "<strong>Init:</strong> arr=[4,5,2,10,8]. Result=[-1]*5. Stack=[]",
                    "<strong>i=0 (Val 4):</strong> Stack empty. Push 0. Stack=[0(4)].",
                    "<strong>i=1 (Val 5):</strong> 4 < 5? YES! <span style='color:var(--success)'>Found NGE for 4 is 5.</span> Pop 0. Stack=[]. Push 1. Stack=[1(5)].",
                    "<strong>i=2 (Val 2):</strong> 5 < 2? NO. Push 2. Stack=[1(5), 2(2)].",
                    "<strong>i=3 (Val 10):</strong> 2 < 10? YES! Pop 2 (NGE=10). 5 < 10? YES! Pop 1 (NGE=10). Push 3. Stack=[3(10)].",
                    "<strong>i=4 (Val 8):</strong> 10 < 8? NO. Push 4. Stack=[3(10), 4(8)].",
                    "<strong>End:</strong> Stack [3,4] have no NGE (-1)."
                ],
                codeTitle: "Python Solution (Better Variable Names)",
                code: `def nextGreaterElement(arr):
    n = len(arr)
    result = [-1] * n
    stack = []  # Indices store karenge
    
    for current_index in range(n):
        current_value = arr[current_index]
        
        # Jab tak stack mein chote elements hain
        while stack and arr[stack[-1]] < current_value:
            smaller_index = stack.pop()
            result[smaller_index] = current_value
        
        stack.append(current_index)
    
    return result`
            }
        },
        {
            id: "largest-rectangle-in-histogram",
            title: "Largest Rectangle in Histogram",
            leetcodeUrl: "https://leetcode.com/problems/largest-rectangle-in-histogram/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["The Boss Problem"],
            quiz: {
                description: "Find max rectangle area. What's the boss-level trick?",
                options: [
                    "Brute force all rectangles O(nÂ²)",
                    "Monotonic Increasing Stack with index tracking",
                    "Divide and Conquer O(n log n)",
                    "DP O(nÂ²)"
                ],
                correct: 1,
                explanation: "Monotonic Stack! Maintain increasing heights. When current < stack top, pop and calc area: height[top] * (current_idx - stack.peek() - 1)."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Wait kyun?</strong> Rectangle tabhi finalize hoga jab choti height aayegi (boundary)",
                    "âš¡ Increasing Stack: <code>while h < height[stack.top]</code> â†’ Pop!",
                    "ğŸ”„ Calc Area: <code>height[popped] * (current_i - new_top - 1)</code>",
                    "âœ… Push current index. Add Sentinel sets boundaries auto.",
                    "ğŸ’¡ -1 Sentinel stack start mein zaroor add karein for easy width calc"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Monotonic Increasing Stack:</strong><br>â€¢ Each element pushed ONCE<br>â€¢ Each element popped ONCE<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Stack stores indices<br>â€¢ Worst Case: Increasing order [1,2,3...N] -> Stack holds all N elements.<br><strong>Aux:</strong> <code>O(N)</code>",
                visual: `<div style="text-align:center;">
                    <div style="font-size:3rem; margin-bottom:10px;">ğŸ“Š ğŸ§±</div>
                    <div><strong>Visual: The Expansion Limits</strong></div>
                    <div style="font-size:0.9rem; color:var(--text-muted); margin-top:5px;">
                        For current bar <code>H</code>, find left-most and right-most boundary where height >= <code>H</code>.<br>
                        <strong>Pop Logic:</strong> When you see a smaller bar, the "tall" bars in stack can't expand right anymore. Process them!
                    </div>
                </div>`,
                crux: "<strong>Framework (Monotonic Increasing Stack):</strong><br>1. <strong>Indices</strong> in stack.<br>2. <strong>Conflict:</strong> `arr[i] < arr[stack.top]`.<br>3. <strong>Pop & Resolve:</strong><br>â€¢ Height = `arr[popped]`<br>â€¢ Width = `i - stack.peek() - 1` (Right - Left - 1)<br>â€¢ Area = Max(Area, H*W)",
                trap: "<strong>The Leftover Sentinel:</strong><br>Append `0` to end of array to force-pop all remaining elements in the stack at the end.",
                dryRun: [
                    "<strong>Init:</strong> heights=[2,1,5,6,2,3]. Append 0. Stack=[-1]. Ans=0.",
                    "<strong>i=0 (Val 2):</strong> Push 0. Stack=[-1, 0].",
                    "<strong>i=1 (Val 1):</strong> 1 < 2? YES. Pop 0 (Val 2). W = 1 - (-1) - 1 = 1. Area = 2*1 = 2.",
                    "<strong>i=2,3 (Val 5,6):</strong> Push. Stack=[-1, 1, 2, 3].",
                    "<strong>i=4 (Val 2):</strong> 2 < 6? YES. Pop 3 (Val 6). W = 4 - 2 - 1 = 1. Area = 6*1 = 6.",
                    "<strong>Cont:</strong> 2 < 5? YES. Pop 2 (Val 5). W = 4 - 1 - 1 = 2. Area = 5*2 = 10 (Max)."
                ],
                codeTitle: "Python Solution (Sentinel Trick)",
                code: `def largestRectangleArea(heights):
    heights.append(0)  # Sentinel to clear stack
    stack = [-1]      # Sentinel for left boundary
    ans = 0
    
    for i, h in enumerate(heights):
        while stack[-1] != -1 and h < heights[stack[-1]]:
            height = heights[stack.pop()]
            width = i - stack[-1] - 1
            ans = max(ans, height * width)
        stack.append(i)
    
    return ans`
            }
        },
        {
            id: "trapping-rain-water-stack",
            title: "Trapping Rain Water (Stack)",
            leetcodeUrl: "https://leetcode.com/problems/trapping-rain-water/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Horizontal Slicing"],
            quiz: {
                description: "Solve using stack. How?",
                options: [
                    "Monotonic decreasing stack",
                    "Store indices, calculate water when finding taller bar",
                    "Prefix max arrays",
                    "Greedy"
                ],
                correct: 1,
                explanation: "Stack stores indices (Decreasing). When current > top, we found a right wall. Pop top (Floor). New Top is Left Wall. Water = (min(L, R) - Floor) * Dist."
            },
            learn: {
                quickAlgo: [
                    "vol = 0; stack = []",
                    "for i, h in enumerate(height):",
                    "    while stack and height[stack[-1]] < h: # ğŸ¯ Bowl boundary found (Right Wall)",
                    "        mid = stack.pop()          # âš¡ Identify valley (Bottom)",
                    "        if not stack: break        # âŒ No Left Wall",
                    "        h_bound = min(h, height[stack[-1]]) - height[mid] # ğŸ”„ Water Height",
                    "        w_bound = i - stack[-1] - 1 # âœ… Water Width",
                    "        vol += h_bound * w_bound",
                    "    stack.append(i)",
                    "return vol",
                    "ğŸ’¡ Two Pointer approach is usually better (O(1) space), but this is good concept"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Monotonic Decreasing Stack:</strong><br>â€¢ Each bar pushed ONCE<br>â€¢ Each bar popped ONCE<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Stack stores indices<br>â€¢ Worst Case: Decreasing order.<br><strong>Aux:</strong> <code>O(N)</code>",
                visual: `<div style="text-align:center;">
                    <div style="font-size:3rem; margin-bottom:10px;">ğŸ¥£ ğŸ’§</div>
                    <div><strong>Visual: Horizontal Slicing</strong></div>
                    <div style="font-size:0.9rem; color:var(--text-muted); margin-top:5px;">
                        Imagine filling a bowl layer by layer.<br>
                        <strong>Floor:</strong> The popped short bar.<br>
                        <strong>Left Wall:</strong> The new top after pop.<br>
                        <strong>Right Wall:</strong> The current bar <code>i</code>.
                    </div>
                </div>`,
                crux: "<strong>Framework (The Bowl):</strong><br>1. <strong>Stack</strong> (Decreasing).<br>2. <strong>Conflict:</strong> `h[i] > h[stack.top]` (Right Wall found!).<br>3. <strong>Process Bowl:</strong><br>â€¢ `Floor` = pop().<br>â€¢ `height` = `min(Left, Right) - Floor`.<br>â€¢ `width` = `Right - Left - 1`.<br>â€¢ `Add water`!",
                trap: "<strong>The Flat Floor:</strong><br>If `stack` is empty after popping floor, it means there is no <strong>Left Wall</strong> to hold water. Break.",
                dryRun: [
                    "<strong>Init:</strong> height=[4,2,0,3,2,5]. Ans=0. Stack=[].",
                    "<strong>i=0,1,2 (Val 4,2,0):</strong> Decreasing. Push. Stack=[0(4), 1(2), 2(0)].",
                    "<strong>i=3 (Val 3):</strong> 3 > 0? YES.",
                    "â¡ Pop 0 (Floor). Left=2. Right=3. H=min(2,3)-0=2. W=3-1-1=1. Water+=2.",
                    "â¡ 3 > 2 (Next Top)? YES.",
                    "â¡ Pop 2 (Floor). Left=4. Right=3. H=min(4,3)-2=1. W=3-0-1=2. Water+=2. Total=4."
                ],
                codeTitle: "Python Solution (Horizontal Method)",
                code: `def trap(height):
    stack = []  # Indices
    water = 0
    
    for i, h in enumerate(height):
        while stack and h > height[stack[-1]]:
            floor_index = stack.pop()
            if not stack: break  # No left wall
            
            left_wall_index = stack[-1]
            width = i - left_wall_index - 1
            bounded_height = min(height[left_wall_index], h) - height[floor_index]
            
            water += width * bounded_height
            
        stack.append(i)
    return water`
            }
        },
        {
            id: "asteroid-collision",
            title: "Asteroid Collision",
            leetcodeUrl: "https://leetcode.com/problems/asteroid-collision/",
            difficulty: "Bonus",
            priority: "ğŸŸ¢",
            tags: ["Simulation"],
            quiz: {
                description: "Asteroids collide if moving towards each other. Pattern?",
                options: [
                    "Queue-based simulation",
                    "Stack: push right-moving, check collisions with left-moving",
                    "Greedy selection",
                    "DP"
                ],
                correct: 1,
                explanation: "Stack! Push Right (->). Check Left (<-) against stack."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Collision Logic?</strong> Only Right (â†’) and Left (â†) collide",
                    "âš¡ Stack: Stores stable/right-moving asteroids",
                    "ğŸ”„ Loop: <code>while stack.top > 0 and curr < 0:</code> â†’ Crush!",
                    "âœ… If <code>abs(curr) > abs(top)</code>, pop stack & continue. Else destroy curr.",
                    "ğŸ’¡ Loop end pe agar curr survive kiya, toh push"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Simulation:</strong><br>â€¢ Each asteroid processed once<br>â€¢ Stack push/pop = O(1) each<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Stack stores survivors<br>â€¢ Worst: No collisions (all same direction) = <code>O(N)</code>",
                visual: `<div style="text-align:center;">
                    <div style="font-size:3rem; margin-bottom:10px;">â˜„ï¸ ğŸ’¥ ğŸª¨</div>
                    <div><strong>Visual: The One-Way Street</strong></div>
                    <div style="font-size:0.9rem; color:var(--text-muted); margin-top:5px;">
                        Right-moving (+) asteroids are peaceful travellers waiting in the stack.<br>
                        Left-moving (-) asteroids are destroyers attempting to crash into them.
                    </div>
                </div>`,
                crux: "<strong>Framework (Collisions):</strong><br>1. <strong>Stack</strong> only stores Stable asteroids.<br>2. <strong>Conflict Cond:</strong> StackTop > 0 (Right) AND Current < 0 (Left).<br>3. <strong>Battle Logic:</strong><br>â€¢ Top < |Cur| â¡ ğŸ’¥ Top destroyed. Continue Checking.<br>â€¢ Top == |Cur| â¡ ğŸ’¥ Both destroyed.<br>â€¢ Top > |Cur| â¡ ğŸ’¥ Cur destroyed. Stop.",
                trap: "<strong>The Survivor:</strong><br>If a Left-Moving asteroid destroys ALL right-moving ones in the stack, it survives and settles in the stack itself.",
                dryRun: [
                    "<strong>Init:</strong> ast=[5, 10, -5]. Stack=[].",
                    "<strong>Val 5 (+):</strong> Push. Stack=[5].",
                    "<strong>Val 10 (+):</strong> Push. Stack=[5, 10].",
                    "<strong>Val -5 (-):</strong> Conflict with 10!",
                    "â¡ Compare 10 vs |-5|. 10 wins. -5 destroyed.",
                    "<strong>End:</strong> Stack=[5, 10]."
                ],
                codeTitle: "Python Solution (Battle Simulation)",
                code: `def asteroid_collision(asteroids):
    stack = []

    for current_asteroid in asteroids:
        # Collision sirf tab: current NEGATIVE (â†) aur stack top POSITIVE (â†’)
        while stack and current_asteroid < 0 < stack[-1]:
            
            # Case 1: Current BADA - top destroy, current zinda
            if abs(current_asteroid) > stack[-1]:
                stack.pop()
                continue  # Agle se bhi collision check karo (chain reaction!)

            # Case 2: EQUAL - dono destroy
            elif abs(current_asteroid) == stack[-1]:
                stack.pop()
                break  # Current bhi destroy, append mat karo

            # Case 3: Top BADA - current destroy
            else:
                break  # Current destroy, append mat karo

        # Yahan tab aayega jab:
        # 1. Current POSITIVE tha (while skip ho gaya)
        # 2. Current NEGATIVE tha BUT bach gaya (sabko uda diya)
        else:
            stack.append(current_asteroid)

    return stack`
            }
        }
    ]
}


// ========== data/dsa/trees.js ==========
// Trees data
// Extracted from data.js

const topic_trees = {
    id: "trees",
    title: "Tree Mastery",
    description: "Principal Engineer DSA â€¢ Day 5",
    color: "#16a34a",
    icon: "fas fa-tree",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ”„ LCA Problems", desc: "Find common ancestor â†’ Bubble-up DFS or BST property" },
            { label: "ğŸ“ˆ Path Sum/Max", desc: "Track global vs local â†’ Split (update global) + Flow (return)" },
            { label: "ğŸ—ï¸ Construction", desc: "Build from traversals â†’ Preorder=root, Inorder=split" },
            { label: "ğŸ“¦ Serialize", desc: "Tree â†” String â†’ Preorder + null markers 'N'" },
            { label: "ğŸ”¥ Multi-direction", desc: "Need to go UP? â†’ Convert to Graph (parent pointers)" },
            { label: "ğŸ¯ BST Property", desc: "Sorted tree â†’ left < root < right, use for O(H) search" }
        ],
        patterns: [
            { algo: "LCA (Binary Tree)", use: "Common ancestor", time: "O(N)", space: "O(H)", template: "if root==p or q: return root; combine L/R" },
            { algo: "LCA (BST)", use: "Common ancestor BST", time: "O(H)", space: "O(1)", template: "both < root: left; both > root: right; else: split!" },
            { algo: "Max Path Sum", use: "Any-to-any path", time: "O(N)", space: "O(H)", template: "global = split, return = flow" },
            { algo: "Serialize/Deserialize", use: "Tree to string", time: "O(N)", space: "O(N)", template: "preorder + 'N' markers + iterator" },
            { algo: "Construct Tree", use: "Pre+In to tree", time: "O(N)", space: "O(N)", template: "pre=root, inorder=split, use hashmap" },
            { algo: "Tree to Graph", use: "Burn tree, multi-dir", time: "O(N)", space: "O(N)", template: "Build adj list with parent links, BFS" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Tree Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "What type of tree problem?" â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    SEARCH    â”‚      â”‚  CONSTRUCT   â”‚      â”‚  PATH/SUM    â”‚
â”‚  LCA/Find    â”‚      â”‚  Build Tree  â”‚      â”‚   Problems   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚                     â”‚
       â–¼                     â–¼                     â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ BST?        â”‚      â”‚ Pre + In?   â”‚      â”‚ Global vs   â”‚
  â”‚ â†’ O(H) walk â”‚      â”‚ â†’ Pre=root  â”‚      â”‚ Local!      â”‚
  â”‚             â”‚      â”‚   In=split  â”‚      â”‚             â”‚
  â”‚ Binary?     â”‚      â”‚             â”‚      â”‚ Split: L+R  â”‚
  â”‚ â†’ Bubble-up â”‚      â”‚ Serialize?  â”‚      â”‚ Flow: max() â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ â†’ Pre + 'N' â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

       "Need to go UP the tree?"
              â”‚
              â–¼
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ Convert to Graph! â”‚
      â”‚ Parent pointers   â”‚
      â”‚ + BFS from start  â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Tree Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ LCA Binary Tree (Bubble-up)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def lowestCommonAncestor(root, p, q):
    if not root or root == p or root == q:
        return root
    left = lowestCommonAncestor(root.left, p, q)
    right = lowestCommonAncestor(root.right, p, q)
    if left and right: return root  # I am LCA
    return left if left else right
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Max Path Sum (Global vs Local)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def maxPathSum(root):
    max_sum = float('-inf')
    def dfs(node):
        nonlocal max_sum
        if not node: return 0
        left = max(dfs(node.left), 0)   # Clamp negatives!
        right = max(dfs(node.right), 0)
        # SPLIT: Update global (L + root + R)
        max_sum = max(max_sum, node.val + left + right)
        # FLOW: Return to parent (max path through me)
        return node.val + max(left, right)
    dfs(root)
    return max_sum
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Serialize/Deserialize
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def serialize(root):
    vals = []
    def dfs(node):
        if not node: vals.append("N"); return
        vals.append(str(node.val))
        dfs(node.left); dfs(node.right)
    dfs(root)
    return ",".join(vals)

def deserialize(data):
    vals = iter(data.split(","))
    def build():
        val = next(vals)
        if val == "N": return None
        node = TreeNode(int(val))
        node.left, node.right = build(), build()
        return node
    return build()
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Tree to Graph (Burn Tree)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def burnTree(root, start):
    graph = defaultdict(list)
    def buildGraph(node):
        if not node: return
        if node.left:
            graph[node.val].append(node.left.val)
            graph[node.left.val].append(node.val)
            buildGraph(node.left)
        if node.right:
            graph[node.val].append(node.right.val)
            graph[node.right.val].append(node.val)
            buildGraph(node.right)
    buildGraph(root)
    # BFS from start
    return bfs_from(graph, start)
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ” Base case!", desc: "<code>if not root: return None/0</code> â€” Always first!" },
            { label: "ğŸŒ³ Height vs Nodes!", desc: "Space = O(H) for recursion. H = log N (balanced), H = N (skewed)" },
            { label: "ğŸ“ˆ Clamp negatives!", desc: "Max path: <code>left = max(dfs(left), 0)</code> â€” Ignore negative subtrees" },
            { label: "ğŸ”„ Global vs Local!", desc: "Split updates global (L+R), Flow returns to parent (max one branch)" },
            { label: "ğŸ“‹ Use Iterator!", desc: "Deserialize: <code>iter()</code> not index â€” avoids O(N) slicing" },
            { label: "â†•ï¸ Need parent?", desc: "Tree only goes down. For UP: convert to graph or track parent" }
        ]
    },
    questions: [
        {
            id: "lca-binary-tree",
            title: "LCA in Binary Tree",
            leetcodeUrl: "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["DFS Pattern"],
            quiz: {
                description: "Find LCA in general binary tree. Best approach?",
                options: [
                    "Find paths to both, compare",
                    "Recursive: if root is p or q, return root. Combine left/right results",
                    "Level-order",
                    "Iterative"
                ],
                correct: 1,
                explanation: "Recursive DFS! Base: if root == p or q or null, return root. Recurse left/right. If both return node, I am LCA. If one, return that."
            },
            learn: {
                quickAlgo: [
                    "if not root or root == p or root == q: # ğŸ¯ Base Case: Found target or None",
                    "    return root",
                    "left = dfs(root.left, p, q)        # âš¡ Search Left Subtree",
                    "right = dfs(root.right, p, q)      # âš¡ Search Right Subtree",
                    "if left and right:                 # âœ… Both sides returned non-null?",
                    "    return root                    #    -> Current 'root' is the Split Point (LCA)",
                    "return left if left else right     # ğŸ”„ Propagate found node upwards"
                ],
                metrics: { time: "O(N)", space: "O(H)" },
                timeExplainer: "<strong>DFS Traversal:</strong><br>â€¢ Visit every node once<br>â€¢ Recurse Left and Right<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Recursion Stack depth = Tree Height<br>â€¢ Skewed Tree: <code>O(N)</code><br>â€¢ Balanced Tree: <code>O(log N)</code><br><br><strong>Result:</strong> <code>O(H)</code>",
                visual: "<span><strong>Visual: The Meeting Point</strong><br>Paths merge at the LCA.</span>",
                crux: "<strong>Bubbling Up:</strong><br>1. If I am P or Q, return Me.<br>2. If Left & Right both return something, I am LCA.<br>3. Else return non-null child.",
                trap: "<strong>Missing Node:</strong> Standard algo assumes both nodes exist.",
                dryRun: ["1. Found P in Left. Return P.", "2. Found Q in Right. Return Q.", "3. Root receives P and Q. Returns Root."],
                codeTitle: "Python Solution",
                code: `def lowestCommonAncestor(root, p, q):
if not root or root == p or root == q: return root
left = lowestCommonAncestor(root.left, p, q)
right = lowestCommonAncestor(root.right, p, q)
if left and right: return root
return left if left else right`
            }
        },
        {
            id: "serialize-deserialize-binary-tree",
            title: "Serialize & Deserialize",
            leetcodeUrl: "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["System Design Core"],
            quiz: {
                description: "Convert tree to string and back. Best traversal?",
                options: ["Inorder", "Preorder with null markers", "Postorder", "Level-order"],
                correct: 1,
                explanation: "Preorder + null markers! Serialize: '1,2,N,N,3'. Deserialize: Iterator. If 'N' return None. Else create node, recurse."
            },
            learn: {
                quickAlgo: [
                    "vals = []",
                    "def encode(node):                  # ğŸ¯ Preorder Traversal (Root->Left->Right)",
                    "    if not node: vals.append('#')  # âš¡ Mark nulls to keep structure",
                    "    else:",
                    "        vals.append(str(node.val))",
                    "        encode(node.left); encode(node.right)",
                    "def decode(iter_vals):             # ğŸ”„ Reconstruct matches Preorder",
                    "    val = next(iter_vals)",
                    "    if val == '#': return None     # âœ… Null marker -> Stop branch",
                    "    node = TreeNode(int(val))",
                    "    node.left = decode(iter_vals)  # ğŸ’¡ Next val goes to left child",
                    "    node.right = decode(iter_vals)",
                    "    return node"
                ],
                metrics: { time: "O(N)", space: "O(H)" },
                timeExplainer: "<strong>Preorder Traversal:</strong><br>â€¢ Visit all nodes to serialize: <code>O(N)</code><br>â€¢ Deserialize visits all nodes: <code>O(N)</code><br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Recursion Stack: <code>O(H)</code><br>â€¢ Output String/Array: <code>O(N)</code><br><br><strong>Result:</strong> <code>O(N)</code>",
                visual: "<span><strong>Visual: Flat Tree</strong><br>Record Nulls to preserve structure.</span>",
                crux: "<strong>Preorder (Root-Left-Right):</strong><br>Ser: `vals.append(str(node.val))` or 'N'.<br>Deser: `next(iter)`. If 'N', return None.",
                trap: "<strong>Global Index:</strong> Don't use a global integer index. Use an <strong>Iterator</strong>.",
                dryRun: ["Ser: [1, 2, N, N, 3, N, N].", "Deser: 1 -> Left(2) -> Left(N), Right(N). 1 -> Right(3)."],
                codeTitle: "Python Solution",
                code: `class Codec:
def serialize(self, root):
    vals = []
    def dfs(node):
        if not node: vals.append("N"); return
        vals.append(str(node.val))
        dfs(node.left)
        dfs(node.right)
    dfs(root)
    return ",".join(vals)

def deserialize(self, data):
    vals = iter(data.split(","))
    def build():
        val = next(vals)
        if val == "N": return None
        node = TreeNode(int(val))
        node.left = build()
        node.right = build()
        return node
    return build()`
            }
        },
        {
            id: "binary-tree-maximum-path-sum",
            title: "Maximum Path Sum",
            leetcodeUrl: "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Global vs Local"],
            quiz: {
                description: "Path can start/end anywhere. What's the trick?",
                options: ["Try all paths", "DFS: track global max, return single-path max upward", "DP", "BFS"],
                correct: 1,
                explanation: "Global vs Local! At each node: global_max = max(global_max, node + left + right). Return upward: node + max(left, right)."
            },
            learn: {
                quickAlgo: [
                    "self.global_max = float('-inf')",
                    "def dfs(node):",
                    "    if not node: return 0",
                    "    L = max(dfs(node.left), 0)     # âš¡ Clamp negatives to 0 (Don't extend bad path)",
                    "    R = max(dfs(node.right), 0)",
                    "    self.global_max = max(self.global_max, node.val + L + R) # âœ… Split point potential",
                    "    return node.val + max(L, R)    # ğŸ”„ Return max SINGLE branch to parent"
                ],
                metrics: { time: "O(N)", space: "O(H)" },
                timeExplainer: "<strong>DFS Postorder:</strong><br>â€¢ Compute max path for each node<br>â€¢ Visit every node exactly once<br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Recursion Stack depth = Tree Height<br>â€¢ Worst case (Skewed): <code>O(N)</code><br><br><strong>Result:</strong> <code>O(H)</code>",
                visual: "<span><strong>Visual: The Inverted V</strong><br>Split (Arch) vs Flow (Straight).</span>",
                crux: "<strong>1. Split:</strong> `Root + Left + Right`. Update Global Max.<br><strong>2. Flow:</strong> `Root + max(Left, Right)`. Return to parent.<br><strong>3. Clamp:</strong> `max(gain, 0)`.",
                trap: "<strong>Negative Gain:</strong> If subtree sum is negative, ignore it (clamp to 0).",
                dryRun: ["Left gives 15. Right gives 7. Root is 20.", "Global update: 15+7+20 = 42.", "Return: 20 + 15 = 35."],
                codeTitle: "Python Solution",
                code: `class Solution:
def maxPathSum(self, root):
    self.max_sum = float('-inf')
    def get_max(node):
        if not node: return 0
        left = max(get_max(node.left), 0)
        right = max(get_max(node.right), 0)
        self.max_sum = max(self.max_sum, node.val + left + right)
        return node.val + max(left, right)
    get_max(root)
    return self.max_sum`
            }
        },
        {
            id: "construct-binary-tree-preorder-inorder",
            title: "Construct Tree (Pre+In)",
            leetcodeUrl: "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Index Mastery"],
            quiz: {
                description: "Rebuild tree from two traversals. Key insight?",
                options: ["Preorder gives roots, Inorder gives split", "Hash Inorder", "Stack", "Level order"],
                correct: 0,
                explanation: "Preorder[0] is Root. Find Root in Inorder. Left of it is LeftSubtree, Right is RightSubtree."
            },
            learn: {
                quickAlgo: [
                    "in_map = {val: idx for idx, val in enumerate(inorder)} # ğŸ¯ O(1) lookup for root in inorder",
                    "pre_idx = 0                                            # âš¡ Global index for preorder (current root)",
                    "def build(in_start, in_end):",
                    "    nonlocal pre_idx",
                    "    if in_start > in_end: return None                 # âœ… Base Case: No elements left",
                    "    root_val = preorder[pre_idx]",
                    "    root = TreeNode(root_val)",
                    "    pre_idx += 1",
                    "    mid = in_map[root_val]                             # ğŸ”„ Find root in inorder to split",
                    "    root.left = build(in_start, mid - 1)               # ğŸ’¡ Build left subtree",
                    "    root.right = build(mid + 1, in_end)              # ğŸ’¡ Build right subtree",
                    "    return root"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                timeExplainer: "<strong>Time Breakdown:</strong><br>â€¢ HashMap construction: <code>O(N)</code><br>â€¢ Recursive Tree Building: <code>O(N)</code><br><br><strong>Total:</strong> <code>O(N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ HashMap stores N indices<br>â€¢ Recursion Stack: <code>O(H)</code><br><br><strong>Total:</strong> <code>O(N)</code>",
                visual: "<span><strong>Visual: The Knife</strong><br>Root (from Pre) slices Inorder into Left/Right.</span>",
                crux: "1. `root = pre.next()`<br>2. `mid = map[root]`<br>3. `size = mid - in_start`<br>4. Recurse.",
                trap: "<strong>Slicing:</strong> `pre[1:]` is O(N). Use indices or iterator!",
                dryRun: ["Pre: [3,9,20]. In: [9,3,20].", "Root=3. Mid=1. LeftSize=1.", "Left: Build([9]). Right: Build([20])."],
                codeTitle: "Python Solution",
                code: `def buildTree(preorder, inorder):
in_map = {v: i for i, v in enumerate(inorder)}
pre_iter = iter(preorder)

def build(l, r):
    if l > r: return None
    val = next(pre_iter)
    root = TreeNode(val)
    mid = in_map[val]
    root.left = build(l, mid - 1)
    root.right = build(mid + 1, r)
    return root
    
return build(0, len(inorder) - 1)`
            }
        },
        {
            id: "vertical-order-traversal",
            title: "Vertical Order Traversal",
            leetcodeUrl: "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Coordinates"],
            quiz: {
                description: "Print nodes by vertical column. Data structure?",
                options: ["BFS only", "DFS with (row, col) + Sorting", "Inorder", "Level-order"],
                correct: 1,
                explanation: "Track (row, col). Store in `Map[col]`. Sort by Col, then Row, then Val."
            },
            learn: {
                quickAlgo: [
                    "q = deque([root]); res = []",
                    "while q:",
                    "    level = []",
                    "    for _ in range(len(q)):        # ğŸ¯ Freeze size logic for Level Separation",
                    "        node = q.popleft()",
                    "        if not node: continue",
                    "        level.append(node.val)",
                    "        q.append(node.left)        # âš¡ Queue children for NEXT level",
                    "        q.append(node.right)",
                    "    if level: res.append(level)    # âœ… Add level if not empty (handles null children)"
                ],
                metrics: { time: "O(N log N)", space: "O(N)" },
                timeExplainer: "<strong>BFS + Sorting:</strong><br>â€¢ BFS Traversal: <code>O(N)</code><br>â€¢ Sorting nodes in same column: <code>O(N log N)</code><br><br><strong>Total:</strong> <code>O(N log N)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Map stores all nodes<br>â€¢ Queue for BFS<br><br><strong>Result:</strong> <code>O(N)</code>",
                visual: "<span><strong>Visual: Grid Overlay</strong><br>Left: (r+1, c-1). Right: (r+1, c+1).</span>",
                crux: "<strong>Grouping + Sorting:</strong><br>1. BFS/DFS to collect `(c, r, val)`.<br>2. Sort.",
                trap: "<strong>Shadow Nodes:</strong> Nodes can land on same (r, c). Must sort by value.",
                dryRun: ["(0,0,1)", "(-1,1,2), (1,1,3)", "Sort -> Col -1: [2], Col 0: [1], Col 1: [3]"],
                codeTitle: "Python Solution",
                code: `def verticalTraversal(root):
cols = defaultdict(list)
q = deque([(root, 0, 0)])
min_c, max_c = 0, 0
while q:
    node, r, c = q.popleft()
    if node:
        cols[c].append((r, node.val))
        min_c = min(min_c, c)
        max_c = max(max_c, c)
        q.append((node.left, r+1, c-1))
        q.append((node.right, r+1, c+1))
res = []
for c in range(min_c, max_c + 1):
    cols[c].sort(key=lambda x: (x[0], x[1]))
    res.append([x[1] for x in cols[c]])
return res`
            }
        },
        {
            id: "lca-bst",
            title: "LCA in BST",
            leetcodeUrl: "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¢",
            tags: ["BST Property"],
            quiz: {
                description: "Find LCA in BST. Optimization?",
                options: ["Same as Binary Tree (DFS)", "Use BST Property: if split, that's LCA", "Inorder Traversal", "BFS"],
                correct: 1,
                explanation: "Use BST Property! If both p and q < root, go Left. If both > root, go Right. The first node where they SPLIT (one small, one big) is the LCA. O(H) time, O(1) space (iterative)."
            },
            learn: {
                quickAlgo: [
                    "def maxDepth(node):",
                    "    if not node: return 0              # ğŸ¯ Base Case: Empty tree has depth 0",
                    "    left_depth = maxDepth(node.left)   # âš¡ Recurse Left",
                    "    right_depth = maxDepth(node.right) # âš¡ Recurse Right",
                    "    return 1 + max(left_depth, right_depth) # âœ… My Depth = 1 (Me) + Max(Children)"
                ],
                metrics: { time: "O(H)", space: "O(1)" },
                code: `def lowestCommonAncestor(root, p, q):
while root:
    if p.val < root.val and q.val < root.val:
        root = root.left
    elif p.val > root.val and q.val > root.val:
        root = root.right
    else:
        return root`
            }
        },
        {
            id: "largest-bst-in-bt",
            title: "Largest BST in Binary Tree",
            leetcodeUrl: "https://practice.geeksforgeeks.org/problems/largest-bst/1",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Postorder"],
            quiz: {
                description: "Find size of largest BST subtree. Return type?",
                options: ["Boolean only", "Size only", "Generic Tuple (min, max, size, isBST)", "Void"],
                correct: 2,
                explanation: "Postorder Tuple! Each node needs from children: (Min_Val, Max_Val, Size, Is_BST). If Left is BST & Right is BST & MaxLeft < Node < MinRight -> Current is BST."
            },
            learn: {
                quickAlgo: [
                    "def validate(node, min_val, max_val):",
                    "    if not node: return True           # ğŸ¯ Base Case: Empty tree is a valid BST",
                    "    if not (min_val < node.val < max_val): # âš¡ Check current node's value against range",
                    "        return False",
                    "    # âœ… Recursively check left and right subtrees with updated ranges",
                    "    return validate(node.left, min_val, node.val) and \\",
                    "           validate(node.right, node.val, max_val)"
                ],
                metrics: { time: "O(N)", space: "O(H)" },
                code: `def largestBST(root):
# Return: (min_val, max_val, size)
def postorder(node):
    if not node: return (float('inf'), float('-inf'), 0)
    
    l_min, l_max, l_size = postorder(node.left)
    r_min, r_max, r_size = postorder(node.right)
    
    if l_max < node.val < r_min:
        return (min(l_min, node.val), max(r_max, node.val), l_size + r_size + 1)
    
    return (float('-inf'), float('inf'), max(l_size, r_size))
    
return postorder(root)[2]`
            }
        },
        {
            id: "burn-binary-tree",
            title: "Burn a Binary Tree",
            leetcodeUrl: "https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Graph on Tree"],
            quiz: {
                description: "Time to burn tree from target node. Approach?",
                options: ["Standard DFS", "Convert to Graph (Parent Pointers) + BFS", "Inorder", "DP"],
                correct: 1,
                explanation: "Convert to Graph! Tree nodes only point down. To burn UP, we need Parent pointers (or Adj List). Then run BFS from start node to find max distance."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Graph conversion kyun?</strong> Tree pointers only down jaate hain, burn UP bhi hota hai",
                    "âš¡ Map: <code>parent_map[node] = parent</code> â€” backward edge create karo",
                    "ğŸ”„ BFS: Start from Target node, spread radially (Up, Left, Right)",
                    "âœ… Max Distance: Level 0 se start karo, last reachable node time dega",
                    "ğŸ’¡ Visited Set zaroori hai cycle/revisit avoid karne ke liye"
                ],
                metrics: { time: "O(N)", space: "O(N)" },
                code: `def amountOfTime(root, start):
graph = defaultdict(list)
def dfs(node):
    if not node: return
    if node.left:
        graph[node.val].append(node.left.val)
        graph[node.left.val].append(node.val)
        dfs(node.left)
    if node.right:
        graph[node.val].append(node.right.val)
        graph[node.right.val].append(node.val)
        dfs(node.right)
dfs(root)

q = deque([(start, 0)])
visited = {start}
max_time = 0
while q:
    node, time = q.popleft()
    max_time = max(max_time, time)
    for nei in graph[node]:
        if nei not in visited:
            visited.add(nei)
            q.append((nei, time + 1))
return max_time`
            }
        }
    ]
}


// ========== data/dsa/graphs.js ==========
// Graphs data
// Extracted from data.js

const topic_graphs = {
    id: "graphs",
    title: "Graph Mastery",
    description: "Principal Engineer DSA â€¢ Day 6",
    color: "#c026d3",
    icon: "fas fa-project-diagram",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ›¤ï¸ Shortest Path (Unweighted)", desc: "BFS (Level by level). O(V+E)" },
            { label: "âš–ï¸ Shortest Path (Weighted)", desc: "Dijkstra (Priority Queue). No negative edges!" },
            { label: "ğŸ“‹ Dependencies", desc: "Topological Sort (Kahn's BFS or DFS)" },
            { label: "ğŸ”— Connectivity", desc: "Union-Find (DSU). O(Î±(N)) per op" },
            { label: "ğŸŒ³ MST", desc: "Kruskal (sort edges + UF) or Prim (min-heap)" },
            { label: "ğŸ”„ Cycle Detection", desc: "DFS back-edge or Union-Find" }
        ],
        patterns: [
            { algo: "BFS", use: "Unweighted shortest path / level order", time: "O(V+E)", space: "O(V)", template: "queue + visited set, pop front" },
            { algo: "DFS", use: "Connectivity, topological sort", time: "O(V+E)", space: "O(V)", template: "recursion/stack + visited" },
            { algo: "Dijkstra", use: "Weighted shortest path", time: "O((V+E) log V)", space: "O(V)", template: "min-heap (dist, node), relax edges" },
            { algo: "Kruskal", use: "Minimum Spanning Tree", time: "O(E log E)", space: "O(V)", template: "sort edges + Union-Find" },
            { algo: "Unionâ€‘Find", use: "Cycle detection / DSU problems", time: "â‰ˆ O(Î±(N)) per op", space: "O(N)", template: "find(x) with path compression, union by rank" },
            { algo: "Topo Sort", use: "Course schedule, build order", time: "O(V+E)", space: "O(V)", template: "Kahn's BFS: indegree=0 first" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Graph Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "What's the graph problem?"  â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SHORTEST    â”‚      â”‚ CONNECTIVITY â”‚      â”‚ DEPENDENCY/  â”‚
â”‚    PATH      â”‚      â”‚  / GROUPING  â”‚      â”‚   ORDERING   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚                     â”‚
       â–¼                     â–¼                     â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ Weighted?     â”‚    â”‚ Components?   â”‚    â”‚ Topological   â”‚
 â”‚ â†’ DIJKSTRA    â”‚    â”‚ â†’ DFS/BFS     â”‚    â”‚ Sort!         â”‚
 â”‚               â”‚    â”‚ â†’ Union-Find  â”‚    â”‚               â”‚
 â”‚ Unweighted?   â”‚    â”‚               â”‚    â”‚ Kahn's BFS:   â”‚
 â”‚ â†’ BFS         â”‚    â”‚ MST?          â”‚    â”‚ indegree = 0  â”‚
 â”‚               â”‚    â”‚ â†’ Kruskal     â”‚    â”‚ first         â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ğŸ”‘ VISITED TRACKING:                                    â”‚
  â”‚ â€¢ BFS: Mark visited WHEN ADDING to queue (not pop)     â”‚
  â”‚ â€¢ DFS: Mark visited at START of visit                  â”‚
  â”‚ â€¢ This prevents duplicates and saves time!              â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Graph Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ BFS (Shortest Path Unweighted)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
from collections import deque
def bfs(graph, start):
    visited = {start}
    queue = deque([(start, 0)])  # (node, distance)
    while queue:
        node, dist = queue.popleft()
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)  # Mark BEFORE push!
                queue.append((neighbor, dist + 1))
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Dijkstra (Weighted Shortest Path)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
import heapq
def dijkstra(graph, start):
    dist = {start: 0}
    heap = [(0, start)]
    while heap:
        d, node = heapq.heappop(heap)
        if d > dist.get(node, float('inf')): continue
        for neighbor, weight in graph[node]:
            new_dist = d + weight
            if new_dist < dist.get(neighbor, float('inf')):
                dist[neighbor] = new_dist
                heapq.heappush(heap, (new_dist, neighbor))
    return dist
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Union-Find (DSU)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
class UnionFind:
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [0] * n
    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])  # Path compression
        return self.parent[x]
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py: return False  # Already connected
        if self.rank[px] < self.rank[py]: px, py = py, px
        self.parent[py] = px
        if self.rank[px] == self.rank[py]: self.rank[px] += 1
        return True
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Topological Sort (Kahn's BFS)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
from collections import deque
def topoSort(numCourses, prerequisites):
    graph = defaultdict(list)
    indegree = [0] * numCourses
    for course, prereq in prerequisites:
        graph[prereq].append(course)
        indegree[course] += 1
    queue = deque([i for i in range(numCourses) if indegree[i] == 0])
    order = []
    while queue:
        node = queue.popleft()
        order.append(node)
        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                queue.append(neighbor)
    return order if len(order) == numCourses else []  # [] = cycle!
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ›‘ Mark visited EARLY!", desc: "BFS: Add to visited BEFORE pushing to queue, not when popping" },
            { label: "âš–ï¸ No negative edges!", desc: "Dijkstra fails with negative edges. Use Bellman-Ford instead" },
            { label: "ğŸ”„ Cycle = no topo sort!", desc: "If output length < V, there's a cycle" },
            { label: "ğŸ“Š Build graph first!", desc: "Convert edge list to adjacency list before traversal" },
            { label: "ğŸ”— Path compression!", desc: "Union-Find: Always use <code>find()</code> to update parent" },
            { label: "ğŸ“ Multi-source BFS!", desc: "Rotten oranges: Add ALL sources to queue initially" }
        ]
    },
    questions: [
        {
            id: "rotting-oranges",
            title: "Rotten Oranges",
            leetcodeUrl: "https://leetcode.com/problems/rotting-oranges/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Multi-Source BFS", "Matrix"],
            quiz: {
                description: "Simulate rotting. Why not DFS?",
                options: ["DFS is too slow", "DFS checks one path at a time (Simultaneous vs Sequential)", "DFS stack overflow", "DFS is hard to implement"],
                correct: 1,
                explanation: "The core problem is **SIMULTANEOUS** expansion. All rotten oranges affect neighbors at `t=1`. DFS goes deep on one orange (sequential) effectively calculating 'distance from ONE root', which is wrong here. We need 'min distance from ANY root' -> BFS."
            },
            learn: {
                quickAlgo: [
                    "q = deque(); fresh = 0",
                    "for r, c in grid:                  # ğŸ¯ Multi-source BFS: Add ALL rotten",
                    "    if grid[r][c] == 2: q.append((r,c,0))",
                    "    if grid[r][c] == 1: fresh += 1",
                    "while q:",
                    "    r, c, time = q.popleft()",
                    "    for dr, dc in dirs:            # âš¡ 4-directional spread",
                    "        nr, nc = r+dr, c+dc",
                    "        if valid(nr,nc) and grid[nr][nc] == 1:",
                    "            grid[nr][nc] = 2; fresh -= 1",
                    "            q.append((nr, nc, time+1)) # ğŸ”„ Level = Time",
                    "return time if fresh == 0 else -1  # âœ… Check all rotted"
                ],
                metrics: { time: "O(NÃ—M)", space: "O(NÃ—M)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(NÃ—M)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <p><strong>Compare Approaches:</strong></p>
                        <table style="width:100%; border-collapse: collapse; margin-top:10px;">
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1);">
                                <th style="text-align:left; padding:10px;">Approach</th>
                                <th style="text-align:left; padding:10px;">Complexity</th>
                                <th style="text-align:left; padding:10px;">Outcome</th>
                            </tr>
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1); background:rgba(239, 68, 68, 0.1);">
                                <td style="padding:10px;"><strong>Naive DFS</strong></td>
                                <td style="padding:10px;">O((NM)Â²)</td>
                                <td style="padding:10px;">âŒ TLE / Wrong Logic (Sequential)</td>
                            </tr>
                            <tr style="background:rgba(16, 185, 129, 0.1);">
                                <td style="padding:10px;"><strong>Multi-Source BFS</strong></td>
                                <td style="padding:10px;">O(NÃ—M)</td>
                                <td style="padding:10px;">âœ… Optimal (Simultaneous)</td>
                            </tr>
                        </table>
                        
                        <div style="margin-top:15px;">
                            <strong>Why O(NÃ—M)?</strong>
                            <ul style="line-height:1.6; color:#e2e8f0;">
                                <li>Each cell is added to Queue <strong>AT MOST ONCE</strong>.</li>
                                <li>Each cell is processed constant times (4 neighbors).</li>
                                <li>Total = NÃ—M cells Ã— O(1) operations.</li>
                            </ul>
                        </div>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(NÃ—M)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <ul style="line-height:2;">
                            <li><strong>Queue Size:</strong> In worst case (e.g., all rotten initially), queue holds O(NÃ—M) cells.</li>
                            <li><strong>Grid Modified In-Place:</strong> No extra <code>visited</code> array needed if we modify grid (1 â†’ 2).</li>
                        </ul>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸŒŠ Simultaneous Expansion (The Wave)</h4>
                    <div style="display:flex; flex-wrap:wrap; gap:20px; justify-content: center; margin: 20px 0;">
                        
                        <!-- T=0 -->
                        <div>
                            <div style="text-align:center; margin-bottom:5px; font-size:0.9rem; color:#94a3b8;">T = 0 (Init)</div>
                            <div style="display:grid; grid-template-columns:repeat(3, 30px); gap:2px; background:#334155; padding:2px; border-radius:4px;">
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                            </div>
                            <div style="text-align:center; font-size:0.8rem; color:#64748b; margin-top:5px;">Q: [(0,0)]</div>
                        </div>

                        <!-- Arrow -->
                        <div style="display:flex; align-items:center; color:#64748b;">â</div>

                        <!-- T=1 -->
                        <div>
                            <div style="text-align:center; margin-bottom:5px; font-size:0.9rem; color:#94a3b8;">T = 1 (Wave 1)</div>
                            <div style="display:grid; grid-template-columns:repeat(3, 30px); gap:2px; background:#334155; padding:2px; border-radius:4px;">
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold; border: 1px solid #ef4444;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold; border: 1px solid #ef4444;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                            </div>
                            <div style="text-align:center; font-size:0.8rem; color:#64748b; margin-top:5px;">Fresh: 6 -> 4</div>
                        </div>

                        <!-- Arrow -->
                        <div style="display:flex; align-items:center; color:#64748b;">â</div>

                        <!-- T=2 -->
                        <div>
                            <div style="text-align:center; margin-bottom:5px; font-size:0.9rem; color:#94a3b8;">T = 2 (Wave 2)</div>
                             <div style="display:grid; grid-template-columns:repeat(3, 30px); gap:2px; background:#334155; padding:2px; border-radius:4px;">
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold; border: 1px solid #ef4444;">2</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold; border: 1px solid #ef4444;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#64748b;">0</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#f87171; font-weight:bold; border: 1px solid #ef4444;">2</div>
                                <div style="background:#1e293b; height:30px; display:flex; align-items:center; justify-content:center; color:#4ade80;">1</div>
                            </div>
                            <div style="text-align:center; font-size:0.8rem; color:#64748b; margin-top:5px;">Fresh: 4 -> 1</div>
                        </div>

                    </div>
                    
                    <div style="background:#0f172a; padding:15px; border-radius:8px; margin-top:10px;">
                        <ul style="margin:0; padding-left:20px; color:#cbd5e1; font-size:0.9rem;">
                            <li><strong style="color:#f87171;">2</strong> = Rotten (Sources)</li>
                            <li><strong style="color:#4ade80;">1</strong> = Fresh (Targets)</li>
                            <li><span style="border: 1px solid #ef4444; padding:0 4px; border-radius:2px;">Box</span> = Newly Rotten this minute</li>
                        </ul>
                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: "Process Level = 1 Minute"</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Mental Model:</strong> Think of this as a <strong>Physical Simulation</strong>.
                            <br>Every tick of the clock, infection spreads 1 unit distance in all directions.
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px; border-left:4px solid #ef4444;">
                            <strong>Why processing by size(Q) matters:</strong>
                            <br>We need to know when "Minute 1" ends and "Minute 2" begins.
                            <br><code>for _ in range(len(q)):</code> ensures we only process the CURRENT batch, not the newly infected ones!
                        </div>
                    </div>
                    
                    <h5 style="color:#a78bfa; margin-top:20px;">ğŸ•¸ï¸ Pattern: Multi-Source BFS</h5>
                    <p style="color:#cbd5e1; font-style:italic;">Why are these problems actually the same?</p>
                    <ul style="line-height:2;">
                        <li>ğŸ”¥ <strong>Walls and Gates</strong>: Replace "Rotten" with "Gate". Find distance to nearest Gate. SAME LOGIC.</li>
                        <li>ğŸŒŠ <strong>01 Matrix</strong>: Replace "Rotten" with "0". Find distance to nearest 0. SAME LOGIC.</li>
                        <li>ğŸ—ºï¸ <strong>Shortest Bridge</strong>: Expand from Island A (Multi-source) until you hit Island B.</li>
                    </ul>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Deep Traps</h4>
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#f87171;">1. The "Last Minute" Bug</strong><br>
                            If you increment <code>time</code> at the start of the loop, you might count a minute even if NO fresh oranges rot.<br>
                            <span style="color:#cbd5e1; font-size:0.9em;">Fix: Check <code>if fresh > 0</code> or return <code>time - 1</code> if Q not empty.</span>
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#fbbf24;">2. Isolated Fresh Orange</strong><br>
                            A fresh orange surrounded by 0s can NEVER be reached.<br>
                            <span style="color:#cbd5e1; font-size:0.9em;">Fix: Check <code>if fresh_count == 0</code> at the very end.</span>
                        </div>
                        <div style="background:rgba(139, 92, 246, 0.1); padding:15px; border-radius:8px; grid-column: span 2;">
                            <strong style="color:#a78bfa;">3. Modifying Queue Size during Loop</strong><br>
                            Classic Python trap! <code>for _ in range(len(que))</code> evaluates <code>len</code> ONCE.
                            If you used a dynamic <code>while</code> loop without fixing the range size, you'd mix levels!
                        </div>
                    </div>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: [[2,1,1],[1,1,0],[0,1,1]]</h4>
                    <div style="background:#0f172a; padding:20px; border-radius:12px; font-family:'Consolas', monospace;">
                        <pre style="color:#e2e8f0; margin:0; line-height:1.8;">
<span style="color:#f59e0b;">Init:</span> Q=[(0,0)], fresh=6, time=0

<span style="color:#f59e0b;">Loop 1 (Size=1):</span>
  â€¢ Pop (0,0). Neighbors: (0,1), (1,0)
  â€¢ Rot (0,1) & (1,0). fresh=4.
  â€¢ Q now has [(0,1), (1,0)] (New batch!)
  â€¢ time â†’ 1

<span style="color:#f59e0b;">Loop 2 (Size=2):</span>
  â€¢ Pop (0,1). Rot neighbors...
  â€¢ Pop (1,0). Rot neighbors...
  â€¢ time â†’ 2

<span style="color:#f59e0b;">End:</span> Q empty? No. Fresh > 0? No. 
Break! Return time.
                        </pre>
                    </div>
                `,
                codeTitle: "Python Solution (Teacher's Voice)",
                code: `from collections import deque

def orangesRotting(grid):
    rows, cols = len(grid), len(grid[0])
    
    # 1. PRE-SCAN: Find all initially rotten oranges (Sources)
    queue = deque()
    fresh_count = 0
    
    for row in range(rows):
        for col in range(cols):
            if grid[row][col] == 2:
                queue.append((row, col))
            elif grid[row][col] == 1:
                fresh_count += 1

    # Edge Case: If no fresh oranges, 0 minutes needed.
    if fresh_count == 0:
        return 0
    
    # 2. BFS: Level by Level
    minutes_elapsed = 0
    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    
    # Trap Fix: "while queue and fresh_count > 0"
    while queue and fresh_count > 0:
        
        # Process ONLY current level (snapshot of current minute)
        for _ in range(len(queue)):
            current_row, current_col = queue.popleft()

            for row_change, col_change in directions:
                new_row = current_row + row_change
                new_col = current_col + col_change 

                # Valid check + Fresh check
                if 0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 1:
                    grid[new_row][new_col] = 2  # Rot it immediately!
                    fresh_count -= 1
                    queue.append((new_row, new_col)) # Add to NEXT level
        
        minutes_elapsed += 1
    
    # 3. FINAL CHECK: Did we reach everyone?
    return minutes_elapsed if fresh_count == 0 else -1`
            }
        },

        {
            id: "course-schedule",
            title: "Course Schedule",
            leetcodeUrl: "https://leetcode.com/problems/course-schedule/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Topo Sort"],
            quiz: {
                description: "Detect if courses can be finished (dependencies). Algo?",
                options: ["Dijkstra", "Kahn's Algo (Topo Sort)", "Union Find", "Floyd Warshall"],
                correct: 1,
                explanation: "Topo Sort (Kahn's)! Build graph. Calculate Indegrees. Q = [Indegree 0]. Process Q, reduce neighbor indegrees. If processed count == N, true."
            },
            learn: {
                quickAlgo: [
                    "indegree = [0] * n; graph = defaultdict(list)",
                    "for a, b in prereqs:",
                    "    graph[b].append(a); indegree[a] += 1 # ğŸ¯ Build Graph + Indegrees",
                    "q = deque([i for i in range(n) if indegree[i] == 0]) # âš¡ Start: No deps",
                    "count = 0",
                    "while q:",
                    "    node = q.popleft(); count += 1",
                    "    for nei in graph[node]:",
                    "        indegree[nei] -= 1           # ğŸ”„ Reduce dependency",
                    "        if indegree[nei] == 0: q.append(nei) # âœ… Unlocked!",
                    "return count == n                   # ğŸ’¡ All done = No cycle"
                ],
                metrics: { time: "O(V+E)", space: "O(V+E)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(V + E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <p><strong>Step-by-Step Breakdown:</strong></p>
                        <ul style="line-height:1.6; color:#e2e8f0;">
                            <li><strong>Build Graph:</strong> <code style="color:#22d3ee;">O(E)</code> - Iterate through all prerequisites.</li>
                            <li><strong>Initialize Queue:</strong> <code style="color:#22d3ee;">O(V)</code> - Scan all in-degrees.</li>
                            <li><strong>BFS Processing:</strong> <code style="color:#22d3ee;">O(V + E)</code> - Process each vertex once, visit each edge once.</li>
                        </ul>
                        <div style="margin-top:15px; background:#0f172a; padding:10px; border-radius:8px; text-align:center;">
                            <code style="color:#34d399; font-size:1.1rem;">Total: O(E) + O(V) + O(V + E) = O(V + E)</code>
                        </div>
                        <p style="margin-top:10px; font-size:0.9em; color:#cbd5e1;"><em>Interview Tip:</em> "Why not VÃ—E? Because we don't re-scan edges for every node. We visit each edge exactly once."</p>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ’¾ Space Complexity: O(V + E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <table style="width:100%;">
                            <tr><td style="padding:8px;"><strong>Graph:</strong></td><td>O(E) - Adjacency list stores E edges.</td></tr>
                            <tr><td style="padding:8px;"><strong>In-degree Array:</strong></td><td>O(V) - Size of num_courses.</td></tr>
                            <tr><td style="padding:8px;"><strong>Queue:</strong></td><td>O(V) - Worst case all nodes (0 dependencies).</td></tr>
                        </table>
                        <div style="margin-top:15px; font-weight:bold; color:#e879f9; text-align:center;">
                            Total Space â‰ˆ O(V + E)
                        </div>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ”— Topological Sort: Kahn's Algorithm</h4>
                    <div style="display:flex; flex-direction:column; gap:20px; max-width:600px; margin:20px 0;">
                      
                      <!-- Graph Structure -->
                      <div style="display:flex; justify-content:center; gap:40px; margin-bottom:10px;">
                         <!-- Node 0 -->
                         <div style="position:relative; text-align:center;">
                            <div style="width:40px; height:40px; background:#10b981; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; border:2px solid #fff; margin:0 auto;">0</div>
                            <div style="margin-top:5px; font-size:12px; color:#cbd5e1;">In: <span style="color:#10b981">0</span></div>
                         </div>
                         
                         <div style="display:flex; flex-direction:column; justify-content:center; font-size:20px; color:#64748b;">
                            <div>â”</div>
                            <div>â†˜</div>
                         </div>

                         <!-- Node 1 & 2 -->
                         <div style="display:flex; flex-direction:column; gap:20px;">
                            <div style="position:relative; text-align:center;">
                                <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; margin:0 auto;">1</div>
                                <div style="margin-top:5px; font-size:12px; color:#cbd5e1;">In: 1</div>
                            </div>
                            <div style="position:relative; text-align:center;">
                                <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; margin:0 auto;">2</div>
                                <div style="margin-top:5px; font-size:12px; color:#cbd5e1;">In: 1</div>
                            </div>
                         </div>
                         
                         <div style="display:flex; flex-direction:column; justify-content:center; font-size:20px; color:#64748b;">
                            <div>â†˜</div>
                            <div>â†—</div>
                         </div>

                         <!-- Node 3 -->
                         <div style="position:relative; text-align:center;">
                            <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; margin:0 auto;">3</div>
                            <div style="margin-top:5px; font-size:12px; color:#cbd5e1;">In: 2</div>
                         </div>
                      </div>

                      <!-- Timeline Breakdown -->
                      <div style="background:#1e293b; padding:15px; border-radius:8px;">
                         <div style="border-left:3px solid #10b981; padding-left:15px; margin-bottom:15px;">
                            <div style="color:#10b981; font-weight:bold; font-size:12px; margin-bottom:4px;">STEP 1: INITIALIZE</div>
                            <div style="color:#e2e8f0; font-size:13px;">Find nodes with Indegree = 0 (Node 0)</div>
                            <div style="margin-top:5px; background:#0f172a; padding:6px; border-radius:4px; display:inline-block; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               Queue: [ <span style="color:#10b981; font-weight:bold;">0</span> ]
                            </div>
                         </div>
                         
                         <div style="border-left:3px solid #f59e0b; padding-left:15px; margin-bottom:15px;">
                            <div style="color:#f59e0b; font-weight:bold; font-size:12px; margin-bottom:4px;">STEP 2: PROCESS 0</div>
                            <div style="color:#cbd5e1; font-size:13px;">Pop 0 â†’ Decrement neighbors (1 & 2)</div>
                            <div style="color:#e2e8f0; font-size:13px; margin-top:2px;">Indegrees become 0! Add to Q.</div>
                            <div style="margin-top:5px; background:#0f172a; padding:6px; border-radius:4px; display:inline-block; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               Queue: [ <span style="color:#f59e0b; font-weight:bold;">1, 2</span> ]
                            </div>
                         </div>

                         <div style="border-left:3px solid #a78bfa; padding-left:15px;">
                            <div style="color:#a78bfa; font-weight:bold; font-size:12px; margin-bottom:4px;">STEP 3: PROCESS 1 & 2</div>
                            <div style="color:#cbd5e1; font-size:13px;">Pop 1, 2 â†’ Decrement 3 twice (2â†’1â†’0)</div>
                            <div style="color:#e2e8f0; font-size:13px; margin-top:2px;">3 is now free! Add to Q.</div>
                            <div style="margin-top:5px; background:#0f172a; padding:6px; border-radius:4px; display:inline-block; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               Queue: [ <span style="color:#a78bfa; font-weight:bold;">3</span> ]
                            </div>
                         </div>
                      </div>
                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: Kahn's Algorithm</h4>
                    <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981; margin:15px 0;">
                        <strong>Core Idea:</strong>
                        <ul style="margin:5px 0 0 20px; color:#e2e8f0;">
                            <li>Cycle = Impossible (Return False)</li>
                            <li>No Cycle = Possible (Return True)</li>
                        </ul>
                    </div>
                    <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
                        <div style="background:#0f172a; padding:15px; border-radius:8px;">
                            <strong style="color:#38bdf8;">1. In-Degree</strong>
                            <p style="font-size:0.9em; color:#94a3b8;">How many courses must be done <em>before</em> this one.</p>
                        </div>
                        <div style="background:#0f172a; padding:15px; border-radius:8px;">
                            <strong style="color:#38bdf8;">2. Queue</strong>
                            <p style="font-size:0.9em; color:#94a3b8;">Courses with 0 dependencies (Ready to take).</p>
                        </div>
                    </div>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Common Mistakes (Interview Killers)</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#f87171;">1. Wrong Graph Direction âŒ</strong><br>
                            <span style="color:#cbd5e1; font-size:0.9em;">Make sure <code>pre -> course</code>. If <code>[1, 0]</code>, it means 0 -> 1.</span>
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#f87171;">2. Syntax Errors âŒ</strong><br>
                            <span style="color:#cbd5e1; font-size:0.9em;"><code>graph[pre].append = course</code> is WRONG. Use <code>.append(course)</code>.</span>
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#fbbf24;">3. Counting Neighbors vs Courses âš ï¸</strong><br>
                            <span style="color:#cbd5e1; font-size:0.9em;">Increment <code>processed</code> when popping from Queue (Course level), NOT when iterating neighbors.</span>
                        </div>
                        <div style="background:rgba(139, 92, 246, 0.1); padding:15px; border-radius:8px;">
                             <strong style="color:#a78bfa;">4. Iterating Values vs Indices âš ï¸</strong><br>
                             <span style="color:#cbd5e1; font-size:0.9em;">Use <code>range(num_courses)</code> to check in-degree 0, not <code>in_degree</code> values directly.</span>
                        </div>
                    </div>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: N=5, [[1,0],[2,0],[3,1],[3,2],[4,3]]</h4>
                    <div style="background:#0f172a; padding:20px; border-radius:12px; font-family:'Consolas', monospace;">
                        <pre style="color:#e2e8f0; margin:0; line-height:1.8;">
<span style="color:#f59e0b;">Init:</span> Q=[0], processed=0
<span style="color:#64748b;">(0 is only one with in-degree 0)</span>

<span style="color:#f59e0b;">Process 0:</span> processed=1
Neighbors: 1, 2
Indegrees: 1->0, 2->0
Q -> [1, 2]

<span style="color:#f59e0b;">Process 1:</span> processed=2
Neighbor: 3
Indegree: 3->1 (Still waiting on 2)
Q -> [2]

<span style="color:#f59e0b;">Process 2:</span> processed=3
Neighbor: 3
Indegree: 3->0 (Now 3 is free!)
Q -> [3]

<span style="color:#f59e0b;">Process 3:</span> processed=4
Neighbor: 4
Indegree: 4->0
Q -> [4]

<span style="color:#10b981;">Final:</span> processed(5) == num_courses(5) -> True
                        </pre>
                    </div>
                `,
                codeTitle: "Python Solution (Kahn's Algorithm)",
                code: `from collections import defaultdict, deque

def course_schedule(num_courses, prerequisites):
    # STEP 1: Build graph and in-degree array
    graph = defaultdict(list)
    in_degree = [0] * num_courses
    
    for course, pre_course in prerequisites:
        graph[pre_course].append(course)  # pre_course -> course
        in_degree[course] += 1
    
    # STEP 2: Find all starting points (in_degree = 0)
    que = deque()
    for course in range(num_courses):
        if in_degree[course] == 0:
            que.append(course)
    
    # STEP 3: BFS - Process level by level
    processed_courses = 0
    
    while que:
        cur_course = que.popleft()
        processed_courses += 1  # âœ… Count this course
        
        for neighbour in graph[cur_course]:
            in_degree[neighbour] -= 1
            if in_degree[neighbour] == 0:
                que.append(neighbour)
    
    # STEP 4: Check if all courses processed
    return processed_courses == num_courses`
            }
        },

        {
            id: "network-delay-time",
            title: "Network Delay Time",
            leetcodeUrl: "https://leetcode.com/problems/network-delay-time/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Dijkstra"],
            quiz: {
                description: "Max time for signal to reach all nodes. Weighted edges.",
                options: ["BFS", "Dijkstra", "DFS", "Topo Sort"],
                correct: 1,
                explanation: "Dijkstra! Weighted edges require Priority Queue. BFS is for unweighted. Visit nodes in increasing order of cost."
            },
            learn: {
                quickAlgo: [
                    "dist = {node: inf for node in graph}; dist[src] = 0",
                    "heap = [(0, src)]                  # ğŸ¯ MinHeap: (cost, node)",
                    "visited = set()",
                    "while heap:",
                    "    cost, node = heappop(heap)",
                    "    if node in visited: continue   # âš¡ Already found shortest",
                    "    visited.add(node)",
                    "    for nei, weight in graph[node]:",
                    "        new_cost = cost + weight",
                    "        if new_cost < dist[nei]:   # ğŸ”„ Relaxation",
                    "            dist[nei] = new_cost",
                    "            heappush(heap, (new_cost, nei)) # âœ… Push updated",
                    "return dist                        # ğŸ’¡ dist[x] = shortest path from src"
                ],
                metrics: { time: "O(E log V)", space: "O(V+E)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(E log V)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <p><strong>Dijkstra's Algorithm Breakdown:</strong></p>
                        <table style="width:100%; margin-top:10px;">
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1);">
                                <td style="padding:10px;"><strong>Heap Operations:</strong></td>
                                <td style="padding:10px;">Each edge may be pushed to heap â†’ <code style="color:#22d3ee;">O(E)</code> pushes</td>
                            </tr>
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1);">
                                <td style="padding:10px;"><strong>Each Push/Pop:</strong></td>
                                <td style="padding:10px;">Heap has at most V nodes â†’ <code style="color:#22d3ee;">O(log V)</code></td>
                            </tr>
                            <tr>
                                <td style="padding:10px;"><strong>Total:</strong></td>
                                <td style="padding:10px; font-weight:700; color:#34d399;">O(E Ã— log V)</td>
                            </tr>
                        </table>
                        <div style="background:rgba(139, 92, 246, 0.1); padding:15px; border-radius:8px; margin-top:15px;">
                            <strong style="color:#a78bfa;">Why not O(VÂ²)?</strong><br>
                            That's the naive version without a heap. With min-heap, we get O(E log V).
                        </div>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(V+E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <table style="width:100%;">
                            <tr><td style="padding:8px;"><strong>Graph:</strong></td><td>O(V+E) - adjacency list</td></tr>
                            <tr><td style="padding:8px;"><strong>Dist Dict:</strong></td><td>O(V) - stores shortest distances</td></tr>
                            <tr><td style="padding:8px;"><strong>Heap:</strong></td><td>O(E) worst case with lazy deletion</td></tr>
                        </table>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ¯ Dijkstra: Greedy Shortest Path</h4>
                    <div style="display:flex; flex-direction:column; gap:20px; max-width:600px; margin:20px 0;">
                      
                      <!-- Graph Structure -->
                      <div style="display:flex; justify-content:center; gap:50px; margin-bottom:15px; align-items:flex-start;">
                         <!-- Node 1 -->
                         <div style="text-align:center;">
                            <div style="width:40px; height:40px; background:#10b981; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; border:2px solid #fff; margin:0 auto;">1</div>
                            <div style="margin-top:2px; font-size:11px; color:#10b981;">Dist: 0</div>
                         </div>
                         
                         <!-- Nodes 2 & 3 -->
                         <div style="display:flex; flex-direction:column; gap:40px;">
                            <div style="position:relative;">
                                <div style="position:absolute; top:20px; left:-40px; border-top:2px dashed #64748b; width:40px; transform:rotate(-25deg);"></div>
                                <div style="position:absolute; top:5px; left:-25px; font-size:10px; color:#f59e0b; background:#1e293b; padding:0 3px;">2</div>
                                
                                <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white;">2</div>
                                <div style="margin-top:2px; font-size:11px; color:#cbd5e1;">Dist: 2</div>
                            </div>
                            
                            <div style="position:relative;">
                                <div style="position:absolute; top:20px; left:-40px; border-top:2px dashed #64748b; width:40px; transform:rotate(25deg);"></div>
                                <div style="position:absolute; top:35px; left:-25px; font-size:10px; color:#f59e0b; background:#1e293b; padding:0 3px;">1</div>
                                
                                <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white;">3</div>
                                <div style="margin-top:2px; font-size:11px; color:#cbd5e1;">Dist: 1</div>
                            </div>
                         </div>

                         <!-- Node 4 -->
                         <div style="display:flex; align-items:center;">
                             <div style="width:40px; height:40px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white;">4</div>
                         </div>
                      </div>

                      <!-- Heap Logic -->
                      <div style="background:#1e293b; padding:15px; border-radius:8px;">
                         <div style="margin-bottom:12px; border-bottom:1px solid #334155; padding-bottom:8px;">
                            <strong style="color:#cbd5e1; font-size:13px;">MIN-HEAP State (Cost, Node):</strong>
                         </div>

                         <!-- Step 1 -->
                         <div style="display:flex; gap:10px; align-items:center; margin-bottom:12px;">
                            <div style="font-size:12px; color:#64748b; width:40px;">Step 1</div>
                            <div style="background:#0f172a; padding:5px 10px; border-radius:4px; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               [(0, 1)]
                            </div>
                            <div style="font-size:12px; color:#10b981;">Pop 1, Push neighbors (2, 3)</div>
                         </div>

                         <!-- Step 2 -->
                         <div style="display:flex; gap:10px; align-items:center; margin-bottom:12px;">
                            <div style="font-size:12px; color:#64748b; width:40px;">Step 2</div>
                            <div style="background:#0f172a; padding:5px 10px; border-radius:4px; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               [(1, 3), (2, 2)]
                            </div>
                            <div style="font-size:12px; color:#10b981;">Pop 3 (Cost 1), Push 4</div>
                         </div>

                         <!-- Step 3 -->
                         <div style="display:flex; gap:10px; align-items:center;">
                            <div style="font-size:12px; color:#64748b; width:40px;">Step 3</div>
                            <div style="background:#0f172a; padding:5px 10px; border-radius:4px; font-family:monospace; font-size:12px; border:1px solid #334155;">
                               [(2, 2), (4, 4)]
                            </div>
                            <div style="font-size:12px; color:#10b981;">Pop 2 (Cost 2)...</div>
                         </div>

                      </div>
                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: Greedy + Min-Heap</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Greedy Choice:</strong> Always process the node with smallest known distance
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px; border-left:4px solid #f59e0b;">
                            <strong>Relaxation:</strong> If new path is shorter, update and push to heap
                        </div>
                        <div style="background:rgba(139, 92, 246, 0.1); padding:15px; border-radius:8px; border-left:4px solid #8b5cf6;">
                            <strong>Lazy Deletion:</strong> Skip nodes that are already in dist (stale entries)
                        </div>
                    </div>
                    <div style="background:#0f172a; padding:15px; border-radius:8px; margin:15px 0; font-family:Consolas;">
                        <code style="color:#7dd3fc;">
                            while heap:<br>
                            &nbsp;&nbsp;cost, node = heappop(heap)<br>
                            &nbsp;&nbsp;if node in dist: continue  # <span style="color:#ef4444;">CRITICAL!</span><br>
                            &nbsp;&nbsp;dist[node] = cost<br>
                            &nbsp;&nbsp;for neighbor, weight in graph[node]:<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;if neighbor not in dist:<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;heappush(heap, (cost + weight, neighbor))
                        </code>
                    </div>
                    <h5 style="color:#a78bfa; margin-top:20px;">Same Pattern Problems:</h5>
                    <ul style="line-height:2;">
                        <li>ğŸ›¤ï¸ <strong>Cheapest Flights Within K Stops</strong> - Dijkstra with constraint</li>
                        <li>ğŸŠ <strong>Swim in Rising Water</strong> - Min-max path (modified Dijkstra)</li>
                        <li>ğŸ“ <strong>Path with Minimum Effort</strong> - Minimize maximum edge</li>
                        <li>ğŸš— <strong>Shortest Path in Binary Matrix</strong> - BFS (unweighted)</li>
                    </ul>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Common Traps</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 1: Stale Heap Entries</strong><br>
                            Same node can be pushed multiple times with different costs.<br>
                            <code style="background:#0f172a; padding:4px 8px; border-radius:4px; color:#f87171;">if node in dist: continue</code>
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 2: Using BFS for Weighted</strong><br>
                            BFS only works for unweighted graphs! Dijkstra is for weighted.
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 3: Negative Weights</strong><br>
                            Dijkstra FAILS with negative weights! Use Bellman-Ford instead.
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 4: Node Indexing</strong><br>
                            This problem uses 1-indexed nodes! Start from node k, not k-1.
                        </div>
                    </div>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: times=[[1,2,1],[1,3,2],[2,3,1]], n=3, k=1</h4>
                    <div style="background:#0f172a; padding:20px; border-radius:12px; font-family:'Consolas', monospace;">
                        <pre style="color:#e2e8f0; margin:0; line-height:1.8;">
<span style="color:#f59e0b;">Graph:</span>
  1 â†’(1)â†’ 2 â†’(1)â†’ 3
  1 â†’(2)â†’ 3

<span style="color:#f59e0b;">Initial:</span>
  heap = [(0, 1)]
  dist = {}

<span style="color:#f59e0b;">Pop (0, 1):</span>
  dist = {1: 0}
  Push (0+1, 2) and (0+2, 3)
  heap = [(1, 2), (2, 3)]

<span style="color:#f59e0b;">Pop (1, 2):</span>
  dist = {1: 0, 2: 1}
  Push (1+1, 3) = (2, 3)
  heap = [(2, 3), (2, 3)]  â† duplicate!

<span style="color:#f59e0b;">Pop (2, 3):</span>
  dist = {1: 0, 2: 1, 3: 2}
  heap = [(2, 3)]  â† stale entry

<span style="color:#f59e0b;">Pop (2, 3):</span>
  3 in dist â†’ SKIP!

<span style="color:#10b981;">âœ… len(dist) == n, return max(dist.values()) = 2</span>
                        </pre>
                    </div>
                `,
                codeTitle: "Python Solution (Dijkstra)",
                code: `def networkDelayTime(times, n, k):
    import heapq
    from collections import defaultdict
    
    # Build adjacency list
    graph = defaultdict(list)
    for u, v, w in times:
        graph[u].append((v, w))
    
    # Min-heap: (distance, node)
    heap = [(0, k)]
    dist = {}
    
    while heap:
        cost, node = heapq.heappop(heap)
        
        # Skip stale entries (already processed)
        if node in dist:
            continue
        
        # First time reaching this node = shortest path
        dist[node] = cost
        
        # Relax neighbors
        for neighbor, weight in graph[node]:
            if neighbor not in dist:
                heapq.heappush(heap, (cost + weight, neighbor))
    
    # Check if all nodes are reachable
    if len(dist) == n:
        return max(dist.values())
    return -1`
            }
        },

        {
            id: "number-of-provinces",
            title: "Number of Provinces",
            leetcodeUrl: "https://leetcode.com/problems/number-of-provinces/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Union-Find"],
            quiz: {
                description: "Count connected components. Efficient DS?",
                options: ["DFS", "BFS", "Union-Find (DSU)", "All of the above"],
                correct: 3,
                explanation: "All work! But DSU (Union-Find) is the most elegant for 'connectivity' and 'components'. Initialize N parents. Union connected nodes. Count unique parents."
            },
            learn: {
                quickAlgo: [
                    "parent = list(range(n)); rank = [0] * n",
                    "def find(x):                       # ğŸ¯ Path Compression",
                    "    if parent[x] != x: parent[x] = find(parent[x])",
                    "    return parent[x]",
                    "def union(x, y):                   # âš¡ Union by Rank",
                    "    px, py = find(x), find(y)",
                    "    if px == py: return False      # ğŸ”„ Already connected (Cycle!)",
                    "    if rank[px] < rank[py]: px, py = py, px",
                    "    parent[py] = px",
                    "    if rank[px] == rank[py]: rank[px] += 1",
                    "    return True                    # âœ… Merged successfully"
                ],
                metrics: { time: "O(NÂ²Ã—Î±(N))", space: "O(N)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(NÂ² Ã— Î±(N))</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <table style="width:100%; margin-top:10px;">
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1);">
                                <td style="padding:10px;"><strong>Iterate Matrix:</strong></td>
                                <td style="padding:10px;">O(NÂ²) - check each pair</td>
                            </tr>
                            <tr style="border-bottom:1px solid rgba(255,255,255,0.1);">
                                <td style="padding:10px;"><strong>Union/Find:</strong></td>
                                <td style="padding:10px;">O(Î±(N)) â‰ˆ O(1) with path compression</td>
                            </tr>
                        </table>
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; margin-top:15px;">
                            <strong style="color:#10b981;">What is Î±(N)?</strong><br>
                            Inverse Ackermann function. For any practical N (even 10^100), Î±(N) â‰¤ 5. Basically constant!
                        </div>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(N)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <table style="width:100%;">
                            <tr><td style="padding:8px;"><strong>Parent Array:</strong></td><td>O(N) - one entry per node</td></tr>
                            <tr><td style="padding:8px;"><strong>Rank Array (optional):</strong></td><td>O(N) - for union by rank</td></tr>
                        </table>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ¢ Union-Find: Corporate Merger</h4>
                    <div style="display:flex; flex-direction:column; gap:20px; max-width:600px; margin:20px 0;">
                        
                        <!-- Initial State -->
                        <div style="background:#1e293b; padding:10px; border-radius:8px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                                <span style="color:#cbd5e1; font-size:12px;">Step 1: Initial (4 Provinces)</span>
                                <span style="font-family:monospace; color:#e2e8f0; font-size:11px;">Parent: [0, 1, 2, 3]</span>
                            </div>
                            <div style="display:flex; gap:10px; justify-content:center;">
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">0</div>
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">1</div>
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">2</div>
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">3</div>
                            </div>
                        </div>

                        <!-- Union 0-1 -->
                        <div style="background:#1e293b; padding:10px; border-radius:8px;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                                <span style="color:#cbd5e1; font-size:12px;">Step 2: Union(0, 1)</span>
                                <span style="font-family:monospace; color:#e2e8f0; font-size:11px;">Parent: [1, 1, 2, 3]</span>
                            </div>
                            <div style="display:flex; gap:10px; justify-content:center; align-items:flex-start;">
                                <div style="display:flex; flex-direction:column; align-items:center;">
                                    <div style="width:30px; height:30px; background:#10b981; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px; border:2px solid #fff;">1</div>
                                    <div style="height:15px; border-left:2px solid #64748b;"></div>
                                    <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">0</div>
                                </div>
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">2</div>
                                <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">3</div>
                            </div>
                        </div>

                        <!-- Union 1-2 (Result) -->
                        <div style="background:#1e293b; padding:10px; border-radius:8px; border:1px solid #10b981;">
                            <div style="display:flex; justify-content:space-between; margin-bottom:10px;">
                                <span style="color:#10b981; font-size:12px; font-weight:bold;">Step 3: Union(1, 2) â†’ Final</span>
                                <span style="font-family:monospace; color:#e2e8f0; font-size:11px;">Count: 2</span>
                            </div>
                            <div style="display:flex; gap:40px; justify-content:center;">
                                <!-- Group 1 -->
                                <div style="position:relative; width:80px; height:80px; border:2px dashed #64748b; border-radius:12px; display:flex; justify-content:center; align-items:end; padding-bottom:5px;">
                                    <div style="position:absolute; top:-10px; background:#1e293b; color:#cbd5e1; font-size:10px; padding:0 5px;">Prov A</div>
                                    
                                    <!-- Tree Structure -->
                                    <div style="position:absolute; top:10px; left:25px; width:30px; height:30px; background:#10b981; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px; z-index:2;">2</div>
                                    
                                    <svg style="position:absolute; top:25px; left:10px; width:60px; height:40px; z-index:1;">
                                        <line x1="20" y1="0" x2="10" y2="30" stroke="#64748b" stroke-width="2" />
                                        <line x1="20" y1="0" x2="50" y2="30" stroke="#64748b" stroke-width="2" />
                                    </svg>

                                    <div style="position:absolute; bottom:5px; left:5px; width:25px; height:25px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:10px;">0</div>
                                    <div style="position:absolute; bottom:5px; right:5px; width:25px; height:25px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:10px;">1</div>
                                </div>

                                <!-- Group 2 -->
                                <div style="position:relative; width:40px; height:80px; border:2px dashed #64748b; border-radius:12px; display:flex; justify-content:center; align-items:center;">
                                    <div style="position:absolute; top:-10px; background:#1e293b; color:#cbd5e1; font-size:10px; padding:0 5px;">Prov B</div>
                                    <div style="width:30px; height:30px; background:#10b981; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-size:12px;">3</div>
                                </div>
                            </div>
                        </div>

                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: Find Root + Union Roots</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Find with Path Compression:</strong><br>
                            <code style="background:#0f172a; padding:4px 8px; border-radius:4px;">if parent[x] != x: parent[x] = find(parent[x])</code>
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px; border-left:4px solid #f59e0b;">
                            <strong>Union by Rank/Size:</strong> Attach smaller tree under larger tree's root
                        </div>
                    </div>
                    <h5 style="color:#a78bfa; margin-top:20px;">Same Pattern Problems:</h5>
                    <ul style="line-height:2;">
                        <li>ğŸï¸ <strong>Number of Islands</strong> - Can use DFS or DSU</li>
                        <li>ğŸ”— <strong>Redundant Connection</strong> - Find the extra edge</li>
                        <li>ğŸ“Š <strong>Accounts Merge</strong> - Group by common emails</li>
                        <li>ğŸ‘¥ <strong>Smallest String with Swaps</strong> - Group indices by swaps</li>
                    </ul>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Common Traps</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 1: Union Nodes, Not Roots</strong><br>
                            <code style="color:#f87171;">parent[x] = y</code> is WRONG!<br>
                            <code style="color:#10b981;">parent[find(x)] = find(y)</code> is CORRECT!
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 2: Counting Components</strong><br>
                            Count unique roots, not unique parent values. Use set(find(i) for i in range(n)).
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">Trap 3: Self-Connection</strong><br>
                            isConnected[i][i] = 1 always. Don't count it twice or union i with i.
                        </div>
                    </div>
                `,
                codeTitle: "Python Solution (Union-Find)",
                code: `def findCircleNum(isConnected):
    n = len(isConnected)
    parent = list(range(n))
    count = n  # Start with N separate provinces
    
    def find(x):
        # Path compression: point directly to root
        if parent[x] != x:
            parent[x] = find(parent[x])
        return parent[x]
    
    def union(x, y):
        nonlocal count
        root_x, root_y = find(x), find(y)
        if root_x != root_y:
            parent[root_x] = root_y  # Merge trees
            count -= 1               # One less component
    
    # Check each pair (upper triangle only)
    for i in range(n):
        for j in range(i + 1, n):
            if isConnected[i][j] == 1:
                union(i, j)
    
    return count`
            }
        },

        {
            id: "clone-graph",
            title: "Clone Graph",
            leetcodeUrl: "https://leetcode.com/problems/clone-graph/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¢",
            tags: ["Deep Copy"],
            quiz: {
                description: "Deep copy graph. How to handle cycles?",
                options: ["BFS", "DFS + HashMap", "Recursion only", "Queue"],
                correct: 1,
                explanation: "DFS + HashMap! Map stores `OldNode -> NewNode`. If node in map, return stored copy (handles cycles). Else create, add to map, recurse."
            },
            learn: {
                quickAlgo: [
                    "old_to_new = {}                    # ğŸ¯ Map original -> clone",
                    "def dfs(node):",
                    "    if node in old_to_new:         # âš¡ Already cloned? (Cycle handling)",
                    "        return old_to_new[node]",
                    "    clone = Node(node.val)         # ğŸ”„ Create new node",
                    "    old_to_new[node] = clone       # âœ… Store BEFORE recursing (critical!)",
                    "    for nei in node.neighbors:",
                    "        clone.neighbors.append(dfs(nei)) # ğŸ’¡ Clone neighbors recursively",
                    "    return clone",
                    "return dfs(node)"
                ],
                metrics: { time: "O(V+E)", space: "O(V)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(V + E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left: 10px;">
                            <li><strong style="color:#f472b6;">Visit Nodes:</strong> Each node processed exactly once (Hash Map check). <code>O(V)</code></li>
                            <li><strong style="color:#f472b6;">Traverse Edges:</strong> We iterate over neighbors for every node. <code>O(E)</code></li>
                        </ul>
                        <div style="margin-top:10px; font-weight:bold; text-align:center; color:#e879f9;">Total: O(V + E)</div>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(V)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left: 10px;">
                            <li><strong style="color:#22d3ee;">Hash Map:</strong> Stores V nodes. <code>O(V)</code></li>
                            <li><strong style="color:#22d3ee;">Recursion Stack:</strong> Worst case depth is V. <code>O(V)</code></li>
                        </ul>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ”„ Clone with Cycle Detection</h4>
                    <div style="display:flex; gap:10px; margin:20px 0; max-width:600px;">
                        
                        <!-- Original Graph (Left) -->
                        <div style="flex:1; background:#1e293b; padding:10px; border-radius:8px;">
                            <div style="text-align:center; color:#94a3b8; font-size:12px; margin-bottom:10px;">Original Graph</div>
                            <div style="display:flex; justify-content:center; gap:20px;">
                                <div style="display:flex; flex-direction:column; gap:20px;">
                                    <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white;">1</div>
                                    <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white;">4</div>
                                </div>
                                <div style="display:flex; flex-direction:column; gap:20px;">
                                    <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white;">2</div>
                                    <div style="width:30px; height:30px; background:#334155; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white;">3</div>
                                </div>
                            </div>
                        </div>

                        <!-- Expansion Logic (Middle) -->
                        <div style="flex:1.5; display:flex; flex-direction:column; gap:8px;">
                            
                            <div style="background:#0f172a; padding:8px; border-radius:6px; border-left:3px solid #f59e0b;">
                                <div style="font-size:11px; color:#f59e0b; font-weight:bold;">1. Visit Node 1</div>
                                <div style="font-size:10px; color:#cbd5e1;">Map: {1 -> 1'}</div>
                            </div>

                            <div style="background:#0f172a; padding:8px; border-radius:6px; border-left:3px solid #f59e0b;">
                                <div style="font-size:11px; color:#f59e0b; font-weight:bold;">2. Visit Node 2</div>
                                <div style="font-size:10px; color:#cbd5e1;">Map: {1->1', 2->2'}</div>
                            </div>

                            <div style="background:#0f172a; padding:8px; border-radius:6px; border-left:3px solid #10b981;">
                                <div style="font-size:11px; color:#10b981; font-weight:bold;">3. Visit 1 (Cycle)</div>
                                <div style="font-size:10px; color:#cbd5e1;">1 in Map? YES! Return 1'</div>
                            </div>

                        </div>

                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: HashMap = Visited + Clone Storage</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Check Map First:</strong> If node exists in map, return existing clone (breaks cycles!)
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px; border-left:4px solid #f59e0b;">
                            <strong>Add to Map BEFORE recursing:</strong> This is critical for cycle handling!
                        </div>
                    </div>
                    <div style="background:#0f172a; padding:15px; border-radius:8px; margin:15px 0; font-family:Consolas;">
                        <code style="color:#7dd3fc;">
                            if node in hashmap: return hashmap[node]<br>
                            clone = Node(node.val)<br>
                            hashmap[node] = clone  # <span style="color:#ef4444;">ADD BEFORE RECURSING!</span><br>
                            for neighbor in node.neighbors:<br>
                            &nbsp;&nbsp;clone.neighbors.append(dfs(neighbor))
                        </code>
                    </div>
                    <h5 style="color:#a78bfa; margin-top:20px;">Same Pattern Problems:</h5>
                    <ul style="line-height:2;">
                        <li>ğŸ“‹ <strong>Copy List with Random Pointer</strong> - Same hashmap trick</li>
                        <li>ğŸŒ³ <strong>Clone Binary Tree with Random Pointer</strong> - Tree version</li>
                        <li>ğŸ”— <strong>Clone N-ary Tree</strong> - Simpler, no cycles</li>
                    </ul>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Common Mistakes & Why They're Wrong</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">1. Missing Base Case Check âŒ</strong><br>
                            <span style="color:#cbd5e1; font-size:0.9rem;"><code>if node in cloned: return cloned[node]</code></span><br>
                            Without this, cycles (e.g., 1â†’2â†’1) cause infinite recursion!
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">2. Late Map Entry âŒ</strong><br>
                            Store <code>cloned[node] = clone</code> <strong>BEFORE</strong> processing neighbors.<br>
                            If you do it after, the neighbor's recursive call won't find the node in 'cloned', leading to loops.
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#fbbf24;">3. Not Handling None Input âš ï¸</strong><br>
                            Graph can be empty! <code>if not node: return None</code>
                        </div>
                    </div>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: 1 -- 2</h4>
                    <div style="background:#0f172a; padding:15px; border-radius:12px; font-family:'Consolas', monospace; font-size:0.9rem;">
                        <div style="margin-bottom:10px; border-bottom:1px solid #334155; padding-bottom:5px;">
                            <span style="color:#94a3b8;">Start: cloneGraph(1)</span>
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:10px;">
                            â€¢ <strong>DFS(1)</strong>: Not in map.
                            <br>&nbsp;&nbsp;â†’ Create Clone(1). Map = {1: 1'}
                            <br>&nbsp;&nbsp;â†’ Process neighbor 2.
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:25px; margin-top:5px; border-left:2px solid #334155; padding-left:10px;">
                            â€¢ <strong>DFS(2)</strong>: Not in map.
                            <br>â†’ Create Clone(2). Map = {1: 1', 2: 2'}
                            <br>â†’ Process neighbor 1 (Cycle!).
                            <br><span style="color:#10b981; background:rgba(16, 185, 129, 0.2); padding:2px 6px; border-radius:4px;">1 IS in Map! Return Clone(1)</span>
                        </div>
                    </div>
                `,
                codeTitle: "Python Solution (DFS + HashMap)",
                code: `class Node:
    def __init__(self, val=0, neighbors=None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []

def cloneGraph(node):
    # EDGE CASE: Empty graph
    if not node:
        return None
    
    # Hash map: original_node -> cloned_node
    cloned = {}
    
    def dfs(node):
        # BASE CASE: Node already cloned? Return it!
        if node in cloned:
            return cloned[node]
        
        # STEP 1: Create clone
        clone = Node(node.val)
        
        # STEP 2: Store in map BEFORE neighbors (Critical!)
        cloned[node] = clone
        
        # STEP 3: Clone neighbors recursively
        for neighbor in node.neighbors:
            clone.neighbors.append(dfs(neighbor))
        
        return clone
    
    return dfs(node)`
            }
        },

        {
            id: "is-graph-bipartite",
            title: "Is Graph Bipartite?",
            leetcodeUrl: "https://leetcode.com/problems/is-graph-bipartite/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Graph Coloring"],
            quiz: {
                description: "Can graph be colored with 2 colors? Algorithm?",
                options: ["Dijkstra", "BFS/DFS 2-Coloring", "Topological Sort", "Union Find"],
                correct: 1,
                explanation: "2-Coloring (Bipartite Check)! Use BFS/DFS. Assign color 0/1. If neighbor has SAME color -> False. If neighbor unvisited -> Assign opposite color."
            },
            learn: {
                quickAlgo: [
                    "color = [-1] * n                   # ğŸ¯ -1 = Unvisited",
                    "def bfs(start):",
                    "    q = deque([start]); color[start] = 0",
                    "    while q:",
                    "        node = q.popleft()",
                    "        for nei in graph[node]:",
                    "            if color[nei] == -1:   # âš¡ Uncolored? Assign opposite",
                    "                color[nei] = 1 - color[node]",
                    "                q.append(nei)",
                    "            elif color[nei] == color[node]: # ğŸ”„ Same color = Conflict!",
                    "                return False",
                    "    return True",
                    "return all(bfs(i) for i in range(n) if color[i] == -1) # âœ… Check all components"
                ],
                metrics: { time: "O(V+E)", space: "O(V)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(V + E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left:10px;">
                            <li><strong style="color:#f472b6;">Outer Loop:</strong> Iterates V nodes to handle disconnected components. <code>O(V)</code></li>
                            <li><strong style="color:#f472b6;">BFS Traversal:</strong> Visits every node once <code>O(V)</code> and checks all edges <code>O(E)</code>.</li>
                        </ul>
                        <div style="margin-top:10px; font-weight:bold; text-align:center; color:#e879f9;">Total: O(V + E)</div>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(V)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left:10px;">
                            <li><strong style="color:#22d3ee;">Color Array:</strong> Stores state for V nodes. <code>O(V)</code></li>
                            <li><strong style="color:#22d3ee;">Queue:</strong> Worst case holds all nodes at one level. <code>O(V)</code></li>
                        </ul>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ¨ 2-Coloring: Red vs Blue</h4>
                    <div style="display:flex; flex-direction:column; gap:20px; max-width:600px; margin:20px 0;">
                        
                        <!-- Valid Case -->
                        <div style="background:#1e293b; padding:15px; border-radius:8px;">
                            <div style="text-align:center; color:#10b981; font-weight:bold; margin-bottom:15px;">âœ… Bipartite (Even Cycle)</div>
                            <div style="display:flex; justify-content:center; gap:30px; align-items:center;">
                                <div style="display:flex; flex-direction:column; gap:30px;">
                                    <div style="width:40px; height:40px; background:#ef4444; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; border:2px solid #fff;">R</div>
                                    <div style="width:40px; height:40px; background:#3b82f6; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">B</div>
                                </div>
                                <div style="height:80px; width:2px; background:#64748b;"></div>
                                <div style="display:flex; flex-direction:column; gap:30px;">
                                    <div style="width:40px; height:40px; background:#3b82f6; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">B</div>
                                    <div style="width:40px; height:40px; background:#ef4444; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">R</div>
                                </div>
                            </div>
                            <div style="text-align:center; margin-top:10px; font-size:12px; color:#cbd5e1;">All neighbors have DIFFERENT colors</div>
                        </div>

                        <!-- Invalid Case -->
                        <div style="background:#1e293b; padding:15px; border-radius:8px;">
                            <div style="text-align:center; color:#f87171; font-weight:bold; margin-bottom:15px;">âŒ Not Bipartite (Odd Cycle)</div>
                            <div style="display:flex; justify-content:center; align-items:center; position:relative; height:100px;">
                                <!-- Triangle -->
                                <div style="position:absolute; top:0; left:50%; transform:translateX(-50%); width:40px; height:40px; background:#ef4444; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">R</div>
                                <div style="position:absolute; bottom:0; left:20%; width:40px; height:40px; background:#3b82f6; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold;">B</div>
                                
                                <div style="position:absolute; bottom:0; right:20%; width:40px; height:40px; background:#ef4444; border-radius:50%; display:flex; align-items:center; justify-content:center; color:white; font-weight:bold; border:2px dashed #f59e0b;">R?</div>
                                
                                <div style="position:absolute; top:50%; right:10px; color:#f59e0b; font-size:12px; width:80px;">Conflict! Needs Blue but neighbor is Blue</div>
                            </div>
                        </div>

                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: Alternate Colors</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Key Insight:</strong> Bipartite âŸº No odd-length cycles
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px; border-left:4px solid #f59e0b;">
                            <strong>Algorithm:</strong> <code>neighbor_color = 1 - current_color</code>
                        </div>
                    </div>
                    <h5 style="color:#a78bfa; margin-top:20px;">Same Pattern Problems:</h5>
                    <ul style="line-height:2;">
                        <li>ğŸ‘¥ <strong>Possible Bipartition</strong> - Same problem, different name</li>
                        <li>ğŸ« <strong>Divide into Two Groups</strong> - Graph coloring variant</li>
                    </ul>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ Common Mistakes & Why They're Wrong</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">1. Only starting BFS from Node 0 âŒ</strong><br>
                            Graphs can be disconnected! Must iterate <code>range(n)</code> to cover all components.
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#ef4444;">2. Using Visited Set (Boolean) âŒ</strong><br>
                            Need 3 states: <code>-1</code> (Unvisited), <code>0</code> (Color A), <code>1</code> (Color B). Boolean isn't enough to check conflicts.
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px;">
                            <strong style="color:#fbbf24;">3. Incorrect Logic for "Same Color" âš ï¸</strong><br>
                            If neighbor has SAME color as current node â†’ <strong>Odd Cycle Detected</strong> â†’ Return False immediately.
                        </div>
                    </div>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: Triangle 0-1-2 (Not Bipartite)</h4>
                    <div style="background:#0f172a; padding:15px; border-radius:12px; font-family:'Consolas', monospace; font-size:0.9rem;">
                        <div style="margin-bottom:10px; border-bottom:1px solid #334155; padding-bottom:5px;">
                            <span style="color:#94a3b8;">Start: 0-1-2 connected</span>
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:10px;">
                            â€¢ <strong>Process 0</strong>: Color=0. Q=[0]
                            <br>&nbsp;&nbsp;â†’ Neighbors 1, 2 uncolored.
                            <br>&nbsp;&nbsp;â†’ Color[1]=1, Color[2]=1. Q=[1, 2]
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:25px; margin-top:5px; border-left:2px solid #334155; padding-left:10px;">
                            â€¢ <strong>Process 1</strong> (Color 1):
                            <br>â†’ Neighbor 0 (Color 0) âœ… OK (Opposite)
                            <br>â†’ Neighbor 2 (Color 1) âŒ <span style="color:#ef4444; font-weight:bold;">CONFLICT! Same Color!</span>
                        </div>
                        
                        <div style="margin-top:10px; color:#ef4444; font-weight:bold;">
                            Result: False (Odd Cycle Detected)
                        </div>
                    </div>
                `,
                codeTitle: "Python Solution (BFS Coloring)",
                code: `from collections import deque

def isBipartite(graph):
    n = len(graph)
    # -1: Uncolored, 0: Red, 1: Blue
    color = [-1] * n
    
    # Check all components (Handle Disconnected Graphs)
    for start in range(n):
        if color[start] != -1:
            continue
            
        # Begin BFS
        queue = deque([start])
        color[start] = 0  # Assign first color
        
        while queue:
            node = queue.popleft()
            
            for neighbor in graph[node]:
                # Case 1: Uncolored -> Assign opposite color
                if color[neighbor] == -1:
                    color[neighbor] = 1 - color[node]
                    queue.append(neighbor)
                
                # Case 2: Already colored with SAME color -> CONFLICT!
                elif color[neighbor] == color[node]:
                    return False
                    
    return True`
            }
        },

        {
            id: "detect-cycle-directed",
            title: "Detect Cycle (Directed)",
            leetcodeUrl: "https://practice.geeksforgeeks.org/problems/detect-cycle-in-a-directed-graph/1",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["DFS Recursion"],
            quiz: {
                description: "Find cycle in directed graph. DFS State?",
                options: ["Visited Set only", "Visited + RecursionStack Sets", "BFS", "Union Find"],
                correct: 1,
                explanation: "Need 2 Sets! 1. Visited (Global), 2. RecursionStack (Current Path). If node in RecursionStack -> Cycle detected. If in Visited but not Stack -> Safe (Cross Edge)."
            },
            learn: {
                quickAlgo: [
                    "visited, rec_stack = set(), set() # ğŸ¯ Global vs Current Path",
                    "def dfs(node):",
                    "    visited.add(node)",
                    "    rec_stack.add(node)            # âš¡ Add to current path",
                    "    for nei in graph[node]:",
                    "        if nei not in visited:",
                    "            if dfs(nei): return True # ğŸ”„ Recursion found cycle",
                    "        elif nei in rec_stack:     # âœ… Back edge = CYCLE!",
                    "            return True",
                    "    rec_stack.remove(node)         # ğŸ’¡ Backtrack: Remove from path",
                    "    return False"
                ],
                metrics: { time: "O(V+E)", space: "O(V)" },
                timeExplainer: `
                    <h4 style="color:#c026d3;">â±ï¸ Time Complexity: O(V + E)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <p><strong>Step-by-Step Breakdown:</strong></p>
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left: 10px;">
                            <li><strong style="color:#f472b6;">Iterate Graph:</strong> We visit every node once using the loop. <code>O(V)</code></li>
                            <li><strong style="color:#f472b6;">DFS Traversal:</strong> Inside DFS, each node is added to <code>visited</code> once. We never process a visited node again.</li>
                            <li><strong style="color:#f472b6;">Edge Traversal:</strong> For every node, we iterate over its adjacency list. Across the entire process, we traverse every edge exactly once. <code>O(E)</code></li>
                        </ul>
                        <p style="margin-top:10px; background:rgba(0,0,0,0.3); padding:10px; border-radius:8px; text-align:center; border: 1px solid rgba(192, 38, 211, 0.3);">
                            <strong>Total: O(V + E)</strong> where V is vertices, E is edges.
                        </p>
                    </div>
                `,
                spaceExplainer: `
                    <h4 style="color:#c026d3;">ğŸ“¦ Space Complexity: O(V)</h4>
                    <div style="background:rgba(192, 38, 211, 0.1); padding:20px; border-radius:12px; margin:15px 0;">
                        <p><strong>Memory Usage:</strong></p>
                        <ul style="line-height:2.0; color:#e2e8f0; margin-left: 10px;">
                            <li><strong style="color:#22d3ee;">Visited Set:</strong> Stores up to V nodes. <code>O(V)</code></li>
                            <li><strong style="color:#22d3ee;">Recursive Stack Set:</strong> Stores current path nodes. Worst case (line graph) O(V).</li>
                            <li><strong style="color:#22d3ee;">System Call Stack:</strong> Recursion depth can go up to V. <code>O(V)</code></li>
                        </ul>
                        <div style="margin-top:15px; font-size:0.9em; color:#cbd5e1; font-style:italic;">
                            *Adjacency List takes O(V+E) if constructed, but usually given or considered input space. Aux space is O(V).
                        </div>
                    </div>
                `,
                visual: `
                    <h4 style="color:#c026d3;">ğŸ”„ Visualizing the Trap</h4>
                    <div style="display:flex; flex-direction:column; gap:20px; max-width:600px; margin:20px 0;">
                        <div style="background:#1e293b; padding:20px; border-radius:12px; border: 1px solid rgba(255,255,255,0.1);">
                            <div style="display:flex; justify-content:space-around; align-items:center;">
                                <div style="text-align:center;">
                                    <div style="width:50px; height:50px; background:#f59e0b; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:black; margin:0 auto; box-shadow:0 0 15px rgba(245, 158, 11, 0.4);">A</div>
                                    <div style="margin-top:8px; font-size:12px; color:#f59e0b;">Current</div>
                                </div>
                                <div style="font-size:24px; color:#94a3b8;">â¡</div>
                                <div style="text-align:center;">
                                    <div style="width:50px; height:50px; background:#ef4444; border-radius:50%; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; margin:0 auto; border:2px dashed #fff;">B</div>
                                    <div style="margin-top:8px; font-size:12px; color:#ef4444;">Neighbor</div>
                                </div>
                            </div>
                            <div style="margin-top:20px; background:rgba(0,0,0,0.3); padding:15px; border-radius:8px;">
                                <div style="display:flex; justify-content:space-between; margin-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px;">
                                    <span style="color:#94a3b8;">Case 1: B not visited</span>
                                    <strong style="color:#10b981;">Safe to Explore ğŸŸ¢</strong>
                                </div>
                                <div style="display:flex; justify-content:space-between; margin-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px;">
                                    <span style="color:#94a3b8;">Case 2: B in Recursion Stack</span>
                                    <strong style="color:#ef4444;">CYCLE DETECTED! ğŸ”´</strong>
                                </div>
                                <div style="display:flex; justify-content:space-between;">
                                    <span style="color:#94a3b8;">Case 3: B visited, NOT in Stack</span>
                                    <strong style="color:#3b82f6;">Safe (Cross Edge) ğŸ”µ</strong>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                trap: `
                    <h4 style="color:#ef4444;">âš ï¸ The "Visited" Trap</h4>
                    <p style="color:#cbd5e1; margin-bottom:15px;">Why isn't a single <code>visited</code> set enough? Why do we need <code>recursive_stack</code>?</p>
                    
                    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:15px;">
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px; border-left:3px solid #ef4444;">
                            <strong style="color:#f87171;">Scenario:</strong>
                            <br>Path A -> B -> C
                            <br>Path A -> D -> C
                        </div>
                        <div style="background:rgba(59, 130, 246, 0.1); padding:15px; border-radius:8px; border-left:3px solid #3b82f6;">
                            <strong style="color:#60a5fa;">Explanation:</strong>
                            <br>When DFS reaches C via D, C is "visited" (from path A->B->C).
                            <br>But this is NOT a cycle! It's just a merge.
                        </div>
                    </div>
                    <div style="margin-top:15px; background:rgba(255,255,255,0.05); padding:12px; border-radius:8px;">
                        <span style="color:#fbbf24;">âœ… Fix:</span> A cycle exists ONLY if we see a node that is part of the <strong>CURRENT active path</strong> (recursion stack).
                    </div>
                `,
                crux: `
                    <h4 style="color:#10b981;">ğŸ’¡ The Crux: Two Sets with Different Meanings</h4>
                    <div style="display:grid; gap:15px; margin:15px 0;">
                        <div style="background:rgba(16, 185, 129, 0.1); padding:15px; border-radius:8px; border-left:4px solid #10b981;">
                            <strong>Visited Set:</strong> "Have we processed this node in ANY path?" (Global)
                        </div>
                        <div style="background:rgba(245, 158, 11, 0.1); padding:15px; border-radius:8px; border-left:4px solid #f59e0b;">
                            <strong>RecStack Set:</strong> "Is this node in our CURRENT path?" (Local to DFS call)
                        </div>
                        <div style="background:rgba(239, 68, 68, 0.1); padding:15px; border-radius:8px; border-left:4px solid #ef4444;">
                            <strong>Cycle:</strong> Node is in RecStack â†’ We're revisiting it in same path â†’ Back edge â†’ Cycle!
                        </div>
                    </div>
                
                    <h5 style="color:#a78bfa; margin-top:20px;">Same Pattern Problems:</h5>
                    <ul style="line-height:2;">
                        <li>ğŸ“š <strong>Course Schedule</strong> - Uses same DFS cycle detection to find circular dependencies.</li>
                        <li>ğŸ”— <strong>Find Eventual Safe States</strong> - Nodes that are not part of any cycle (and don't lead to one).</li>
                        <li>â­• <strong>Detect Cycle in Undirected Graph</strong> - Simpler version: just track 'parent' to avoid trivial immediate backward path.</li>
                        <li>ğŸ‘½ <strong>Alien Dictionary</strong> - Topological Sort (which detects cycles as "impossible" ordering).</li>
                    </ul>
                `,
                dryRun: `
                    <h4 style="color:#22d3ee;">ğŸ” Dry Run: 0->1, 1->2, 2->0</h4>
                    <div style="background:#0f172a; padding:15px; border-radius:12px; font-family:'Consolas', monospace; font-size:0.9rem;">
                        <div style="margin-bottom:10px; border-bottom:1px solid #334155; padding-bottom:5px;">
                            <span style="color:#94a3b8;">Start DFS(0)</span>
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:10px;">
                            â€¢ <strong>DFS(0)</strong>: Visited={0}, Stack={0}
                            <br>&nbsp;&nbsp;â†’ Neighbor 1? Not visited.
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:25px; margin-top:5px; border-left:2px solid #334155; padding-left:10px;">
                            â€¢ <strong>DFS(1)</strong>: Visited={0,1}, Stack={0,1}
                            <br>â†’ Neighbor 2? Not visited.
                        </div>
                        
                        <div style="color:#e2e8f0; margin-left:40px; margin-top:5px; border-left:2px solid #334155; padding-left:10px;">
                            â€¢ <strong>DFS(2)</strong>: Visited={0,1,2}, Stack={0,1,2}
                            <br>â†’ Neighbor 0?
                            <br><span style="color:#ef4444; background:rgba(239, 68, 68, 0.2); padding:2px 6px; border-radius:4px;">âš ï¸ 0 is in Stack! Return True</span>
                        </div>
                        
                        <div style="color:#10b981; margin-top:10px; font-weight:bold;">
                            Result: True (Cycle Detected)
                        </div>
                    </div>
                `,
                codeTitle: "Python Solution (DFS + Recursive Stack)",
                code: `from collections import defaultdict

def detect_cycle(n, edges):
    # 1. Build Adjacency List
    graph = defaultdict(list)
    for u, v in edges:
        graph[u].append(v)
    
    visited = set()
    recursive_stack = set()
    
    def dfs(node):
        # Mark current node as visited and add to recursion stack
        visited.add(node)
        recursive_stack.add(node)
        
        for neighbour in graph[node]:
            # Case 1: If neighbour not visited, recurse
            if neighbour not in visited:
                if dfs(neighbour):
                    return True
            # Case 2: If neighbour in recursion stack -> CYCLE!
            elif neighbour in recursive_stack:
                return True
        
        # Backtrack: Remove from recursion stack before returning
        recursive_stack.remove(node)
        return False
    
    # 2. Iterate ALL nodes (Handle disconnected components)
    for node in range(n):
        if node not in visited:
            if dfs(node):
                return True
                
    return False

# Example Usage
# n = 3, edges = [[0,1], [1,2], [2,0]] -> True
# n = 4, edges = [[0,1], [0,2], [1,3], [2,3]] -> False`
            }
        }
    ]
}



// ========== data/dsa/dp.js ==========
// Dp data
// Extracted from data.js

const topic_dp = {
    id: "dp",
    title: "Dynamic Programming",
    description: "Principal Engineer DSA â€¢ Day 7",
    color: "#ec4899",
    icon: "fas fa-braille",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ”„ Overlapping Subproblems", desc: "Same small problem solved repeatedly â†’ Memoize it!" },
            { label: "ğŸ—ï¸ Optimal Substructure", desc: "Optimal solution built from optimal sub-solutions" },
            { label: "ğŸ“Š Counting Ways", desc: "How many ways to reach X? â†’ DP addition" },
            { label: "âš–ï¸ Optimization", desc: "Min/Max value? â†’ DP with min()/max()" },
            { label: "âœ… Decision Making", desc: "Take or skip? â†’ Compare both choices" }
        ],
        patterns: [
            { algo: "1D Linear", use: "House Robber, Climbing Stairs", time: "O(N)", space: "O(1)", template: "dp[i] = f(dp[i-1], dp[i-2])" },
            { algo: "0/1 Knapsack", use: "Subset Sum, Partition Equal", time: "O(NÃ—W)", space: "O(W)", template: "Take: dp[j-w]+v, Skip: dp[j]" },
            { algo: "Unbounded Knapsack", use: "Coin Change, Rod Cutting", time: "O(NÃ—W)", space: "O(W)", template: "for coin: dp[j] = min(dp[j], dp[j-coin]+1)" },
            { algo: "LCS/LIS", use: "Longest Common/Increasing", time: "O(NÂ²) or O(N log N)", space: "O(N)", template: "match: dp[i-1][j-1]+1, else: max(skip)" },
            { algo: "Grid DP", use: "Unique Paths, Min Path Sum", time: "O(MÃ—N)", space: "O(N)", template: "dp[i][j] = f(dp[i-1][j], dp[i][j-1])" },
            { algo: "Interval DP", use: "Burst Balloons, MCM", time: "O(NÂ³)", space: "O(NÂ²)", template: "for len, for i, for k in (i,j)" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  DP Pattern Recognition (Recursive Thinking)</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "What type of DP problem?"   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SEQUENCE    â”‚      â”‚   KNAPSACK   â”‚      â”‚    GRID      â”‚
â”‚  Problems    â”‚      â”‚   Problems   â”‚      â”‚   Problems   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                     â”‚                     â”‚
       â–¼                     â–¼                     â–¼
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚ LIS/LCS?      â”‚    â”‚ 0/1? Use item â”‚    â”‚ solve(i, j)   â”‚
 â”‚ solve(i, j)   â”‚    â”‚ ONCE only     â”‚    â”‚               â”‚
 â”‚               â”‚    â”‚               â”‚    â”‚ return from   â”‚
 â”‚ match? +1     â”‚    â”‚ Unbounded?    â”‚    â”‚ solve(i-1, j) â”‚
 â”‚ else max()    â”‚    â”‚ Can REUSE     â”‚    â”‚ solve(i, j-1) â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ğŸ”¥ UNIVERSAL RECURSIVE TEMPLATE:                        â”‚
  â”‚                                                         â”‚
  â”‚   def solve(i, ...):                                    â”‚
  â”‚       if BASE_CASE: return 0                            â”‚
  â”‚       if (i, ...) in memo: return memo[(i, ...)]        â”‚
  â”‚                                                         â”‚
  â”‚       take = value + solve(NEXT_STATE_AFTER_TAKE)       â”‚
  â”‚       skip = solve(NEXT_STATE_AFTER_SKIP)               â”‚
  â”‚                                                         â”‚
  â”‚       memo[(i, ...)] = max(take, skip)  # or min        â”‚
  â”‚       return memo[(i, ...)]                             â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

       "Counting ways vs Optimization?"
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
       â–¼             â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ COUNTING    â”‚   â”‚ OPTIMIZATIONâ”‚
  â”‚ return      â”‚   â”‚ return      â”‚
  â”‚ solve(a) +  â”‚   â”‚ max/min(    â”‚
  â”‚ solve(b)    â”‚   â”‚  take, skip â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ )           â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ DP Templates (Memoization)</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ House Robber (Take/Skip)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def rob(nums):
    memo = {}
    def solve(i):
        if i >= len(nums): return 0
        if i in memo: return memo[i]
        
        take = nums[i] + solve(i + 2)  # Take current, skip next
        skip = solve(i + 1)             # Skip current
        
        memo[i] = max(take, skip)
        return memo[i]
    return solve(0)
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Coin Change (Unbounded)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def coinChange(coins, amount):
    memo = {}
    def solve(remaining):
        if remaining == 0: return 0
        if remaining < 0: return float('inf')
        if remaining in memo: return memo[remaining]
        
        min_coins = float('inf')
        for coin in coins:
            min_coins = min(min_coins, solve(remaining - coin) + 1)
        
        memo[remaining] = min_coins
        return min_coins
    
    ans = solve(amount)
    return ans if ans != float('inf') else -1
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ LCS (Longest Common Subsequence)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def lcs(text1, text2):
    memo = {}
    def solve(i, j):
        if i == len(text1) or j == len(text2): return 0
        if (i, j) in memo: return memo[(i, j)]
        
        if text1[i] == text2[j]:
            memo[(i, j)] = 1 + solve(i + 1, j + 1)  # Match!
        else:
            memo[(i, j)] = max(solve(i + 1, j), solve(i, j + 1))  # Skip
        
        return memo[(i, j)]
    return solve(0, 0)
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ 0/1 Knapsack
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def knapsack(weights, values, capacity):
    memo = {}
    def solve(i, remaining):
        if i == len(weights) or remaining == 0: return 0
        if (i, remaining) in memo: return memo[(i, remaining)]
        
        skip = solve(i + 1, remaining)  # Skip current item
        take = 0
        if weights[i] <= remaining:
            take = values[i] + solve(i + 1, remaining - weights[i])
        
        memo[(i, remaining)] = max(take, skip)
        return memo[(i, remaining)]
    return solve(0, capacity)
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
5ï¸âƒ£ Unique Paths (Grid DP)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def uniquePaths(m, n):
    memo = {}
    def solve(i, j):
        if i == m - 1 and j == n - 1: return 1  # Reached destination
        if i >= m or j >= n: return 0           # Out of bounds
        if (i, j) in memo: return memo[(i, j)]
        
        # Can only go DOWN or RIGHT
        memo[(i, j)] = solve(i + 1, j) + solve(i, j + 1)
        return memo[(i, j)]
    return solve(0, 0)
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
6ï¸âƒ£ Longest Increasing Subsequence (LIS)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def lengthOfLIS(nums):
    memo = {}
    def solve(i, prev_idx):
        if i == len(nums): return 0
        if (i, prev_idx) in memo: return memo[(i, prev_idx)]
        
        skip = solve(i + 1, prev_idx)  # Skip current
        take = 0
        if prev_idx == -1 or nums[i] > nums[prev_idx]:
            take = 1 + solve(i + 1, i)  # Take current
        
        memo[(i, prev_idx)] = max(take, skip)
        return memo[(i, prev_idx)]
    return solve(0, -1)
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ“ Define dp[i]!", desc: "Clearly write what dp[i] represents BEFORE coding" },
            { label: "ğŸ”¢ Base cases!", desc: "<code>dp[0]</code> initialization â€” don't skip!" },
            { label: "ğŸ”„ Loop direction!", desc: "0/1 Knapsack: REVERSE loop. Unbounded: FORWARD loop" },
            { label: "âš¡ Space optimize!", desc: "2D â†’ 1D: Use only prev row. Often just 2 variables!" },
            { label: "ğŸ“Š Counting vs Opt!", desc: "Counting: <code>+=</code>. Optimization: <code>min()/max()</code>" },
            { label: "ğŸ¯ Don't overthink!", desc: "Most DP = Take vs Skip: <code>max(take, skip)</code>" }
        ]
    },
    questions: [
        {
            id: "house-robber",
            title: "House Robber",
            leetcodeUrl: "https://leetcode.com/problems/house-robber/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["1D DP", "Space Optimization"],
            quiz: {
                description: "Max loot, can't rob adjacent houses. What's the recurrence?",
                options: ["`max(nums[i] + dp[i-2], dp[i-1])`", "`nums[i] + dp[i-1]`", "`max(nums[i], dp[i-1])`", "Greedy (pick largest)"],
                correct: 0,
                explanation: "At each house: Either ROB it (take money + skip previous) OR SKIP it (keep previous max). Compare and take maximum!"
            },
            learn: {
                quickAlgo: [
                    "rob1, rob2 = 0, 0                  # ğŸ¯ Space Optimization: Only 2 vars needed",
                    "for n in nums:",
                    "    new_rob = max(rob1 + n, rob2)  # âš¡ Decision: Rob current (n + prev_prev) vs Skip (prev)",
                    "    rob1 = rob2                    # ğŸ”„ Shift window forward",
                    "    rob2 = new_rob                 # âœ… Update max loot found so far",
                    "return rob2"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                timeExplainer: `<strong>Time Breakdown:</strong><br>
                    â€¢ Single pass through all N houses<br>
                    â€¢ Constant O(1) work at each house (just max comparison)<br>
                    <br><strong>Total:</strong> <code>O(N)</code>`,
                spaceExplainer: `<strong>Space Optimization Journey:</strong><br>
                    â€¢ <strong>Naive:</strong> O(N) dp array<br>
                    â€¢ <strong>Optimized:</strong> Only 2 variables needed!<br>
                    â€¢ Why? dp[i] only depends on dp[i-1] and dp[i-2]<br>
                    <br><strong>Result:</strong> <code>O(1)</code> space`,
                visual: `<div style="background: #1e293b; padding: 20px; border-radius: 12px; margin: 15px 0;">
                    <strong style="color: #a78bfa;">ğŸ  The Thief's Decision Tree</strong><br><br>
                    <code style="color: #4ade80;">
                    At House[i]:<br>
                    â”œâ”€â”€ ROB it  â†’ Take nums[i] + best from 2 houses ago<br>
                    â””â”€â”€ SKIP it â†’ Keep best from previous house<br><br>
                    Answer = max(ROB, SKIP)
                    </code>
                </div>`,
                crux: `<strong style="color:#f59e0b;">ğŸ”‘ Key Insight:</strong><br>
                    <strong>Adjacent constraint = "Gap of 1" pattern</strong><br><br>
                    
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>The Recurrence:</strong><br>
                    <code>max_loot_at[i] = max(nums[i] + max_loot_at[i-2], max_loot_at[i-1])</code><br><br>
                    
                    <strong>In Words:</strong><br>
                    â€¢ ROB current = current money + best from 2 houses ago<br>
                    â€¢ SKIP current = best from previous house<br>
                    â€¢ Take maximum of both choices
                    </div>
                    
                    <br><strong style="color:#22d3ee;">ğŸ’¡ Same Pattern Problems:</strong><br>
                    â€¢ <strong>Climbing Stairs</strong> - ways[i] = ways[i-1] + ways[i-2]<br>
                    â€¢ <strong>Fibonacci</strong> - fib[i] = fib[i-1] + fib[i-2]<br>
                    â€¢ <strong>House Robber II</strong> - Same but circular array`,
                trap: `<strong style="color:#ef4444;">âš ï¸ Common Traps:</strong><br><br>
                    
                    <strong>1. Greedy Fails:</strong><br>
                    <code>[2, 1, 1, 2]</code> â†’ Greedy picks 2+2=4, but optimal is 2+2=4 âœ“... wait<br>
                    <code>[1, 3, 1, 3, 100]</code> â†’ Greedy picks 3+100=103, but optimal is 1+1+100=102... wait<br>
                    Actually: <code>[2, 7, 9, 3, 1]</code> â†’ Greedy might pick 9, missing 2+9+1=12<br><br>
                    
                    <strong>2. Edge Cases to Handle:</strong><br>
                    â€¢ Empty array â†’ return 0<br>
                    â€¢ Single house â†’ return nums[0]<br>
                    â€¢ Two houses â†’ return max(nums[0], nums[1])`,
                dryRun: [
                    `<strong>Input:</strong> nums = [1, 2, 3, 1]`,
                    `<strong>Initialize:</strong><br>
                    â€¢ prev_prev_max = 0 (no houses robbed yet)<br>
                    â€¢ prev_max = 0`,
                    `<strong>House 0 (money=1):</strong><br>
                    â€¢ ROB: 1 + prev_prev_max = 1 + 0 = 1<br>
                    â€¢ SKIP: prev_max = 0<br>
                    â€¢ current_max = max(1, 0) = <span style="color:#4ade80;">1</span>`,
                    `<strong>House 1 (money=2):</strong><br>
                    â€¢ ROB: 2 + 0 = 2<br>
                    â€¢ SKIP: 1<br>
                    â€¢ current_max = max(2, 1) = <span style="color:#4ade80;">2</span>`,
                    `<strong>House 2 (money=3):</strong><br>
                    â€¢ ROB: 3 + 1 = 4<br>
                    â€¢ SKIP: 2<br>
                    â€¢ current_max = max(4, 2) = <span style="color:#4ade80;">4</span>`,
                    `<strong>House 3 (money=1):</strong><br>
                    â€¢ ROB: 1 + 2 = 3<br>
                    â€¢ SKIP: 4<br>
                    â€¢ current_max = max(3, 4) = <span style="color:#4ade80;">4</span>`,
                    `<strong>Answer:</strong> 4 (robbed houses 0 and 2 â†’ 1+3=4)`
                ],
                codeTitle: "Evolution: DP Table â†’ Space Optimized",
                code: `##### Approach 1: DP Table (O(n) space)
def rob_dp_table(nums):
if not nums:
    return 0
if len(nums) == 1:
    return nums[0]

# dp[i] = max loot we can get from houses 0 to i
dp = [0] * len(nums)
dp[0] = nums[0]
dp[1] = max(nums[0], nums[1])

for house_index in range(2, len(nums)):
    rob_current = nums[house_index] + dp[house_index - 2]
    skip_current = dp[house_index - 1]
    dp[house_index] = max(rob_current, skip_current)

return dp[-1]


##### Approach 2: Space Optimized (O(1) space) âœ… BEST
def rob(nums):
"""
Key insight: We only need previous 2 values!
prev_prev_max = max loot from 2 houses ago
prev_max = max loot from previous house
"""
if not nums:
    return 0
if len(nums) == 1:
    return nums[0]

prev_prev_max = 0  # Best loot from 2 houses back
prev_max = 0       # Best loot from 1 house back

for current_money in nums:
    # Decision: rob current house or skip it?
    rob_current = current_money + prev_prev_max
    skip_current = prev_max
    current_max = max(rob_current, skip_current)
    
    # Shift window forward
    prev_prev_max = prev_max
    prev_max = current_max

return prev_max


# Test cases
print(rob([1,2,3,1]))     # 4 (rob house 0 + house 2)
print(rob([2,7,9,3,1]))   # 12 (rob house 0 + house 2 + house 4)
print(rob([]))            # 0 (edge case)
print(rob([100]))         # 100 (single house)`
            }
        },
        {
            id: "longest-increasing-subsequence",
            title: "LIS",
            leetcodeUrl: "https://leetcode.com/problems/longest-increasing-subsequence/",
            visualizerUrl: "visualizers/lis.html",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["DP + Binary Search", "Take/Skip Pattern"],
            quiz: {
                description: "Find length of LIS. O(N log N) approach?",
                options: ["Standard DP O(NÂ²)", "Patience Sorting / Tails Array", "Sliding Window", "Recursion"],
                correct: 1,
                explanation: "Patience Sorting! Maintain a 'tails' array. For each x, replace the first element in tails >= x. If x is largest, append. Len(tails) is answer."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>NlogN kaise?</strong> Patience sorting â€” solitaire card game strategy",
                    "âš¡ <code>tails</code> array: smallest ending element for LIS of length i+1",
                    "ğŸ”„ Binary Search: Find insertion point of current num in <code>tails</code>",
                    "âœ… Extend: append if largest; Replace: existing bada element chote se replace karo",
                    "ğŸ’¡ Replace kyun? Smaller ending value gives better chance to extend later!"
                ],
                metrics: { time: "O(NÂ²)", space: "O(NÂ²)" },
                timeExplainer: `<strong style="color:#f59e0b;">â±ï¸ Time Complexity Deep Dive</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">1. Brute Force Recursion: O(2â¿)</strong><br><br>
                    <strong>Why 2â¿?</strong><br>
                    â€¢ Har element pe 2 branches: <strong>TAKE</strong> or <strong>SKIP</strong><br>
                    â€¢ n elements = 2 Ã— 2 Ã— 2... (n times) = 2â¿<br>
                    â€¢ Like generating all subsets!<br><br>
                    <code style="color:#f87171;">Result: TLE for n > 20 âŒ</code>
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#10b981;">2. With Memoization: O(NÂ²)</strong><br><br>
                    <strong>Why NÂ²?</strong><br>
                    â€¢ States = (curr_idx, prev_idx)<br>
                    â€¢ curr_idx: 0 to n-1 â†’ N possibilities<br>
                    â€¢ prev_idx: -1 to n-1 â†’ N possibilities<br>
                    â€¢ Total unique states = N Ã— N = NÂ²<br>
                    â€¢ Each state computed ONCE!<br><br>
                    <code style="color:#34d399;">Result: AC! âœ…</code>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #8b5cf6;">
                    <strong style="color:#a78bfa;">3. Binary Search (Advanced): O(N log N)</strong><br><br>
                    â€¢ Patience Sorting technique<br>
                    â€¢ For each element, binary search in 'tails' array<br>
                    â€¢ N elements Ã— log N search = O(N log N)
                </div>`,
                spaceExplainer: `<strong style="color:#22d3ee;">ğŸ“¦ Space Complexity Analysis</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">Recursion without Memo: O(N)</strong><br>
                    â€¢ Only call stack depth = max N frames<br>
                    â€¢ Each frame stores: curr_idx, prev_idx (constants)<br>
                    â€¢ Total: O(N) stack space
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
                    <strong style="color:#fbbf24;">With Memoization: O(NÂ²)</strong><br>
                    â€¢ memo dict stores (curr_idx, prev_idx) â†’ result<br>
                    â€¢ Max entries = N Ã— N = NÂ²<br>
                    â€¢ + Recursion stack O(N)<br>
                    â€¢ Total: O(NÂ²)
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#34d399;">Iterative 1D DP: O(N)</strong><br>
                    â€¢ dp[i] = LIS length ending at index i<br>
                    â€¢ Only 1 array of size N needed!
                </div>`,
                visual: `<div style="background: #1e293b; padding: 20px; border-radius: 12px; margin: 15px 0;">
                    <strong style="color: #a78bfa;">ğŸ§  State Design: "Prev Index Yaad Rakhna Hai!"</strong><br><br>
                    <code style="color: #4ade80;">
                    dfs(curr_idx, prev_idx):<br><br>
                    
                    â”œâ”€â”€ Can we TAKE nums[curr_idx]?<br>
                    â”‚   â””â”€â”€ Only if prev_idx == -1 OR nums[curr_idx] > nums[prev_idx]<br>
                    â”‚       â””â”€â”€ TAKE: 1 + dfs(curr_idx+1, curr_idx)  # prev becomes current<br>
                    â”‚<br>
                    â””â”€â”€ We can always SKIP<br>
                        â””â”€â”€ SKIP: dfs(curr_idx+1, prev_idx)  # prev stays same<br><br>
                    
                    Answer = max(TAKE, SKIP)
                    </code>
                </div>`,
                crux: `<strong style="color:#f59e0b;">ğŸ”‘ Key Insight: "Prev Yaad Rakhna Hai"</strong><br><br>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>Why Two States?</strong><br>
                    â€¢ <code>curr_idx</code>: Where we are now<br>
                    â€¢ <code>prev_idx</code>: Last element we TOOK (for comparison)<br><br>
                    
                    Without prev_idx, we can't check if current > previous!
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>The Core Logic:</strong><br>
                    <code>if nums[curr_idx] > nums[prev_idx]:</code><br>
                    &nbsp;&nbsp;<code>take = 1 + dfs(curr_idx+1, curr_idx)</code><br>
                    <code>skip = dfs(curr_idx+1, prev_idx)</code><br>
                    <code>return max(take, skip)</code>
                </div>
                
                <br><strong style="color:#22d3ee;">ğŸ’¡ Same Pattern Problems:</strong><br>
                â€¢ <strong>Russian Doll Envelopes</strong> - 2D LIS (sort + LIS on heights)<br>
                â€¢ <strong>Maximum Length of Pair Chain</strong> - LIS variant<br>
                â€¢ <strong>Number of LIS</strong> - Count instead of length`,
                trap: `<strong style="color:#ef4444;">âš ï¸ Common Traps:</strong><br><br>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#f87171;">âŒ Forgetting prev_idx = -1</strong><br>
                        <span style="font-size: 0.9rem;">Initial prev is -1 (fictional -âˆ) so first element can always be taken</span>
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#fbbf24;">âŒ Subsequence â‰  Subarray</strong><br>
                        <span style="font-size: 0.9rem;">Elements don't need to be contiguous! [10,9,2,5,3,7,101] â†’ [2,5,7,101]</span>
                    </div>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 12px; border-radius: 8px; margin-top: 15px;">
                    <strong style="color:#a78bfa;">âŒ Wrong memo key</strong><br>
                    Key must be <code>(curr_idx, prev_idx)</code> not just <code>curr_idx</code>!<br>
                    Same curr_idx with different prev_idx gives different results.
                </div>`,
                dryRun: [
                    `<strong>Input:</strong> nums = [10, 9, 2, 5, 3, 7, 101, 18]`,
                    `<strong>Call:</strong> dfs(curr_idx=0, prev_idx=-1)<br>
                    â€¢ prev=-1 means "no element taken yet"<br>
                    â€¢ We can take nums[0]=10 (always allowed when prev=-1)`,
                    `<strong>Exploring from 10:</strong><br>
                    â€¢ TAKE 10: dfs(1, 0) â†’ need nums[1] > 10 to take<br>
                    â€¢ 9 < 10, 2 < 10... stuck!<br>
                    â€¢ Better to start with smaller number`,
                    `<strong>Better path: Start with 2 (index 2)</strong><br>
                    â€¢ SKIP 10, SKIP 9, TAKE 2<br>
                    â€¢ Now prev_idx = 2, nums[prev_idx] = 2`,
                    `<strong>Continue from 2:</strong><br>
                    â€¢ 5 > 2 âœ… â†’ TAKE, LIS = [2, 5]<br>
                    â€¢ 3 > 5 âŒ â†’ Can't take<br>
                    â€¢ 7 > 5 âœ… â†’ TAKE, LIS = [2, 5, 7]<br>
                    â€¢ 101 > 7 âœ… â†’ TAKE, LIS = [2, 5, 7, 101]`,
                    `<strong>Answer:</strong> 4<br>
                    One valid LIS: [2, 5, 7, 101]<br>
                    Another: [2, 3, 7, 101] (same length)`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ Iterative DP",
                code: `##### Approach 1: Brute Recursion - O(2^n) TLE!
def lis_brute(nums):
"""
Two states: curr_idx (where we are) and prev_idx (last taken element)
Key insight: "prev yaad rakhna hai" for comparison!
"""
def dfs(curr_idx, prev_idx):
    # Base: no more elements
    if curr_idx == len(nums):
        return 0
    
    # Option 1: TAKE current (only if increasing)
    take = 0
    if prev_idx == -1 or nums[curr_idx] > nums[prev_idx]:
        take = 1 + dfs(curr_idx + 1, curr_idx)  # curr becomes new prev
    
    # Option 2: SKIP current (always allowed)
    skip = dfs(curr_idx + 1, prev_idx)  # prev stays same
    
    return max(take, skip)

return dfs(0, -1)  # Start with prev = -1 (fictional -âˆ)


##### Approach 2: Memoization - O(NÂ²) âœ…
def lis_memo(nums):
memo = {}  # Key: (curr_idx, prev_idx)

def dfs(curr_idx, prev_idx):
    if curr_idx == len(nums):
        return 0
    
    # Check memo BEFORE computing
    if (curr_idx, prev_idx) in memo:
        return memo[(curr_idx, prev_idx)]
    
    # TAKE if increasing
    take = 0
    if prev_idx == -1 or nums[curr_idx] > nums[prev_idx]:
        take = 1 + dfs(curr_idx + 1, curr_idx)
    
    # SKIP always allowed
    skip = dfs(curr_idx + 1, prev_idx)
    
    result = max(take, skip)
    memo[(curr_idx, prev_idx)] = result  # Store AFTER computing
    return result

return dfs(0, -1)


##### Approach 3: Iterative DP - O(NÂ²) time, O(N) space
def lengthOfLIS(nums):
if not nums:
    return 0

# dp[i] = length of LIS ENDING at index i
dp = [1] * len(nums)  # Each element is LIS of length 1

for curr_idx in range(1, len(nums)):
    for prev_idx in range(curr_idx):
        if nums[curr_idx] > nums[prev_idx]:
            dp[curr_idx] = max(dp[curr_idx], 1 + dp[prev_idx])

return max(dp)  # LIS can end at any index


# Test
print(lis_memo([10,9,2,5,3,7,101,18]))  # 4 â†’ [2,5,7,101]
print(lengthOfLIS([0,1,0,3,2,3]))       # 4 â†’ [0,1,2,3]`
            }
        },
        {
            id: "longest-common-subsequence",
            title: "LCS",
            leetcodeUrl: "https://leetcode.com/problems/longest-common-subsequence/",
            visualizerUrl: "visualizers/lcs.html",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["2D DP", "Two-String Pattern"],
            quiz: {
                description: "Longest common subsequence in two strings. Logic?",
                options: ["Substring matching", "If match: 1 + diag. Else: max(up, left)", "Greedy", "HashMaps"],
                correct: 1,
                explanation: "2D Grid! If chars match: `1 + dp[i-1][j-1]`. If no match: `max(dp[i-1][j], dp[i][j-1])` (carry forward best result)."
            },
            learn: {
                quickAlgo: [
                    "if s1[i] == s2[j]:                 # ğŸ¯ Characters MATCH",
                    "    return 1 + solve(i+1, j+1)     # âš¡ Add 1, move both pointers diagonally",
                    "else:                              # ğŸ”„ NO MATCH",
                    "    return max(solve(i+1, j),      # âœ… Skip s1 char",
                    "               solve(i, j+1))      #    Skip s2 char"
                ],
                metrics: { time: "O(M Ã— N)", space: "O(M Ã— N)" },
                timeExplainer: `<strong style="color:#f59e0b;">â±ï¸ Time Complexity Deep Dive</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">1. Brute Force Recursion: O(2^(m+n))</strong><br><br>
                    <strong>Why 2^(m+n)?</strong><br>
                    â€¢ Worst case: NO characters match<br>
                    â€¢ At each step, we branch into 2: skip from text1 OR skip from text2<br>
                    â€¢ Max depth = m + n (go through both strings)<br>
                    â€¢ Total branches = 2^(m+n)<br><br>
                    <code style="color:#f87171;">Result: TLE for strings > 20 chars âŒ</code>
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#10b981;">2. With Memoization: O(M Ã— N)</strong><br><br>
                    <strong>Why M Ã— N?</strong><br>
                    â€¢ States = (index1, index2)<br>
                    â€¢ index1: 0 to m â†’ M values<br>
                    â€¢ index2: 0 to n â†’ N values<br>
                    â€¢ Total unique states = M Ã— N<br>
                    â€¢ Each state computed ONCE!<br><br>
                    <code style="color:#34d399;">Example: "abcde" vs "ace" â†’ 5Ã—3 = 15 states âœ…</code>
                </div>`,
                spaceExplainer: `<strong style="color:#22d3ee;">ğŸ“¦ Space Complexity Analysis</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">Recursion Stack: O(M + N)</strong><br>
                    â€¢ Max depth = m + n (worst case go through both)<br>
                    â€¢ Each frame: index1, index2 (constants)
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
                    <strong style="color:#fbbf24;">With Memoization: O(M Ã— N)</strong><br>
                    â€¢ memo[(index1, index2)] stores result<br>
                    â€¢ Max entries = M Ã— N<br>
                    â€¢ + Recursion stack O(M + N)
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#34d399;">Space Optimized: O(min(M, N))</strong><br>
                    â€¢ If only need length (not actual LCS)<br>
                    â€¢ Use rolling array (only previous row needed)
                </div>`,
                visual: `<div style="background: #1e293b; padding: 20px; border-radius: 12px; margin: 15px 0;">
                    <strong style="color: #a78bfa;">ğŸ”‘ Two Cases: Match vs No Match</strong><br><br>
                    <code style="color: #4ade80;">
                    def dfs(index1, index2):<br><br>
                    
                    &nbsp;&nbsp;# MATCH: Characters equal! Take it & move BOTH pointers<br>
                    &nbsp;&nbsp;if text1[index1] == text2[index2]:<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;return <span style="color:#fbbf24;">1</span> + dfs(index1+1, index2+1)  <span style="color:#94a3b8;">â† Only ONE choice!</span><br><br>
                    
                    &nbsp;&nbsp;# NO MATCH: Try skipping from EITHER string<br>
                    &nbsp;&nbsp;skip_text1 = dfs(index1+1, index2)  <span style="color:#94a3b8;">â† Skip char from text1</span><br>
                    &nbsp;&nbsp;skip_text2 = dfs(index1, index2+1)  <span style="color:#94a3b8;">â† Skip char from text2</span><br>
                    &nbsp;&nbsp;return max(skip_text1, skip_text2)
                    </code>
                </div>`,
                crux: `<strong style="color:#f59e0b;">ğŸ”‘ Key Insight: "Match = No Choice, No Match = Try Both"</strong><br><br>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong style="color:#34d399;">When Characters MATCH:</strong><br>
                    â€¢ Take the match! Move BOTH pointers forward<br>
                    â€¢ <code>return 1 + dfs(i+1, j+1)</code><br>
                    â€¢ No "Lun Na Lun" here - always take the match!
                </div>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong style="color:#f87171;">When Characters DON'T Match:</strong><br>
                    â€¢ Can't match both - try skipping from either string<br>
                    â€¢ <code>skip1 = dfs(i+1, j)</code> â† Skip from text1<br>
                    â€¢ <code>skip2 = dfs(i, j+1)</code> â† Skip from text2<br>
                    â€¢ <code>return max(skip1, skip2)</code>
                </div>
                
                <br><strong style="color:#22d3ee;">ğŸ’¡ Same Pattern Problems:</strong><br>
                â€¢ <strong>Edit Distance</strong> - Min operations to convert (same 2-string pattern)<br>
                â€¢ <strong>Shortest Common Supersequence</strong> - Based on LCS!<br>
                â€¢ <strong>Longest Palindromic Subsequence</strong> - LCS(s, reverse(s))`,
                trap: `<strong style="color:#ef4444;">âš ï¸ Common Traps:</strong><br><br>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#f87171;">âŒ Subsequence â‰  Substring</strong><br>
                        <span style="font-size: 0.9rem;">Subsequence: Can skip chars, order preserved<br>
                        Substring: Contiguous, no skips allowed</span>
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#fbbf24;">âŒ Wrong base case</strong><br>
                        <span style="font-size: 0.9rem;">Return 0 when EITHER string ends<br>
                        Not when both end!</span>
                    </div>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 12px; border-radius: 8px; margin-top: 15px;">
                    <strong style="color:#a78bfa;">âŒ Thinking it's "Lun Na Lun"</strong><br>
                    When chars MATCH, there's NO choice to make - always take the match!<br>
                    "Lun Na Lun" only applies when chars DON'T match.
                </div>`,
                dryRun: [
                    `<strong>Input:</strong> text1 = "abcde", text2 = "ace"`,
                    `<strong>Call:</strong> dfs(index1=0, index2=0)<br>
                    â€¢ text1[0] = 'a', text2[0] = 'a'<br>
                    â€¢ MATCH! â†’ 1 + dfs(1, 1)`,
                    `<strong>dfs(1, 1):</strong><br>
                    â€¢ text1[1] = 'b', text2[1] = 'c'<br>
                    â€¢ NO MATCH â†’ try both:<br>
                    &nbsp;&nbsp;â€¢ skip 'b': dfs(2, 1)<br>
                    &nbsp;&nbsp;â€¢ skip 'c': dfs(1, 2)`,
                    `<strong>dfs(2, 1):</strong> text1[2]='c', text2[1]='c'<br>
                    â€¢ MATCH! â†’ 1 + dfs(3, 2)<br><br>
                    <strong>dfs(3, 2):</strong> text1[3]='d', text2[2]='e'<br>
                    â€¢ NO MATCH â†’ try both... eventually finds 'e' at dfs(4, 2)`,
                    `<strong>dfs(4, 2):</strong> text1[4]='e', text2[2]='e'<br>
                    â€¢ MATCH! â†’ 1 + dfs(5, 3)<br>
                    â€¢ dfs(5, 3) â†’ index1 == len(text1) â†’ return 0`,
                    `<strong>Answer:</strong> 3<br>
                    LCS = "ace" (matched at positions 0, 2, 4)`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ 2D DP",
                code: `##### Approach 1: Brute Recursion - O(2^(m+n)) TLE!
def lcs_brute(text1, text2):
"""
Two pointers: index1 for text1, index2 for text2
Key: When match, NO choice - must take it!
"""
def dfs(index1, index2):
    # Base: Either string exhausted
    if index1 == len(text1) or index2 == len(text2):
        return 0
    
    # MATCH: Take it and move BOTH pointers
    if text1[index1] == text2[index2]:
        return 1 + dfs(index1 + 1, index2 + 1)
    
    # NO MATCH: Try skipping from either string
    skip_text1 = dfs(index1 + 1, index2)
    skip_text2 = dfs(index1, index2 + 1)
    
    return max(skip_text1, skip_text2)

return dfs(0, 0)


##### Approach 2: Memoization - O(M Ã— N) âœ…
def longestCommonSubsequence(text1, text2):
memo = {}  # Key: (index1, index2)

def dfs(index1, index2):
    # Base: Either string exhausted
    if index1 == len(text1) or index2 == len(text2):
        return 0
    
    # Check memo
    if (index1, index2) in memo:
        return memo[(index1, index2)]
    
    # MATCH: Take it!
    if text1[index1] == text2[index2]:
        result = 1 + dfs(index1 + 1, index2 + 1)
    else:
        # NO MATCH: Try both skips
        skip_text1 = dfs(index1 + 1, index2)
        skip_text2 = dfs(index1, index2 + 1)
        result = max(skip_text1, skip_text2)
    
    memo[(index1, index2)] = result
    return result

return dfs(0, 0)


##### Approach 3: 2D DP (Bottom-Up) â­ï¸
def longestCommonSubsequence_DP(text1, text2):
m, n = len(text1), len(text2)
# dp[i][j] = LCS of text1[0:i] and text2[0:j]
dp = [[0] * (n + 1) for _ in range(m + 1)]

for i in range(1, m + 1):
    for j in range(1, n + 1):
        if text1[i - 1] == text2[j - 1]:
            # MATCH: 1 + diagonal
            dp[i][j] = 1 + dp[i - 1][j - 1]
        else:
            # NO MATCH: max of up or left
            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

return dp[m][n]


# Test
print(longestCommonSubsequence("abcde", "ace"))  # 3 â†’ "ace"`
            }
        },
        {
            id: "coin-change",
            title: "Coin Change",
            leetcodeUrl: "https://leetcode.com/problems/coin-change/",
            visualizerUrl: "visualizers/min_coins.html",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Unbounded Knapsack", "Infinite Supply"],
            quiz: {
                description: "Fewest coins to make amount. Trick?",
                options: ["Greedy (biggest coins first)", "DP: dp[a] = min(dp[a], 1 + dp[a-c])", "Backtracking", "BFS"],
                correct: 1,
                explanation: "Greedy fails (e.g., Coins [1,3,4], Target 6. Greedy 4+1+1 (3 coins). Optimal 3+3 (2 coins)). Use DP: solve for amount 1, then 2..."
            },
            learn: {
                quickAlgo: [
                    "dp = [inf] * (amount + 1); dp[0]=0 # ğŸ¯ Min coins to reach 'i' amount",
                    "for a in range(1, amount+1):",
                    "    for c in coins:",
                    "        if a - c >= 0:             # âš¡ Can we use this coin?",
                    "            dp[a] = min(dp[a], 1 + dp[a-c]) # ğŸ”„ Update min cost",
                    "return dp[amount] if != inf else -1"
                ],
                metrics: { time: "O(A Ã— C)", space: "O(A Ã— C)" },
                timeExplainer: `<strong style="color:#f59e0b;">â±ï¸ Time Complexity Deep Dive</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">1. Brute Force Recursion: O(n^amount) or worse! ğŸ”¥</strong><br><br>
                    <strong>Why so bad?</strong><br>
                    â€¢ Each coin can be taken UNLIMITED times (unbounded)<br>
                    â€¢ Worst case: coin = 1, amount = 100<br>
                    â€¢ Depth = amount/min_coin = 100 (if smallest coin is 1)<br>
                    â€¢ At each level, we have n coin choices<br>
                    â€¢ Total: O(n^(amount/min_coin))<br><br>
                    <code style="color:#f87171;">Result: TLE for amount > 20 âŒ</code>
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#10b981;">2. With Memoization: O(Amount Ã— Coins)</strong><br><br>
                    <strong>Why Amount Ã— Coins?</strong><br>
                    â€¢ States = (remaining_amount, coin_index)<br>
                    â€¢ amount: 0 to amount â†’ A values<br>
                    â€¢ index: 0 to n-1 â†’ n values<br>
                    â€¢ Total unique states = A Ã— n<br>
                    â€¢ Each state computed ONCE!<br><br>
                    <code style="color:#34d399;">Example: amount=100, coins=3 â†’ 300 states âœ…</code>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #8b5cf6;">
                    <strong style="color:#a78bfa;">3. 1D DP: O(Amount Ã— Coins)</strong><br><br>
                    â€¢ For each amount from 1 to A: O(A)<br>
                    â€¢ Try each coin: O(C)<br>
                    â€¢ Total: O(A Ã— C)
                </div>`,
                spaceExplainer: `<strong style="color:#22d3ee;">ğŸ“¦ Space Complexity Analysis</strong>
                
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #ef4444;">
                    <strong style="color:#ef4444;">Recursion Stack: O(Amount/min_coin)</strong><br>
                    â€¢ Worst case: taking coin=1 repeatedly<br>
                    â€¢ Max depth = amount (if smallest coin is 1)<br>
                    â€¢ Each frame: amount, index (constants)
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #f59e0b;">
                    <strong style="color:#fbbf24;">With Memoization: O(Amount Ã— Coins)</strong><br>
                    â€¢ memo[(amount, index)] stores result<br>
                    â€¢ Max entries = A Ã— n<br>
                    â€¢ + Recursion stack O(A)
                </div>
                
                <div style="background: rgba(16, 185, 129, 0.1); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #10b981;">
                    <strong style="color:#34d399;">1D DP: O(Amount) âœ… BEST</strong><br>
                    â€¢ Only need dp array of size amount+1<br>
                    â€¢ dp[i] = min coins to make amount i
                </div>`,
                visual: `<div style="background: #1e293b; padding: 20px; border-radius: 12px; margin: 15px 0;">
                    <strong style="color: #a78bfa;">ğŸ”‘ CRITICAL: UNBOUNDED vs 0/1 Knapsack</strong><br><br>
                    <code style="color: #4ade80;">
                    # UNBOUNDED (Coin Change) - Infinite supply<br>
                    take = 1 + dfs(amount - coins[index], <span style="color:#f87171;">index</span>)  <span style="color:#94a3b8;">â† STAY at same index!</span><br><br>
                    
                    # 0/1 Knapsack - Each item once<br>
                    take = 1 + dfs(amount - items[index], <span style="color:#f87171;">index + 1</span>)  <span style="color:#94a3b8;">â† MOVE to next!</span>
                    </code><br><br>
                    <span style="color:#fbbf24;">âš ï¸ This ONE difference changes everything!</span>
                </div>`,
                crux: `<strong style="color:#f59e0b;">ğŸ”‘ Key Insight: "STAY at Same Index = Infinite Supply"</strong><br><br>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <strong>The Core Logic:</strong><br><br>
                    <code>def dfs(remaining_amount, coin_index):</code><br>
                    &nbsp;&nbsp;<code>if remaining_amount == 0: return 0  # No more coins needed</code><br>
                    &nbsp;&nbsp;<code>if coin_index == len(coins): return inf  # No coins left</code><br><br>
                    
                    &nbsp;&nbsp;<code># TAKE: Use this coin, STAY at same index (can reuse!)</code><br>
                    &nbsp;&nbsp;<code>take = 1 + dfs(amount - coins[index], index)</code><br><br>
                    
                    &nbsp;&nbsp;<code># SKIP: Don't use this coin, move to next</code><br>
                    &nbsp;&nbsp;<code>skip = dfs(amount, index + 1)</code><br><br>
                    
                    &nbsp;&nbsp;<code>return min(take, skip)</code>
                </div>
                
                <br><strong style="color:#22d3ee;">ğŸ’¡ Same Pattern Problems:</strong><br>
                â€¢ <strong>Coin Change II</strong> - Count ways (not min coins)<br>
                â€¢ <strong>Unbounded Knapsack</strong> - Max value with infinite items<br>
                â€¢ <strong>Rod Cutting</strong> - Max profit cutting rod`,
                trap: `<strong style="color:#ef4444;">âš ï¸ Common Traps:</strong><br><br>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: rgba(239, 68, 68, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#f87171;">âŒ Greedy Fails!</strong><br>
                        <span style="font-size: 0.9rem;">Coins=[1,3,4], Target=6<br>
                        Greedy: 4+1+1 = 3 coins âŒ<br>
                        DP: 3+3 = 2 coins âœ…</span>
                    </div>
                    <div style="background: rgba(245, 158, 11, 0.1); padding: 12px; border-radius: 8px;">
                        <strong style="color:#fbbf24;">âŒ Wrong Initialization</strong><br>
                        <span style="font-size: 0.9rem;">dp = [0] * (amount+1) âŒ<br>
                        dp = [inf] * (amount+1) âœ…<br>
                        dp[0] = 0 (base case)</span>
                    </div>
                </div>
                
                <div style="background: rgba(139, 92, 246, 0.1); padding: 12px; border-radius: 8px; margin-top: 15px;">
                    <strong style="color:#a78bfa;">âŒ Confusing 0/1 with Unbounded</strong><br>
                    When TAKING: <code>dfs(amt - coin, index)</code> NOT <code>dfs(amt - coin, index+1)</code>!<br>
                    STAY at same index means we can take same coin again.
                </div>`,
                dryRun: [
                    `<strong>Input:</strong> coins = [1, 2, 5], amount = 11`,
                    `<strong>Call:</strong> dfs(remaining=11, index=0)<br>
                    â€¢ Coins available: [1, 2, 5]<br>
                    â€¢ Need to find MINIMUM coins to make 11`,
                    `<strong>Key Decisions:</strong><br>
                    â€¢ TAKE coin[0]=1: dfs(10, 0) â†’ can take 1 again (unlimited!)<br>
                    â€¢ SKIP coin[0]=1: dfs(11, 1) â†’ try coin 2`,
                    `<strong>Optimal Path Found:</strong><br>
                    â€¢ Take 5: remaining = 6, coins = 1<br>
                    â€¢ Take 5: remaining = 1, coins = 2<br>
                    â€¢ Take 1: remaining = 0, coins = 3 âœ…<br>
                    â€¢ 5 + 5 + 1 = 11 with 3 coins`,
                    `<strong>Answer:</strong> 3<br>
                    One valid combination: [5, 5, 1]<br>
                    Another: [5, 2, 2, 2] = 4 coins (not optimal)`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ 1D DP",
                code: `##### Approach 1: Brute Recursion - O(n^amount) TLE!
def coin_change_brute(coins, amount):
"""
UNBOUNDED: When taking a coin, STAY at same index!
"""
def dfs(remaining_amount, coin_index):
    # Base: Exact amount made
    if remaining_amount == 0:
        return 0
    
    # Base: No coins left OR negative amount
    if coin_index == len(coins) or remaining_amount < 0:
        return float('inf')
    
    # TAKE: Use this coin, STAY at same index (unlimited supply!)
    take = float('inf')
    if remaining_amount >= coins[coin_index]:
        take = 1 + dfs(remaining_amount - coins[coin_index], coin_index)
    
    # SKIP: Move to next coin
    skip = dfs(remaining_amount, coin_index + 1)
    
    return min(take, skip)

result = dfs(amount, 0)
return result if result != float('inf') else -1


##### Approach 2: Memoization - O(Amount Ã— Coins) âœ…
def coinChange(coins, amount):
memo = {}  # Key: (remaining_amount, coin_index)

def dfs(remaining_amount, coin_index):
    if remaining_amount == 0:
        return 0
    if coin_index == len(coins) or remaining_amount < 0:
        return float('inf')
    
    state = (remaining_amount, coin_index)
    if state in memo:
        return memo[state]
    
    # TAKE (stay at index) or SKIP (move to next)
    take = float('inf')
    if remaining_amount >= coins[coin_index]:
        take = 1 + dfs(remaining_amount - coins[coin_index], coin_index)
    skip = dfs(remaining_amount, coin_index + 1)
    
    memo[state] = min(take, skip)
    return memo[state]

result = dfs(amount, 0)
return result if result != float('inf') else -1


##### Approach 3: 1D DP - O(Amount Ã— Coins) time, O(Amount) space â­ï¸
def coinChange_DP(coins, amount):
# dp[i] = min coins to make amount i
dp = [float('inf')] * (amount + 1)
dp[0] = 0  # Base: 0 coins to make 0

for target_amount in range(1, amount + 1):
    for coin in coins:
        if target_amount - coin >= 0:
            dp[target_amount] = min(dp[target_amount], 1 + dp[target_amount - coin])

return dp[amount] if dp[amount] != float('inf') else -1


# Test
print(coinChange([1,2,5], 11))  # 3 â†’ 5+5+1
print(coinChange([2], 3))       # -1 â†’ impossible`
            }
        },
        {
            id: "word-break",
            title: "Word Break",
            leetcodeUrl: "https://leetcode.com/problems/word-break/",
            visualizerUrl: "visualizers/word_break.html",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["String DP", "Dictionary"],
            quiz: {
                description: "Can string s be segmented into dictionary words?",
                options: ["Greedy matching", "DP: dp[i] is true if s[:i] can be segmented", "Backtracking O(2^N)", "Trie"],
                correct: 1,
                explanation: "Brute Force is O(2^N). We need DP! dp[i] = True if dp[j] is True AND s[j:i] in dict. Iterate i from 1 to N, j from 0 to i."
            },
            learn: {
                quickAlgo: [
                    "dp = [1] * n                       # ğŸ¯ dp[i] = Longest chain ending at i",
                    "for i in range(n):",
                    "    for j in range(i):             # âš¡ Check all previous elements",
                    "        if nums[i] > nums[j]:      # ğŸ”„ Can we extend the chain?",
                    "            dp[i] = max(dp[i], 1 + dp[j])",
                    "return max(dp)"
                ],
                metrics: { time: "O(NÂ³)", space: "O(N)" },
                timeExplainer: `
                    <div class="space-y-3">
                        <div class="bg-red-900/20 p-3 rounded-lg border border-red-500/30">
                            <p class="font-bold text-red-400 text-base">ğŸ”´ Brute Force (Recursion): O(2â¿)</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Kyun?</strong> Har character ke baad ek "cut" lag sakta hai ya nahi:</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
                                    l|e|e|t|c|o|d|e   â† 7 potential gaps<br>
                                    Cut? âœ“ or âœ— for each gap
                                </div>
                                
                                <p><strong>ğŸ“Š Math Breakdown:</strong></p>
                                <ul class="list-disc pl-4 space-y-1">
                                    <li>String length = N</li>
                                    <li>Potential gaps = <strong>N-1</strong> (between characters)</li>
                                    <li>Each gap: 2 choices (cut or don't cut)</li>
                                    <li>Total combinations = <strong>2^(N-1)</strong> â‰ˆ O(2â¿)</li>
                                </ul>
                                
                                <p><strong>ğŸ¯ Real Numbers:</strong></p>
                                <table class="w-full text-xs border-collapse">
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 10</td>
                                        <td class="text-yellow-400">512 ops âœ… Fast</td>
                                    </tr>
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 20</td>
                                        <td class="text-yellow-400">~1 Million ops âš ï¸ Borderline</td>
                                    </tr>
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 30</td>
                                        <td class="text-red-400">~1 Billion ops âŒ TLE</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">N = 50</td>
                                        <td class="text-red-400">~10Â¹âµ ops ğŸ’€ Universe Heat Death</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400 text-base">ğŸŸ¢ Memoization / DP: O(NÂ³)</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Why 2â¿ â†’ NÂ³?</strong></p>
                                
                                <p><strong>Step 1: Count Unique States</strong></p>
                                <div class="bg-black/30 p-2 rounded">
                                    <div class="font-mono text-xs">dfs(<span class="text-cyan-400">start</span>)</div>
                                    <div class="text-xs text-gray-400">Start index can only be: 0, 1, 2, ... N</div>
                                    <div class="text-cyan-400 font-bold">Unique States = N+1 â‰ˆ O(N)</div>
                                </div>
                                
                                <p class="mt-2"><strong>Step 2: Work per State</strong></p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
for end in range(start+1, len(s)+1):  <span class="text-yellow-400">â† O(N) iterations</span>
curr_word = s[start:end]           <span class="text-orange-400">â† O(N) slicing!</span>
                                </div>
                                
                                <p class="mt-2"><strong>ğŸ§® Final Calculation:</strong></p>
                                <div class="bg-black/30 p-2 rounded text-cyan-300">
                                    N states Ã— N loop Ã— N slicing = <strong class="text-green-400">O(NÂ³)</strong>
                                </div>
                                
                                <p class="mt-2"><strong>ğŸ’¡ Hidden Cost - Slicing:</strong></p>
                                <div class="bg-orange-900/20 p-2 rounded border border-orange-500/20">
                                    <div class="text-orange-400 font-bold text-xs">âš ï¸ DON'T FORGET!</div>
                                    <div class="text-xs">In Python/Java: <code>s[start:end]</code> creates NEW string</div>
                                    <div class="text-xs">This takes O(end - start) = O(N) time!</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                            <p class="font-bold text-purple-400 text-base">ğŸŸ£ Optimization: O(NÂ² Ã— M)</p>
                            <div class="mt-2 text-sm text-gray-300">
                                <p><strong>Using Trie or Word Length Bound:</strong></p>
                                <ul class="list-disc pl-4 text-xs space-y-1">
                                    <li>If max word length in dict = M (usually small)</li>
                                    <li>Instead of loop till N, loop only till M</li>
                                    <li>Time: O(N Ã— M Ã— M) = O(N Ã— MÂ²)</li>
                                </ul>
                            </div>
                        </div>
                    </div>`,
                spaceExplainer: `
                    <div class="space-y-3">
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-blue-400">1. Recursion Stack: O(N)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <p>Worst case: All single chars are valid words</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs mt-1">
s = "aaa" and dict = {"a"}<br>
dfs(0) â†’ dfs(1) â†’ dfs(2) â†’ dfs(3)<br>
<span class="text-yellow-400">Max depth = N</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-green-400">2. Memoization Cache: O(N)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
memo = {<br>
  0: True/False,   <span class="text-gray-500"># Can break from index 0?</span><br>
  1: True/False,   <span class="text-gray-500"># Can break from index 1?</span><br>
  ...<br>
  N-1: True/False  <span class="text-gray-500"># Can break from last char?</span><br>
}<br>
<span class="text-cyan-400">Size = N entries</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400">Total Space: O(N)</p>
                            <p class="text-sm text-gray-400">Both stack and cache are linear.</p>
                        </div>
                    </div>`,
                visual: `<div class="space-y-3">
                    <div class="text-center font-bold text-cyan-400">ğŸ”ª The Cut Strategy</div>
                    <div class="bg-black/30 p-3 rounded font-mono text-sm">
                        <div class="text-gray-400 mb-2">s = "leetcode", dict = ["leet", "code"]</div>
                        <div class="flex justify-center gap-1" style="font-size:12px;">
                            <span class="bg-green-500/30 px-2 py-1 rounded">l</span>
                            <span class="bg-green-500/30 px-2 py-1 rounded">e</span>
                            <span class="bg-green-500/30 px-2 py-1 rounded">e</span>
                            <span class="bg-green-500/30 px-2 py-1 rounded">t</span>
                            <span class="text-red-400 text-xl">|</span>
                            <span class="bg-blue-500/30 px-2 py-1 rounded">c</span>
                            <span class="bg-blue-500/30 px-2 py-1 rounded">o</span>
                            <span class="bg-blue-500/30 px-2 py-1 rounded">d</span>
                            <span class="bg-blue-500/30 px-2 py-1 rounded">e</span>
                        </div>
                        <div class="text-center mt-2" style="font-size:11px;">
                            <span class="text-green-400">"leet" âœ“</span> + 
                            <span class="text-blue-400">"code" âœ“</span> = 
                            <span class="text-yellow-400 font-bold">VALID!</span>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 text-center">
                        Find ONE valid cut position where:<br>
                        Left part is valid AND right part can be broken
                    </div>
                </div>`,
                crux: `<div class="space-y-3">
                    <div class="bg-cyan-900/20 p-3 rounded-lg border border-cyan-500/30">
                        <div class="font-bold text-cyan-400 mb-2">ğŸ¯ The "Cut or Extend" Logic</div>
                        <div class="bg-black/30 p-2 rounded font-mono text-xs">
for end in range(start + 1, len(s) + 1):  <span class="text-gray-500"># Try all ends</span><br>
word = s[start:end]<br>
<br>
if word in wordSet:    <span class="text-green-400"># Mila! CUT lagao</span><br>
    if dfs(end):       <span class="text-green-400"># Baki bhi valid?</span><br>
        return True<br>
<span class="text-gray-500"># Else: EXTEND karo (loop continues)</span>
                        </div>
                    </div>
                    
                    <div class="bg-yellow-900/20 p-3 rounded-lg border border-yellow-500/30">
                        <div class="font-bold text-yellow-400 mb-2">ğŸ’¡ Key Insight</div>
                        <p class="text-sm text-gray-300"><strong>STATE:</strong> Just the <code>start</code> index</p>
                        <p class="text-sm text-gray-300"><strong>DECISION:</strong> Where to cut (try all ends)</p>
                        <p class="text-sm text-gray-300"><strong>BASE CASE:</strong> start == len(s) â†’ True</p>
                    </div>
                    
                    <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                        <div class="font-bold text-purple-400 mb-2">ğŸ”— Same Pattern Problems</div>
                        <ul class="text-sm text-gray-300 space-y-1">
                            <li>â€¢ <strong>Word Break II</strong> - Return all valid segmentations</li>
                            <li>â€¢ <strong>Palindrome Partitioning</strong> - Cut where each part is palindrome</li>
                            <li>â€¢ <strong>Decode Ways</strong> - Valid number â†’ letter mappings</li>
                        </ul>
                    </div>
                </div>`,
                trap: `<div class="space-y-2">
                    <div class="bg-red-900/20 p-2 rounded border border-red-500/30">
                        <div class="font-bold text-red-400 text-sm">âŒ Trap 1: Complexity Confusion</div>
                        <p class="text-xs text-gray-300">Looks like O(N^N) due to nested loop, but it's O(2^N)!</p>
                        <p class="text-xs text-gray-400">Each gap has binary choice: cut or extend.</p>
                    </div>
                    
                    <div class="bg-orange-900/20 p-2 rounded border border-orange-500/30">
                        <div class="font-bold text-orange-400 text-sm">âŒ Trap 2: Slicing Cost Hidden</div>
                        <p class="text-xs text-gray-300"><code>s[start:end]</code> is NOT O(1)!</p>
                        <p class="text-xs text-gray-400">It's O(K) where K = substring length. Total = O(NÂ³)</p>
                    </div>
                    
                    <div class="bg-yellow-900/20 p-2 rounded border border-yellow-500/30">
                        <div class="font-bold text-yellow-400 text-sm">âŒ Trap 3: Wrong Loop Range</div>
                        <div class="bg-black/30 p-1 rounded font-mono text-xs mt-1">
<span class="text-red-400">âŒ range(start, len(s)+1)</span>  <span class="text-gray-500"># empty substring!</span><br>
<span class="text-green-400">âœ… range(start+1, len(s)+1)</span> <span class="text-gray-500"># at least 1 char</span>
                        </div>
                    </div>
                    
                    <div class="bg-blue-900/20 p-2 rounded border border-blue-500/30">
                        <div class="font-bold text-blue-400 text-sm">âŒ Trap 4: Not Using Set</div>
                        <p class="text-xs text-gray-300">List lookup = O(N). <strong>Set lookup = O(1)!</strong></p>
                        <p class="text-xs text-gray-400">Always convert wordDict to set first.</p>
                    </div>
                </div>`,
                dryRun: [
                    `<details class="group bg-slate-800 rounded-lg p-2 cursor-pointer open:ring-1 open:ring-indigo-500/50 transition-all duration-300">
                        <summary class="flex items-center gap-3 font-medium text-indigo-300 select-none list-none text-sm">
                            <span class="bg-indigo-500/20 text-indigo-400 p-1.5 rounded-md group-open:rotate-90 transition-transform">
                                <i class="fas fa-chevron-right text-xs"></i>
                            </span>
                            <span>ğŸ” View Trace: "leetcode" (Hidden by Default)</span>
                        </summary>
                        
                        <div class="mt-3 pl-4 border-l-2 border-indigo-500/20 space-y-3 text-sm font-mono text-gray-300 animate-in fade-in slide-in-from-top-2 duration-300">
                            <div class="bg-black/30 p-2 rounded text-xs">
                                <strong>Input:</strong> s = "leetcode"<br>
                                <strong>Dict:</strong> {"leet", "code"}
                            </div>
                            
                            <div class="flex items-start gap-2">
                                <span class="text-blue-400 mt-1">1.</span>
                                <div>
                                    <div class="font-bold text-white">dfs(0)</div>
                                    <div class="text-xs text-gray-500">Full string "leetcode"</div>
                                </div>
                            </div>

                            <div class="pl-4 border-l border-gray-700 ml-1 opacity-60 hover:opacity-100 transition-opacity">
                                <div class="flex items-center gap-2 text-xs text-red-300">
                                    <span>s[0:1] = "l"</span>
                                    <span class="text-red-500">âŒ Not in dict</span>
                                </div>
                                <div class="flex items-center gap-2 text-xs text-red-300">
                                    <span>s[0:2] = "le"</span>
                                    <span class="text-red-500">âŒ Not in dict</span>
                                </div>
                                <div class="flex items-center gap-2 text-xs text-red-300">
                                    <span>s[0:3] = "lee"</span>
                                    <span class="text-red-500">âŒ Not in dict</span>
                                </div>
                            </div>

                            <div class="flex items-start gap-2 pl-4 border-l border-gray-700 ml-1">
                                <span class="text-green-400 mt-1">2.</span>
                                <div>
                                    <div class="flex items-center gap-2">
                                        <span>s[0:4] = "leet"</span>
                                        <span class="bg-green-500/20 text-green-400 text-xs px-1.5 rounded">FOUND!</span>
                                    </div>
                                    <div class="text-xs text-gray-400">CUT lagao! â†’ Recurse on remaining...</div>
                                </div>
                            </div>

                            <div class="flex items-start gap-2 pl-6 border-l border-gray-700 ml-1">
                                <span class="text-blue-400 mt-1">3.</span>
                                <div>
                                    <div class="font-bold text-white">dfs(4)</div>
                                    <div class="text-xs text-gray-500">Remaining: "code"</div>
                                </div>
                            </div>

                            <div class="pl-10 border-l border-gray-700 ml-1 opacity-60 hover:opacity-100 transition-opacity">
                                <div class="flex items-center gap-2 text-xs text-red-300">
                                    <span>s[4:5] = "c", s[4:6] = "co", s[4:7] = "cod"</span>
                                    <span class="text-red-500">âŒ</span>
                                </div>
                            </div>

                            <div class="flex items-start gap-2 pl-10 border-l border-gray-700 ml-1">
                                <span class="text-green-400 mt-1">4.</span>
                                <div>
                                    <div class="flex items-center gap-2">
                                        <span>s[4:8] = "code"</span>
                                        <span class="bg-green-500/20 text-green-400 text-xs px-1.5 rounded">FOUND!</span>
                                    </div>
                                </div>
                            </div>

                            <div class="flex items-start gap-2 pl-12 border-l border-gray-700 ml-1">
                                <span class="text-purple-400 mt-1">5.</span>
                                <div>
                                    <div class="font-bold text-purple-300">dfs(8) â†’ True</div>
                                    <div class="text-xs text-gray-500">BASE CASE: start == len(s)</div>
                                </div>
                            </div>

                            <div class="border-t border-gray-700 pt-2 mt-2">
                                <div class="flex items-center gap-2 text-green-400">
                                    <i class="fas fa-check-circle"></i>
                                    <span class="font-bold">Backtrack: True â†’ True â†’ True</span>
                                </div>
                                <div class="text-xs text-gray-500 mt-1">"leet" + "code" = âœ… Valid!</div>
                            </div>
                        </div>
                    </details>`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ DP",
                code: `
##### 1. Brute Force Recursion (TLE - O(2^N))
def wordBreak_Brute(s, wordDict):
word_set = set(wordDict)  # O(1) lookup instead of O(N)!

def dfs(start_index):
    # ğŸ¯ BASE CASE: Puri string khatam, segmentation successful!
    if start_index == len(s):
        return True
    
    # Try cutting at every possible end position
    for end_index in range(start_index + 1, len(s) + 1):
        current_word = s[start_index:end_index]
        
        # If current word is valid AND remaining is also valid
        if current_word in word_set and dfs(end_index):
            return True
    
    # No valid cut found from this position
    return False

return dfs(0)

##### 2. Memoization - Top Down (O(NÂ³) Time, O(N) Space)
def wordBreak_Memo(s, wordDict):
word_set = set(wordDict)
memo = {}  # Cache: {start_index: can_break_from_here?}

def dfs(start_index):
    if start_index == len(s):
        return True
    
    # ğŸ” Already computed? Return cached answer!
    if start_index in memo:
        return memo[start_index]
    
    for end_index in range(start_index + 1, len(s) + 1):
        current_word = s[start_index:end_index]
        
        if current_word in word_set and dfs(end_index):
            memo[start_index] = True  # ğŸ’¾ Cache success
            return True
    
    memo[start_index] = False  # ğŸ’¾ Cache failure too!
    return False

return dfs(0)

##### 3. Iterative DP - Bottom Up (O(NÂ³) Time, O(N) Space)
# dp[i] = Can s[0:i] be segmented?
def wordBreak_DP(s, wordDict):
word_set = set(wordDict)
n = len(s)

# dp[i] means: Can s[0:i] be segmented into valid words?
dp = [False] * (n + 1)
dp[0] = True  # Empty string is always valid

# Fill table left to right
for end in range(1, n + 1):
    for start in range(end):
        # Recurrence:
        # 1. dp[start] = True â†’ s[0:start] is valid âœ“
        # 2. s[start:end] in dict â†’ current chunk is valid âœ“
        if dp[start] and s[start:end] in word_set:
            dp[end] = True
            break  # One valid cut is enough!

return dp[n]`
            }
        },
        {
            id: "partition-equal-subset-sum",
            title: "0/1 Knapsack (Partition)",
            leetcodeUrl: "https://leetcode.com/problems/partition-equal-subset-sum/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Knapsack"],
            quiz: {
                description: "Can array be split into two equal sum subsets?",
                options: ["Greedy", "Find subset with sum = Total/2", "Sort and split", "Backtracking"],
                correct: 1,
                explanation: "If Total Sum is odd, impossible. Else, find subset with sum = Total/2. This is 0/1 Knapsack."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Target Sum kyun?</strong> Equal partition = Subset Sum with target <code>Total/2</code>",
                    "âš¡ <code>if sum % 2 != 0</code> â†’ Odd sum divide nahi ho sakta, return False",
                    "ğŸ”„ 0/1 Knapsack logic: Iterate BACKWARDS <code>range(target, num-1, -1)</code>",
                    "âœ… <code>dp[t] = dp[t] or dp[t - num]</code> â€” can we make sum 't'?",
                    "ğŸ’¡ Backwards loop zaroori hai for 1D array to avoid reusing same element"
                ],
                metrics: { time: "O(N Ã— Sum)", space: "O(Sum)" },
                timeExplainer: `
                    <div class="space-y-3">
                        <div class="bg-red-900/20 p-3 rounded-lg border border-red-500/30">
                            <p class="font-bold text-red-400 text-base">ğŸ”´ Brute Force (Recursion): O(2â¿)</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Kyun?</strong> Har element ke liye 2 choices:</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
                                    TAKE   â†’ Include in subset (LUN LE)<br>
                                    SKIP   â†’ Don't include (MAT LE)
                                </div>
                                
                                <p><strong>ğŸ“Š Math Breakdown:</strong></p>
                                <ul class="list-disc pl-4 space-y-1">
                                    <li>N elements in array</li>
                                    <li>Each element: 2 choices (take/skip)</li>
                                    <li>Total subsets = <strong>2^N</strong></li>
                                </ul>
                                
                                <p><strong>ğŸ¯ Real Numbers:</strong></p>
                                <table class="w-full text-xs border-collapse">
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 10</td>
                                        <td class="text-yellow-400">1,024 subsets âœ… Fast</td>
                                    </tr>
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 20</td>
                                        <td class="text-yellow-400">~1 Million âš ï¸ Slow</td>
                                    </tr>
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">N = 30</td>
                                        <td class="text-red-400">~1 Billion âŒ TLE</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">N = 50</td>
                                        <td class="text-red-400">~10Â¹âµ ğŸ’€ Impossible</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400 text-base">ğŸŸ¢ Memoization / DP: O(N Ã— Sum)</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Why 2â¿ â†’ N Ã— Sum?</strong></p>
                                
                                <p><strong>Step 1: Count Unique States</strong></p>
                                <div class="bg-black/30 p-2 rounded">
                                    <div class="font-mono text-xs">solve(<span class="text-cyan-400">index</span>, <span class="text-purple-400">remaining_sum</span>)</div>
                                    <div class="text-xs text-gray-400">index: 0 to N â†’ N values</div>
                                    <div class="text-xs text-gray-400">remaining_sum: 0 to Target â†’ Target+1 values</div>
                                    <div class="text-cyan-400 font-bold">Unique States = N Ã— Target</div>
                                </div>
                                
                                <p class="mt-2"><strong>Step 2: Work per State</strong></p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
take = solve(idx + 1, rem - nums[idx])  <span class="text-green-400">â† O(1)</span><br>
skip = solve(idx + 1, rem)               <span class="text-green-400">â† O(1)</span><br>
return take or skip                      <span class="text-green-400">â† O(1)</span>
                                </div>
                                
                                <p class="mt-2"><strong>ğŸ§® Final Calculation:</strong></p>
                                <div class="bg-black/30 p-2 rounded text-cyan-300">
                                    N Ã— Sum states Ã— O(1) work = <strong class="text-green-400">O(N Ã— Sum)</strong>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                            <p class="font-bold text-purple-400 text-base">ğŸŸ£ 1D Space Optimized: O(Sum)</p>
                            <div class="mt-2 text-sm text-gray-300">
                                <p><strong>Key Trick:</strong> Iterate RIGHT to LEFT!</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs mt-1">
for num in nums:<br>
for s in range(target, num - 1, <span class="text-red-400">-1</span>):  <span class="text-yellow-400">â† BACKWARDS!</span><br>
    dp[s] = dp[s] or dp[s - num]
                                </div>
                                <p class="text-xs text-gray-400 mt-1">Backwards ensures each item used only once!</p>
                            </div>
                        </div>
                    </div>`,
                spaceExplainer: `
                    <div class="space-y-3">
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-blue-400">1. Recursion Stack: O(N)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <p>Max depth = N (one decision per element)</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs mt-1">
solve(0, target) â†’ solve(1, ...) â†’ ... â†’ solve(N, ...)<br>
<span class="text-yellow-400">Max depth = N</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-green-400">2. DP Table: O(N Ã— Sum) â†’ O(Sum)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
<span class="text-gray-500"># 2D Table</span><br>
dp = [[False] * (target+1) for _ in range(N+1)]  <span class="text-yellow-400">â† O(N Ã— Sum)</span><br><br>
<span class="text-gray-500"># Optimized 1D</span><br>
dp = [False] * (target + 1)  <span class="text-green-400">â† O(Sum)</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400">Optimized Space: O(Sum)</p>
                            <p class="text-sm text-gray-400">Where Sum = Total/2 (our target)</p>
                        </div>
                    </div>`,
                visual: `<div class="space-y-3">
                    <div class="text-center font-bold text-cyan-400">ğŸ’ 0/1 Knapsack = Lun ya Mat Lun</div>
                    <div class="bg-black/30 p-3 rounded font-mono text-xs">
                        <div class="text-gray-400 mb-2">nums = [1, 5, 11, 5], Target = 11</div>
                        <div class="flex items-center gap-4 justify-center">
                            <div class="text-center">
                                <div class="bg-green-900/30 p-2 rounded border border-green-500/30 mb-1">
                                    <span class="text-green-400 font-bold">TAKE</span>
                                </div>
                                <div class="text-xs text-gray-400">Include in subset</div>
                                <div class="text-green-400 text-xs">idx + 1, sum - num</div>
                            </div>
                            <div class="text-gray-500 text-2xl">OR</div>
                            <div class="text-center">
                                <div class="bg-red-900/30 p-2 rounded border border-red-500/30 mb-1">
                                    <span class="text-red-400 font-bold">SKIP</span>
                                </div>
                                <div class="text-xs text-gray-400">Don't include</div>
                                <div class="text-red-400 text-xs">idx + 1, sum (same)</div>
                            </div>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 text-center">
                        Each element: use ONCE or not at all<br>
                        Goal: Find subset summing to Target
                    </div>
                </div>`,
                crux: `<div class="space-y-3">
                    <div class="bg-red-900/30 p-3 rounded-lg border-2 border-red-500">
                        <div class="font-bold text-red-400 mb-2">ğŸš¨ CRITICAL: 0/1 vs Unbounded Knapsack</div>
                        <div class="grid grid-cols-2 gap-2 text-xs">
                            <div class="bg-red-900/20 p-2 rounded">
                                <div class="text-red-400 font-bold mb-1">0/1 Knapsack</div>
                                <div class="font-mono bg-black/30 p-1 rounded">
                                    solve(<span class="text-yellow-400">idx + 1</span>, rem - num)
                                </div>
                                <div class="text-gray-400 mt-1">MOVE to next! Each item ONCE.</div>
                            </div>
                            <div class="bg-green-900/20 p-2 rounded">
                                <div class="text-green-400 font-bold mb-1">Unbounded</div>
                                <div class="font-mono bg-black/30 p-1 rounded">
                                    solve(<span class="text-yellow-400">idx</span>, rem - num)
                                </div>
                                <div class="text-gray-400 mt-1">STAY at same! Infinite supply.</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="bg-cyan-900/20 p-3 rounded-lg border border-cyan-500/30">
                        <div class="font-bold text-cyan-400 mb-2">ğŸ¯ Problem Transformation</div>
                        <div class="bg-black/30 p-2 rounded text-xs">
                            <div>1. Total sum odd? â†’ <span class="text-red-400">IMPOSSIBLE</span></div>
                            <div>2. Target = sum / 2</div>
                            <div>3. Find ANY subset that sums to Target</div>
                            <div>4. If found, other subset also = Target! âœ“</div>
                        </div>
                    </div>
                    
                    <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                        <div class="font-bold text-purple-400 mb-2">ğŸ”— Same Pattern Problems</div>
                        <ul class="text-sm text-gray-300 space-y-1">
                            <li>â€¢ <strong>Target Sum</strong> - Assign +/- to reach target</li>
                            <li>â€¢ <strong>Last Stone Weight II</strong> - Minimize remaining stone</li>
                            <li>â€¢ <strong>Subset Sum</strong> - Classic 0/1 Knapsack</li>
                            <li>â€¢ <strong>Count Subsets with Sum K</strong> - Count instead of boolean</li>
                        </ul>
                    </div>
                </div>`,
                trap: `<div class="space-y-2">
                    <div class="bg-red-900/20 p-2 rounded border border-red-500/30">
                        <div class="font-bold text-red-400 text-sm">âŒ Trap 1: Odd Sum</div>
                        <p class="text-xs text-gray-300">If total sum is <strong>ODD</strong>, return False immediately!</p>
                        <p class="text-xs text-gray-400">Can't split odd number into two equal integers.</p>
                    </div>
                    
                    <div class="bg-orange-900/20 p-2 rounded border border-orange-500/30">
                        <div class="font-bold text-orange-400 text-sm">âŒ Trap 2: 1D DP Direction</div>
                        <div class="bg-black/30 p-1 rounded font-mono text-xs mt-1">
<span class="text-red-400">âŒ for s in range(0, target+1):</span>  <span class="text-gray-500"># LEFT to RIGHT</span><br>
<span class="text-green-400">âœ… for s in range(target, num-1, -1):</span>  <span class="text-gray-500"># RIGHT to LEFT</span>
                        </div>
                        <p class="text-xs text-gray-400">Wrong direction = using same item multiple times!</p>
                    </div>
                    
                    <div class="bg-yellow-900/20 p-2 rounded border border-yellow-500/30">
                        <div class="font-bold text-yellow-400 text-sm">âŒ Trap 3: Greedy Doesn't Work</div>
                        <p class="text-xs text-gray-300">[3, 1, 1, 2, 2, 1]: Greedy picks 3, then stuck!</p>
                        <p class="text-xs text-gray-400">Optimal: {3, 2} and {1, 1, 2, 1} both sum to 5.</p>
                    </div>
                    
                    <div class="bg-blue-900/20 p-2 rounded border border-blue-500/30">
                        <div class="font-bold text-blue-400 text-sm">âŒ Trap 4: Confusing with Unbounded</div>
                        <p class="text-xs text-gray-300">0/1 = <strong>idx + 1</strong> (move) | Unbounded = <strong>idx</strong> (stay)</p>
                        <p class="text-xs text-gray-400">This single line difference changes everything!</p>
                    </div>
                </div>`,
                dryRun: [
                    `<details class="group bg-slate-800 rounded-lg p-2 cursor-pointer open:ring-1 open:ring-indigo-500/50 transition-all duration-300">
                        <summary class="flex items-center gap-3 font-medium text-indigo-300 select-none list-none text-sm">
                            <span class="bg-indigo-500/20 text-indigo-400 p-1.5 rounded-md group-open:rotate-90 transition-transform">
                                <i class="fas fa-chevron-right text-xs"></i>
                            </span>
                            <span>ğŸ” View Trace: [1, 5, 11, 5] (Hidden by Default)</span>
                        </summary>
                        
                        <div class="mt-3 pl-4 border-l-2 border-indigo-500/20 space-y-3 text-sm font-mono text-gray-300">
                            <div class="bg-black/30 p-2 rounded text-xs">
                                <strong>Input:</strong> nums = [1, 5, 11, 5]<br>
                                <strong>Total:</strong> 22 (even âœ“)<br>
                                <strong>Target:</strong> 22 / 2 = 11
                            </div>
                            
                            <div class="text-xs">
                                <strong>Find subset summing to 11:</strong>
                                <div class="bg-black/30 p-2 rounded mt-1 space-y-1">
                                    <div class="flex items-center gap-2">
                                        <span class="text-yellow-400">1.</span>
                                        <span>Try [1]: 1 â‰  11</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-yellow-400">2.</span>
                                        <span>Try [1, 5]: 6 â‰  11</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span class="text-yellow-400">3.</span>
                                        <span>Try [1, 5, 5]: 11 = 11 âœ…</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="text-xs">
                                <strong>Or simpler - just take 11:</strong>
                                <div class="bg-black/30 p-2 rounded mt-1">
                                    <div class="flex items-center gap-2">
                                        <span>Subset {11} sums to 11 âœ…</span>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <span>Remaining {1, 5, 5} also sums to 11 âœ…</span>
                                    </div>
                                </div>
                            </div>

                            <div class="border-t border-gray-700 pt-2 mt-2">
                                <div class="flex items-center gap-2 text-green-400">
                                    <i class="fas fa-check-circle"></i>
                                    <span class="font-bold">Answer: True</span>
                                </div>
                                <div class="text-xs text-gray-500 mt-1">Partition: {11} | {1, 5, 5}</div>
                            </div>
                        </div>
                    </details>`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ 1D DP",
                code: `
##### 1. Brute Force Recursion (TLE - O(2^N))
def canPartition_Brute(nums):
total = sum(nums)
if total % 2 != 0:  # Odd sum? Impossible!
    return False
target = total // 2

def solve(index, remaining):
    # ğŸ¯ BASE CASES
    if remaining == 0: return True   # Found valid subset!
    if remaining < 0: return False   # Over budget
    if index >= len(nums): return False  # No items left
    
    # TAKE or SKIP (Lun ya Mat Lun)
    take = solve(index + 1, remaining - nums[index])  # â† idx + 1!
    skip = solve(index + 1, remaining)
    
    return take or skip

return solve(0, target)

##### 2. Memoization - Top Down (O(N Ã— Sum) Time & Space)
def canPartition_Memo(nums):
total = sum(nums)
if total % 2 != 0:
    return False
target = total // 2

memo = {}

def solve(index, remaining):
    if remaining == 0: return True
    if remaining < 0 or index >= len(nums): return False
    
    if (index, remaining) in memo:
        return memo[(index, remaining)]
    
    take = solve(index + 1, remaining - nums[index])
    skip = solve(index + 1, remaining)
    
    memo[(index, remaining)] = take or skip
    return memo[(index, remaining)]

return solve(0, target)

##### 3. 1D DP - Space Optimized (O(N Ã— Sum) Time, O(Sum) Space)
def canPartition_DP(nums):
total = sum(nums)
if total % 2 != 0:
    return False
target = total // 2

# dp[s] = True if we can make sum 's' using some subset
dp = [False] * (target + 1)
dp[0] = True  # Empty subset = sum 0

for num in nums:
    # ğŸš¨ CRITICAL: Iterate BACKWARDS!
    # This ensures each num is used at most ONCE
    for s in range(target, num - 1, -1):
        if dp[s - num]:  # Could make (s - num) before?
            dp[s] = True  # Now can make s!
    
    if dp[target]:  # Early exit optimization
        return True

return dp[target]`
            }
        },
        {
            id: "edit-distance",
            title: "Edit Distance",
            leetcodeUrl: "https://leetcode.com/problems/edit-distance/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["String DP"],
            quiz: {
                description: "Min ops to convert word1 to word2.",
                options: ["LCS variation", "Greedy", "BFS", "Two Pointers"],
                correct: 0,
                explanation: "2D DP. If match: dp[i-1][j-1]. If mismatch: 1 + min(Insert, Delete, Replace)."
            },
            learn: {
                quickAlgo: [
                    "if w1[i] == w2[j]:                 # ğŸ¯ Match: No op needed",
                    "    return solve(i+1, j+1)",
                    "else:",
                    "    insert = 1 + solve(i, j+1)     # âš¡ Insert char",
                    "    delete = 1 + solve(i+1, j)     # âš¡ Delete char",
                    "    replace = 1 + solve(i+1, j+1)  # ğŸ”„ Replace char",
                    "    return min(insert, delete, replace)"
                ],
                metrics: { time: "O(MÃ—N)", space: "O(MÃ—N)" },
                timeExplainer: `
                    <div class="space-y-3">
                        <div class="bg-red-900/20 p-3 rounded-lg border border-red-500/30">
                            <p class="font-bold text-red-400 text-base">ğŸ”´ Brute Force (Recursion): O(3^(M+N))</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Kyun?</strong> Har mismatch pe 3 choices hain:</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
                                    INSERT  â†’ (i, j-1)    <span class="text-gray-500"># Add char to word1</span><br>
                                    DELETE  â†’ (i-1, j)    <span class="text-gray-500"># Remove char from word1</span><br>
                                    REPLACE â†’ (i-1, j-1)  <span class="text-gray-500"># Change char in word1</span>
                                </div>
                                
                                <p><strong>ğŸ“Š Math Breakdown:</strong></p>
                                <ul class="list-disc pl-4 space-y-1">
                                    <li>At each step: <strong>3 branches</strong> (worst case)</li>
                                    <li>Max depth: <strong>M + N</strong> (both strings empty)</li>
                                    <li>Total: 3^(M+N) calls!</li>
                                </ul>
                                
                                <p><strong>ğŸ¯ Real Numbers:</strong></p>
                                <table class="w-full text-xs border-collapse">
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">M=5, N=5</td>
                                        <td class="text-yellow-400">3^10 â‰ˆ 59K ops âœ…</td>
                                    </tr>
                                    <tr class="border-b border-gray-700">
                                        <td class="py-1">M=10, N=10</td>
                                        <td class="text-orange-400">3^20 â‰ˆ 3.5 Billion âš ï¸ TLE</td>
                                    </tr>
                                    <tr>
                                        <td class="py-1">M=20, N=20</td>
                                        <td class="text-red-400">3^40 â‰ˆ 10^19 ğŸ’€ Impossible</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400 text-base">ğŸŸ¢ Memoization / DP: O(M Ã— N)</p>
                            <div class="mt-2 space-y-2 text-sm text-gray-300">
                                <p><strong>ğŸ¤” Why 3^(M+N) â†’ MÃ—N?</strong></p>
                                
                                <p><strong>Step 1: Count Unique States</strong></p>
                                <div class="bg-black/30 p-2 rounded">
                                    <div class="font-mono text-xs">solve(<span class="text-cyan-400">i</span>, <span class="text-purple-400">j</span>)</div>
                                    <div class="text-xs text-gray-400">i can be: 0 to M â†’ (M+1) values</div>
                                    <div class="text-xs text-gray-400">j can be: 0 to N â†’ (N+1) values</div>
                                    <div class="text-cyan-400 font-bold">Unique States = (M+1) Ã— (N+1) â‰ˆ O(MÃ—N)</div>
                                </div>
                                
                                <p class="mt-2"><strong>Step 2: Work per State</strong></p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
if word1[i-1] == word2[j-1]:  <span class="text-green-400">â† O(1) compare</span><br>
return dp[i-1][j-1]       <span class="text-green-400">â† O(1) lookup</span><br>
else:<br>
return 1 + min(...)       <span class="text-green-400">â† O(1) min of 3</span>
                                </div>
                                
                                <p class="mt-2"><strong>ğŸ§® Final Calculation:</strong></p>
                                <div class="bg-black/30 p-2 rounded text-cyan-300">
                                    MÃ—N states Ã— O(1) work = <strong class="text-green-400">O(MÃ—N)</strong>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                            <p class="font-bold text-purple-400 text-base">ğŸŸ£ Space Optimized: O(min(M, N))</p>
                            <div class="mt-2 text-sm text-gray-300">
                                <p><strong>Only need previous row!</strong></p>
                                <ul class="list-disc pl-4 text-xs space-y-1">
                                    <li>Current cell only depends on: top, left, diagonal</li>
                                    <li>Keep 2 rows (previous + current)</li>
                                    <li>Space: O(min(M, N)) if we iterate smarter</li>
                                </ul>
                            </div>
                        </div>
                    </div>`,
                spaceExplainer: `
                    <div class="space-y-3">
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-blue-400">1. Recursion Stack: O(M + N)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <p>Max depth when both strings shrink one char at a time</p>
                                <div class="bg-black/30 p-2 rounded font-mono text-xs mt-1">
solve(M, N) â†’ solve(M-1, N) â†’ ... â†’ solve(0, N)<br>
     â†’ solve(0, N-1) â†’ ... â†’ solve(0, 0)<br>
<span class="text-yellow-400">Max depth = M + N</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-slate-800 p-3 rounded-lg">
                            <p class="font-bold text-green-400">2. Memoization Cache / DP Table: O(M Ã— N)</p>
                            <div class="text-sm text-gray-300 mt-1">
                                <div class="bg-black/30 p-2 rounded font-mono text-xs">
dp = [[0] * (N+1) for _ in range(M+1)]<br>
<span class="text-gray-500"># (M+1) rows Ã— (N+1) columns</span><br>
<span class="text-cyan-400">Size â‰ˆ M Ã— N cells</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="bg-green-900/20 p-3 rounded-lg border border-green-500/30">
                            <p class="font-bold text-green-400">Total Space: O(M Ã— N)</p>
                            <p class="text-sm text-gray-400">Can be optimized to O(min(M,N)) using 2 rows.</p>
                        </div>
                    </div>`,
                visual: `<div class="space-y-3">
                    <div class="text-center font-bold text-cyan-400">âš¡ The 3 Operations</div>
                    <div class="bg-black/30 p-3 rounded font-mono text-xs">
                        <div class="text-gray-400 mb-2">Convert "CAT" â†’ "CUT"</div>
                        <div class="grid grid-cols-3 gap-2 text-center">
                            <div class="bg-blue-900/30 p-2 rounded border border-blue-500/30">
                                <div class="text-blue-400 font-bold">INSERT</div>
                                <div class="text-xs">CAT â†’ C<span class="text-green-400">U</span>AT</div>
                                <div class="text-gray-500 text-xs">(i, j-1)</div>
                            </div>
                            <div class="bg-red-900/30 p-2 rounded border border-red-500/30">
                                <div class="text-red-400 font-bold">DELETE</div>
                                <div class="text-xs">CAT â†’ <span class="text-red-400 line-through">C</span>AT</div>
                                <div class="text-gray-500 text-xs">(i-1, j)</div>
                            </div>
                            <div class="bg-yellow-900/30 p-2 rounded border border-yellow-500/30">
                                <div class="text-yellow-400 font-bold">REPLACE</div>
                                <div class="text-xs">CAT â†’ C<span class="text-yellow-400">U</span>T</div>
                                <div class="text-gray-500 text-xs">(i-1, j-1)</div>
                            </div>
                        </div>
                    </div>
                    <div class="text-xs text-gray-400 text-center">
                        If chars MATCH â†’ move diagonal (no cost)<br>
                        If MISMATCH â†’ pick min of 3 operations (+1 cost)
                    </div>
                </div>`,
                crux: `<div class="space-y-3">
                    <div class="bg-cyan-900/20 p-3 rounded-lg border border-cyan-500/30">
                        <div class="font-bold text-cyan-400 mb-2">ğŸ¯ The Core Recurrence</div>
                        <div class="bg-black/30 p-2 rounded font-mono text-xs">
if word1[i-1] == word2[j-1]:  <span class="text-green-400"># MATCH!</span><br>
dp[i][j] = dp[i-1][j-1]   <span class="text-green-400"># No operation needed</span><br>
else:                         <span class="text-red-400"># MISMATCH</span><br>
dp[i][j] = 1 + min(<br>
    dp[i-1][j],           <span class="text-red-400"># DELETE from word1</span><br>
    dp[i][j-1],           <span class="text-blue-400"># INSERT into word1</span><br>
    dp[i-1][j-1]          <span class="text-yellow-400"># REPLACE in word1</span><br>
)
                        </div>
                    </div>
                    
                    <div class="bg-yellow-900/20 p-3 rounded-lg border border-yellow-500/30">
                        <div class="font-bold text-yellow-400 mb-2">ğŸ’¡ Key Insight: LCS Connection</div>
                        <p class="text-sm text-gray-300">Edit Distance â‰ˆ <strong>Total Length - 2Ã—LCS</strong></p>
                        <p class="text-xs text-gray-400">But direct DP is easier to understand and implement!</p>
                    </div>
                    
                    <div class="bg-purple-900/20 p-3 rounded-lg border border-purple-500/30">
                        <div class="font-bold text-purple-400 mb-2">ğŸ”— Same Pattern Problems</div>
                        <ul class="text-sm text-gray-300 space-y-1">
                            <li>â€¢ <strong>LCS</strong> - Match = take, Mismatch = skip</li>
                            <li>â€¢ <strong>One Edit Distance</strong> - Check if exactly 1 edit</li>
                            <li>â€¢ <strong>Delete Operation for Two Strings</strong> - Only delete allowed</li>
                            <li>â€¢ <strong>Minimum ASCII Delete Sum</strong> - Weighted deletions</li>
                        </ul>
                    </div>
                </div>`,
                trap: `<div class="space-y-2">
                    <div class="bg-red-900/20 p-2 rounded border border-red-500/30">
                        <div class="font-bold text-red-400 text-sm">âŒ Trap 1: Base Case Confusion</div>
                        <div class="bg-black/30 p-1 rounded font-mono text-xs mt-1">
dp[i][0] = i  <span class="text-gray-500"># Delete all i chars from word1</span><br>
dp[0][j] = j  <span class="text-gray-500"># Insert all j chars into word1</span>
                        </div>
                    </div>
                    
                    <div class="bg-orange-900/20 p-2 rounded border border-orange-500/30">
                        <div class="font-bold text-orange-400 text-sm">âŒ Trap 2: Index Off-by-One</div>
                        <p class="text-xs text-gray-300">DP uses 1-indexed! Compare <code>word1[i-1]</code> with <code>word2[j-1]</code></p>
                        <p class="text-xs text-gray-400">dp[i][j] represents first i chars of word1 and first j chars of word2</p>
                    </div>
                    
                    <div class="bg-yellow-900/20 p-2 rounded border border-yellow-500/30">
                        <div class="font-bold text-yellow-400 text-sm">âŒ Trap 3: Forgetting +1</div>
                        <p class="text-xs text-gray-300">INSERT/DELETE/REPLACE each costs <strong>1 operation</strong></p>
                        <p class="text-xs text-gray-400">Return value is: <code>1 + min(...)</code> not just <code>min(...)</code></p>
                    </div>
                    
                    <div class="bg-blue-900/20 p-2 rounded border border-blue-500/30">
                        <div class="font-bold text-blue-400 text-sm">âŒ Trap 4: Greedy Doesn't Work</div>
                        <p class="text-xs text-gray-300">"horse" â†’ "ros": Greedy might replace hâ†’r, but optimal is different!</p>
                        <p class="text-xs text-gray-400">Must try all 3 options and take minimum.</p>
                    </div>
                </div>`,
                dryRun: [
                    `<details class="group bg-slate-800 rounded-lg p-2 cursor-pointer open:ring-1 open:ring-indigo-500/50 transition-all duration-300">
                        <summary class="flex items-center gap-3 font-medium text-indigo-300 select-none list-none text-sm">
                            <span class="bg-indigo-500/20 text-indigo-400 p-1.5 rounded-md group-open:rotate-90 transition-transform">
                                <i class="fas fa-chevron-right text-xs"></i>
                            </span>
                            <span>ğŸ” View Trace: "CAT" â†’ "CUT" (Hidden by Default)</span>
                        </summary>
                        
                        <div class="mt-3 pl-4 border-l-2 border-indigo-500/20 space-y-3 text-sm font-mono text-gray-300">
                            <div class="bg-black/30 p-2 rounded text-xs">
                                <strong>Input:</strong> word1 = "CAT", word2 = "CUT"<br>
                                <strong>Goal:</strong> Minimum operations to convert CAT â†’ CUT
                            </div>
                            
                            <div class="text-xs">
                                <strong>DP Table (rows=word1, cols=word2):</strong>
                                <pre class="bg-black/30 p-2 rounded mt-1 overflow-x-auto">
""  C   U   T
""   0   1   2   3  â† Insert C, U, T
C    1  [0]  1   2  â† C==C, cost=0
A    2   1  [1]  2  â† Aâ‰ U, min(1,1,0)+1=1
T    3   2   2  [1] â† T==T, cost=dp[2][2]=1
                                </pre>
                            </div>
                            
                            <div class="space-y-2 text-xs">
                                <div class="flex items-center gap-2">
                                    <span class="text-green-400">1.</span>
                                    <span>dp[1][1]: C == C â†’ dp[0][0] = <strong>0</strong></span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span class="text-yellow-400">2.</span>
                                    <span>dp[2][2]: A â‰  U â†’ 1 + min(dp[1][2], dp[2][1], dp[1][1])</span>
                                </div>
                                <div class="flex items-center gap-2 pl-4">
                                    <span>= 1 + min(1, 1, 0) = <strong>1</strong> (REPLACE Aâ†’U)</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span class="text-green-400">3.</span>
                                    <span>dp[3][3]: T == T â†’ dp[2][2] = <strong>1</strong></span>
                                </div>
                            </div>

                            <div class="border-t border-gray-700 pt-2 mt-2">
                                <div class="flex items-center gap-2 text-green-400">
                                    <i class="fas fa-check-circle"></i>
                                    <span class="font-bold">Answer: 1 (Replace 'A' with 'U')</span>
                                </div>
                                <div class="text-xs text-gray-500 mt-1">CAT â†’ C<span class="text-yellow-400">U</span>T</div>
                            </div>
                        </div>
                    </details>`
                ],
                codeTitle: "Evolution: Recursion â†’ Memo â†’ DP",
                code: `
##### 1. Brute Force Recursion (TLE - O(3^(M+N)))
def minDistance_Brute(word1, word2):
def solve(i, j):
    # ğŸ¯ BASE CASES
    if i == 0: return j  # Insert remaining j chars
    if j == 0: return i  # Delete remaining i chars
    
    # If chars MATCH - no operation needed!
    if word1[i-1] == word2[j-1]:
        return solve(i-1, j-1)
    
    # If MISMATCH - try all 3 operations, pick minimum
    insert_op = solve(i, j-1)      # Insert word2[j-1] into word1
    delete_op = solve(i-1, j)      # Delete word1[i-1]
    replace_op = solve(i-1, j-1)   # Replace word1[i-1] with word2[j-1]
    
    return 1 + min(insert_op, delete_op, replace_op)

return solve(len(word1), len(word2))

##### 2. Memoization - Top Down (O(MÃ—N) Time & Space)
def minDistance_Memo(word1, word2):
memo = {}

def solve(i, j):
    if i == 0: return j
    if j == 0: return i
    
    if (i, j) in memo:
        return memo[(i, j)]
    
    if word1[i-1] == word2[j-1]:
        result = solve(i-1, j-1)  # Match! No cost
    else:
        insert_op = solve(i, j-1)
        delete_op = solve(i-1, j)
        replace_op = solve(i-1, j-1)
        result = 1 + min(insert_op, delete_op, replace_op)
    
    memo[(i, j)] = result
    return result

return solve(len(word1), len(word2))

##### 3. Iterative DP - Bottom Up (O(MÃ—N) Time & Space)
def minDistance_DP(word1, word2):
m, n = len(word1), len(word2)

# dp[i][j] = min ops to convert word1[0:i] â†’ word2[0:j]
dp = [[0] * (n + 1) for _ in range(m + 1)]

# Base cases: converting empty string
for i in range(m + 1):
    dp[i][0] = i  # Delete all i chars
for j in range(n + 1):
    dp[0][j] = j  # Insert all j chars

# Fill table
for i in range(1, m + 1):
    for j in range(1, n + 1):
        if word1[i-1] == word2[j-1]:
            dp[i][j] = dp[i-1][j-1]  # No operation
        else:
            dp[i][j] = 1 + min(
                dp[i-1][j],    # DELETE
                dp[i][j-1],    # INSERT
                dp[i-1][j-1]   # REPLACE
            )

return dp[m][n]`
            }
        }
    ]
}


// ========== data/dsa/heap_trie.js ==========
// Heap Trie data
// Extracted from data.js

const topic_heap_trie = {
    id: "heap_trie",
    title: "Heaps & Tries",
    description: "Principal Engineer DSA â€¢ Day 8",
    color: "#d97706",
    icon: "fas fa-sitemap",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ† Top K Elements", desc: "Find K largest/smallest â†’ Min-Heap of size K" },
            { label: "ğŸ”€ Merge K Streams", desc: "Merge K sorted lists â†’ Min-Heap with (val, idx, node)" },
            { label: "ğŸ”¤ Prefix Search", desc: "Autocomplete, word search â†’ Trie (O(L) lookup)" },
            { label: "âŠ• Max XOR", desc: "Find max XOR pair â†’ Binary Trie with opposite-bit path" },
            { label: "ğŸ“Š Streaming Data", desc: "Maintain K best in stream â†’ Min-Heap (VIP room analogy)" }
        ],
        patterns: [
            { algo: "Kth Largest (Min-Heap)", use: "Top K elements", time: "O(N log K)", space: "O(K)", template: "Min-heap size K, root = Kth largest" },
            { algo: "Merge K Lists", use: "Merge sorted streams", time: "O(N log K)", space: "O(K)", template: "(val, idx, node) tuple for tie-break" },
            { algo: "Trie Insert/Search", use: "Prefix matching", time: "O(L)", space: "O(NÃ—L)", template: "children={}, isEnd=False per node" },
            { algo: "Binary Trie", use: "Max XOR pair", time: "O(N Ã— 32)", space: "O(N Ã— 32)", template: "Store bits, traverse opposite path" },
            { algo: "Heapify", use: "Build heap from array", time: "O(N)", space: "O(1)", template: "heapq.heapify(arr) - NOT O(N log N)!" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Heap & Trie Pattern Recognition</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:1.8;">
<pre style="color:#e2e8f0; text-align:left; margin:0;">
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚ "What's the core need?"   â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   TOP K /     â”‚    â”‚ MERGE SORTED  â”‚    â”‚   PREFIX /    â”‚
â”‚   STREAMING   â”‚    â”‚   LISTS       â”‚    â”‚   STRINGS     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                    â”‚                    â”‚
        â–¼                    â–¼                    â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ K LARGEST?    â”‚    â”‚ Min-Heap with â”‚    â”‚ Autocomplete? â”‚
  â”‚ â†’ MIN-HEAP    â”‚    â”‚ K heads       â”‚    â”‚ â†’ TRIE        â”‚
  â”‚   size K      â”‚    â”‚ (val,idx,node)â”‚    â”‚               â”‚
  â”‚               â”‚    â”‚               â”‚    â”‚ XOR max?      â”‚
  â”‚ K SMALLEST?   â”‚    â”‚ Pop min,      â”‚    â”‚ â†’ Binary Trie â”‚
  â”‚ â†’ MAX-HEAP    â”‚    â”‚ push next     â”‚    â”‚               â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ğŸ¯ VIP ROOM ANALOGY:                                    â”‚
  â”‚ â€¢ Room capacity = K                                     â”‚
  â”‚ â€¢ Bouncer (min-heap root) = Kth largest                â”‚
  â”‚ â€¢ New person richer than bouncer? Kick bouncer out!     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Heap & Trie Templates</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ Kth Largest (Min-Heap size K)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
import heapq
class KthLargest:
    def __init__(self, k, nums):
        self.k, self.heap = k, []
        for n in nums: self.add(n)
    def add(self, val):
        if len(self.heap) < self.k:
            heapq.heappush(self.heap, val)
        elif val > self.heap[0]:
            heapq.heapreplace(self.heap, val)
        return self.heap[0]  # Kth largest = min of top K
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Merge K Sorted Lists
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def mergeKLists(lists):
    pq = []
    for i, l in enumerate(lists):
        if l: heapq.heappush(pq, (l.val, i, l))  # i = tie-breaker!
    dummy = curr = ListNode()
    while pq:
        val, i, node = heapq.heappop(pq)
        curr.next = node
        curr = curr.next
        if node.next:
            heapq.heappush(pq, (node.next.val, i, node.next))
    return dummy.next
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Trie Implementation
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
class TrieNode:
    def __init__(self):
        self.children = {}
        self.isEnd = False
class Trie:
    def __init__(self):
        self.root = TrieNode()
    def insert(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children:
                cur.children[c] = TrieNode()
            cur = cur.children[c]
        cur.isEnd = True
    def search(self, word):
        cur = self.root
        for c in word:
            if c not in cur.children: return False
            cur = cur.children[c]
        return cur.isEnd  # Must be end of word!
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ XOR Trick (Single Number)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
# A ^ A = 0, A ^ 0 = A
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ”„ Min vs Max Heap!", desc: "Kth LARGEST â†’ MIN-heap. Python heapq is min-heap by default." },
            { label: "âš ï¸ Tuple tie-breaker!", desc: "Merge K Lists: Use <code>(val, idx, node)</code> â€” nodes can't be compared!" },
            { label: "ğŸ”š isEnd flag!", desc: "Trie: Don't forget <code>isEnd = True</code> at word end" },
            { label: "ğŸ“ Prefix vs Word!", desc: "startsWith â†’ just traverse. search â†’ must check isEnd" },
            { label: "âš¡ Heapify is O(N)!", desc: "<code>heapq.heapify()</code> is O(N), NOT O(N log N)" },
            { label: "ğŸ“¦ Heap size K!", desc: "For top K, only keep K elements in heap, not all N" }
        ]
    },
    questions: [
        {
            id: "kth-largest-element-in-a-stream",
            title: "Kth Largest in Stream",
            leetcodeUrl: "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Min-Heap"],
            quiz: {
                description: "Maintain Kth largest in streaming data. Data structure?",
                options: ["Sort list every time", "Max-Heap", "Min-Heap of size K", "BST"],
                correct: 2,
                explanation: "Min-Heap of size K! The root holds the K-th largest. If new val > root, pop root and push new val. Keep top K elements in the club; root is the 'bouncer' (smallest of the top K)."
            },
            learn: {
                quickAlgo: [
                    "class KthLargest:",
                    "    def __init__(self, k, nums):",
                    "        self.k = k",
                    "        self.heap = []",
                    "        for n in nums: self.add(n)",
                    "    def add(self, val):",
                    "        # ğŸ¯ Min-Heap: Stores Top-K largest elements",
                    "        heapq.heappush(self.heap, val) # âš¡ Add new candidate",
                    "        if len(self.heap) > self.k:",
                    "            heapq.heappop(self.heap)   # ğŸ”„ Remove smallest of the giants",
                    "        return self.heap[0]            # âœ… Root is the Kth largest"
                ],
                metrics: { time: "O(log K)", space: "O(K)" },
                timeExplainer: "<strong>Min-Heap:</strong><br>â€¢ Add element: <code>O(log K)</code><br>â€¢ Maintain size K<br><br><strong>Total:</strong> <code>O(log K)</code> per add",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Heap stores exactly K elements<br>â€¢ Ignore infinite stream history<br><br><strong>Result:</strong> <code>O(K)</code>",
                visual: "<span><strong>Visual: The VIP Room</strong><br>Room capacity K. Bouncer (Root) is the poorest VIP. <br>If new guy is richer than Bouncer, kick Bouncer out.</span>",
                crux: "<strong>Inverse Logic:</strong> Kth Largest -> Min-Heap.<br>1. Keep size <= K.<br>2. `heapq.heappushpop` if full.",
                trap: "<strong>Don't Heapify All:</strong> Only store K elements.",
                dryRun: ["K=3. Heap [?, ?, ?].", "Add 5, 2, 8 -> [2, 5, 8]. Root 2 is 3rd largest.", "Add 10. 10 > 2. Pop 2. Push 10. [5, 8, 10]. Root 5 is 3rd largest."],
                codeTitle: "Python Solution",
                code: `class KthLargest:
def __init__(self, k, nums):
    self.k = k
    self.heap = []
    for n in nums: self.add(n)
    
def add(self, val):
    if len(self.heap) < self.k:
        heapq.heappush(self.heap, val)
    elif val > self.heap[0]:
        heapq.heapreplace(self.heap, val)
    return self.heap[0]`
            }
        },
        {
            id: "merge-k-sorted-lists",
            title: "Merge K Sorted Lists",
            leetcodeUrl: "https://leetcode.com/problems/merge-k-sorted-lists/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Heap"],
            quiz: {
                description: "Merge K lists efficiently.",
                options: ["Comparing heads one by one", "Min-Heap with (val, node)", "Merge 2 at a time", "Concatenate and sort"],
                correct: 1,
                explanation: "Min-Heap! Put all K heads in heap. Pop min, add to result, push next node from that list. O(N log K)."
            },
            learn: {
                quickAlgo: [
                    "heap = []                          # ğŸ¯ Min-Heap: (val, index, node)",
                    "for i, l in enumerate(lists):",
                    "    if l: heapq.heappush(heap, (l.val, i, l)) # âš¡ Init heap with heads",
                    "dummy = curr = ListNode(0)",
                    "while heap:",
                    "    val, i, node = heapq.heappop(heap) # ğŸ”„ Get smallest among K heads",
                    "    curr.next = node",
                    "    curr = curr.next",
                    "    if node.next:                  # âœ… Push next node from same list",
                    "        heapq.heappush(heap, (node.next.val, i, node.next))",
                    "return dummy.next"
                ],
                metrics: { time: "O(N log K)", space: "O(K)" },
                timeExplainer: "<strong>Heap Merge:</strong><br>â€¢ Heap size K (one per list)<br>â€¢ Process all N nodes<br>â€¢ Push/Pop is log K<br><br><strong>Total:</strong> <code>O(N log K)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Heap stores K nodes<br>â€¢ Output list not counted (if returning new)<br><br><strong>Result:</strong> <code>O(K)</code>",
                visual: "<span><strong>Visual: The Race</strong><br>K runners at start line. Move the leader forward.</span>",
                crux: "<strong>Tuple Trick:</strong> `(val, idx, node)`. Use `idx` to break ties because Python can't compare `ListNode` objects.",
                trap: "<strong>Comparsion Crash:</strong> Nodes with same value will crash heap if you don't use a tie-breaker or override `__lt__`.",
                dryRun: ["Heads: 1(L1), 4(L2), 2(L3). Heap: [(1, L1), (2, L3), (4, L2)].", "Pop 1. Push L1.next."],
                codeTitle: "Python Solution",
                code: `def mergeKLists(lists):
pq = []
for i, l in enumerate(lists):
    if l: heapq.heappush(pq, (l.val, i, l))

dummy = curr = ListNode()
while pq:
    val, i, node = heapq.heappop(pq)
    curr.next = node
    curr = curr.next
    if node.next:
        heapq.heappush(pq, (node.next.val, i, node.next))
        
return dummy.next`
            }
        },
        {
            id: "implement-trie-prefix-tree",
            title: "Implement Trie",
            leetcodeUrl: "https://leetcode.com/problems/implement-trie-prefix-tree/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Trie"],
            quiz: {
                description: "Data structure for fast prefix search.",
                options: ["HashMap", "Binary Search Tree", "Trie (Prefix Tree)", "Graph"],
                correct: 2,
                explanation: "Trie! Nodes represent characters. Path from root spells word. Shared prefixes share nodes (Space efficient)."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>Trie Structure?</strong> String sharing space save karta hai (prefix 'app' shared by 'apple', 'app')",
                    "âš¡ Node: <code>children = {}</code>, <code>isEnd = False</code>",
                    "ğŸ”„ Insert: Loop chars. If not in children, create new Node. Last node marked <code>isEnd=True</code>",
                    "âœ… Search: Traverse path. If broken -> False. At end, check <code>isEnd</code>",
                    "ğŸ’¡ Prefix Search? Same as search, but don't check <code>isEnd</code>",
                    "<code>startsWith: traverse; return True if reached</code>",
                    "Path from root spells prefix"
                ],
                metrics: { time: "O(L)", space: "O(N*L)" },
                timeExplainer: "<strong>Prefix Tree:</strong><br>â€¢ Traversal depends only on word length L<br>â€¢ Independent of total words N<br><br><strong>Total:</strong> <code>O(L)</code>",
                spaceExplainer: "<strong>Space Analysis:</strong><br>â€¢ Worst: No common prefixes<br>â€¢ <code>N</code> words of length <code>L</code><br><br><strong>Total:</strong> <code>O(NÃ—L)</code> nodes",
                visual: "<span><strong>Visual: Autocomplete</strong><br>APP -> 'A' -> 'P' -> 'P'. <br>APPLE -> Extends 'P' -> 'L' -> 'E'.</span>",
                crux: "<strong>Node Struct:</strong> `children = {}`, `is_end = False`.<br>Insert/Search: Traverse char by char.",
                trap: "<strong>Prefix vs Word:</strong> `startWith` returns True for 'APP'. `search` returns False for 'APP' if only 'APPLE' exists.",
                dryRun: ["Insert 'HI'. Root->H->I(end).", "Search 'H'. Root->H. No end. False.", "Starts 'H'. True."],
                codeTitle: "Python Solution",
                code: `class TrieNode:
def __init__(self):
    self.children = {}
    self.isEnd = False

class Trie:
def __init__(self):
    self.root = TrieNode()

def insert(self, word):
    cur = self.root
    for c in word:
        if c not in cur.children:
            cur.children[c] = TrieNode()
        cur = cur.children[c]
    cur.isEnd = True

def search(self, word):
    cur = self.root
    for c in word:
        if c not in cur.children: return False
        cur = cur.children[c]
    return cur.isEnd

def startsWith(self, prefix):
    cur = self.root
    for c in prefix:
        if c not in cur.children: return False
        cur = cur.children[c]
    return True`
            }
        },
        {
            id: "maximum-xor-of-two-numbers-in-an-array",
            title: "Max XOR of Two Numbers",
            leetcodeUrl: "https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/",
            difficulty: "Good to Do",
            priority: "ğŸŸ¡",
            tags: ["Trie", "Bit Manipulation"],
            quiz: {
                description: "Find max XOR of two nums in array. O(N)?",
                options: ["Brute Force O(NÂ²)", "Trie", "Sort", "Heap"],
                correct: 1,
                explanation: "Insert all numbers into a Binary Trie. For each number, try to traverse the opposite bit path to maximize XOR."
            },
            learn: {
                quickAlgo: [
                    "counts = Counter(tasks)",
                    "maxHeap = [-cnt for cnt in counts.values()] # ğŸ¯ Max Frequency first",
                    "heapq.heapify(maxHeap)",
                    "q = deque()                        # âš¡ Queue: (count, available_time)",
                    "time = 0",
                    "while maxHeap or q:",
                    "    time += 1",
                    "    if maxHeap:                    # ğŸ”„ Process task",
                    "        cnt = heapq.heappop(maxHeap) + 1 # Decr count (negative logic)",
                    "        if cnt: q.append((cnt, time + n)) # âœ… Add to wait queue",
                    "    if q and q[0][1] == time:      # ğŸ’¡ Task becomes available again",
                    "        heapq.heappush(maxHeap, q.popleft()[0])",
                    "return time"
                ],
                metrics: { time: "O(N * 32)", space: "O(N * 32)" },
                code: `# Trie Implementation needed`
            }
        },
        {
            id: "single-number",
            title: "Single Number",
            leetcodeUrl: "https://leetcode.com/problems/single-number/",
            difficulty: "Bonus",
            priority: "ğŸŸ¢",
            tags: ["Bit Manipulation"],
            quiz: {
                description: "All nums appear twice except one. O(N) time, O(1) space?",
                options: ["HashSet", "Sorting", "XOR all numbers", "Math"],
                correct: 2,
                explanation: "A ^ A = 0. A ^ 0 = A. XORing all numbers cancels out pairs, leaving the single number."
            },
            learn: {
                quickAlgo: [
                    "small, large = [], []              # ğŸ¯ Small: Max-Heap, Large: Min-Heap",
                    "def addNum(num):",
                    "    heapq.heappush(small, -num)    # âš¡ Always push to Small first",
                    "    # ğŸ”„ Balance: Max(Small) <= Min(Large)",
                    "    if small and large and (-small[0] > large[0]):",
                    "        heapq.heappush(large, -heapq.heappop(small))",
                    "    # âœ… Size Balance: len(Small) roughly len(Large)",
                    "    if len(small) > len(large) + 1:",
                    "        heapq.heappush(large, -heapq.heappop(small))",
                    "    elif len(large) > len(small):",
                    "        heapq.heappush(small, -heapq.heappop(large))"
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                code: `def singleNumber(nums):
res = 0
for n in nums:
    res ^= n
return res`
            }
        },
        {
            id: "heapify-algorithm",
            title: "Heapify Algorithm",
            difficulty: "Bonus",
            priority: "ğŸŸ¢",
            tags: ["Heap"],
            quiz: {
                description: "Convert array to heap. Complexity?",
                options: ["O(N log N)", "O(N)", "O(log N)", "O(NÂ²)"],
                correct: 1,
                explanation: "O(N)! Sift-down from the last non-leaf node up to root. Lower levels have less work."
            },
            learn: {
                quickAlgo: [
                    "ğŸ¯ <strong>O(N) vs O(NlogN)?</strong> Build Heap from bottom-up is faster (Sift Level-by-Level)",
                    "âš¡ Start: Last non-leaf node (index <code>N//2 - 1</code>)",
                    "ğŸ”„ Loop Backwards: Call <code>sift_down(i)</code> for each node upto root",
                    "âœ… Why O(N)? Most nodes are leaves (0 work). Work decreases as levels go up.",
                    "ğŸ’¡ <code>push</code> N times is O(NlogN). This is efficient batch build."
                ],
                metrics: { time: "O(N)", space: "O(1)" },
                code: `import heapq
def heapify(arr):
heapq.heapify(arr) # Linear time O(N)
return arr`
            }
        }
    ]
}


// ========== data/dsa/backtracking.js ==========
// Backtracking data
// Extracted from data.js

const topic_backtracking = {
    id: "backtracking",
    title: "Backtracking Mastery",
    description: "Principal Engineer DSA â€¢ Part 2",
    color: "#4c1d95",
    icon: "fas fa-chess-queen",
    mentalModel: {
        whenToApply: [
            { label: "ğŸ¯ ALL Solutions", desc: "Find ALL permutations, combinations, subsets, paths." },
            { label: "ğŸ”¢ Small N (â‰¤ 20)", desc: "Exponential time OK when N is small." },
            { label: "ğŸš« Constraint Satisfaction", desc: "N-Queens, Sudoku, Graph Coloring - place items with rules." },
            { label: "ğŸ” Decision Tree", desc: "Each step = make a choice â†’ explore â†’ undo (CHOOSE-EXPLORE-UNCHOOSE)." }
        ],
        patterns: [
            { algo: "Subsets (Pick/No-Pick)", use: "Generate all 2^N subsets", time: "O(2^N Ã— N)", space: "O(N)", template: "backtrack(i+1) for both PICK and SKIP" },
            { algo: "Permutations (Swap)", use: "Generate all N! arrangements", time: "O(N Ã— N!)", space: "O(N)", template: "swap(start, i) â†’ recurse â†’ swap back" },
            { algo: "Combinations (Bounded)", use: "Choose k items from n", time: "O(C(n,k) Ã— k)", space: "O(k)", template: "Loop j from start, recurse with j+1" },
            { algo: "Unbounded (Combination Sum)", use: "Reuse elements allowed", time: "O(N^(T/M))", space: "O(T/M)", template: "PICK stays at i, SKIP moves to i+1" },
            { algo: "Grid DFS (Word Search)", use: "Find path in 2D matrix", time: "O(MÃ—N Ã— 3^L)", space: "O(L)", template: "mark # â†’ 4 dirs â†’ unmark" },
            { algo: "Constraint Satisfaction", use: "N-Queens, Sudoku", time: "O(N!) / O(9^M)", space: "O(N)", template: "Check constraints â†’ place â†’ recurse â†’ remove" }
        ],
        decisionTree: `
<div style="background:#1e293b; padding:25px; border-radius:16px; margin:15px 0; border:1px solid rgba(255,255,255,0.1);">
<h4 style="color:#a78bfa; margin-bottom:20px; text-align:center; font-size:1.1rem;">ğŸ§  Pattern Recognition Flowchart</h4>
<div style="font-family:monospace; font-size:0.85rem; line-height:2;">
<div style="text-align:center; color:#fbbf24; font-weight:bold; margin-bottom:15px;">
"Problem kya maang raha hai?"
</div>
<pre style="color:#e2e8f0; text-align:left;">
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ "Find ALL ___"? â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â–¼                   â–¼                   â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  SUBSETS    â”‚    â”‚ PERMUTATIONSâ”‚    â”‚ COMBINATIONS â”‚
  â”‚  "2^N"      â”‚    â”‚   "N!"      â”‚    â”‚   "C(n,k)"   â”‚
  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                   â”‚                   â”‚
        â–¼                   â–¼                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Pick/No-Pick  â”‚  â”‚     SWAP      â”‚  â”‚ Loop j=start   â”‚
â”‚ i+1 for both  â”‚  â”‚ swapâ†’recâ†’swap â”‚  â”‚ Recurse j+1    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

         "Elements REUSABLE?"          "2D Grid?"
              â”‚                            â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼                   â–¼        â”‚                 â”‚
 â”Œâ”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â–¼                 â–¼
 â”‚ YES  â”‚          â”‚  NO   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â””â”€â”€â”¬â”€â”€â”€â”˜          â””â”€â”€â”€â”¬â”€â”€â”€â”˜  â”‚  YES   â”‚    â”‚ CONSTRAINTâ”‚
    â”‚                  â”‚      â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚ PROBLEM  â”‚
    â–¼                  â–¼          â–¼         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚PICK: stay iâ”‚  â”‚PICK: i+1 â”‚ â”‚Grid DFS â”‚   â”‚ N-Queens/  â”‚
â”‚SKIP: i+1   â”‚  â”‚SKIP: i+1 â”‚ â”‚markâ†’expâ†’â”‚   â”‚ Sudoku     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚unmark   â”‚   â”‚ Use SETS   â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</pre>
</div>
</div>`,
        codeTemplates: `
<div style="background:#0f172a; padding:20px; border-radius:12px; margin:15px 0;">
<h4 style="color:#10b981; margin-bottom:15px;">ğŸ“ Universal Templates (Copy-Paste Ready)</h4>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
1ï¸âƒ£ Subset Pattern (Pick/No-Pick)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def subsets(nums):
    result = []
    def backtrack(index, current):
        if index == len(nums):
            result.append(current[:])  # COPY!
            return
        # PICK
        current.append(nums[index])
        backtrack(index + 1, current)
        current.pop()  # Backtrack
        # NO-PICK
        backtrack(index + 1, current)
    backtrack(0, [])
    return result
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
2ï¸âƒ£ Permutation Pattern (Swap)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def permute(nums):
    result = []
    def backtrack(start):
        if start == len(nums):
            result.append(nums[:])
            return
        for i in range(start, len(nums)):
            nums[start], nums[i] = nums[i], nums[start]  # Swap
            backtrack(start + 1)
            nums[start], nums[i] = nums[i], nums[start]  # Unswap
    backtrack(0)
    return result
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
3ï¸âƒ£ Combination Sum Pattern (Unbounded)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def combinationSum(candidates, target):
    result = []
    def backtrack(index, path, current_sum):
        if current_sum == target:
            result.append(path[:])
            return
        if index >= len(candidates) or current_sum > target:
            return
        # PICK (stay at index)
        path.append(candidates[index])
        backtrack(index, path, current_sum + candidates[index])
        path.pop()
        # SKIP (move to index+1)
        backtrack(index + 1, path, current_sum)
    backtrack(0, [], 0)
    return result
</pre>
</details>

<details style="margin-bottom:15px;">
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
4ï¸âƒ£ Grid DFS Pattern (Word Search)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def exist(board, word):
    ROWS, COLS = len(board), len(board[0])
    def dfs(row, col, char_index):
        if char_index == len(word): return True
        if (row < 0 or row >= ROWS or col < 0 or col >= COLS 
            or board[row][col] != word[char_index]):
            return False
        original = board[row][col]
        board[row][col] = '#'  # Mark
        found = (dfs(row+1,col,char_index+1) or dfs(row-1,col,char_index+1) or
                 dfs(row,col+1,char_index+1) or dfs(row,col-1,char_index+1))
        board[row][col] = original  # Unmark
        return found
    return any(dfs(r,c,0) for r in range(ROWS) for c in range(COLS))
</pre>
</details>

<details>
<summary style="cursor:pointer; color:#fbbf24; font-weight:bold; padding:10px; background:#1e293b; border-radius:8px;">
5ï¸âƒ£ Constraint Pattern (N-Queens)
</summary>
<pre style="color:#a5b4fc; padding:15px; background:#1e1b4b; border-radius:8px; margin-top:10px; font-size:0.85rem;">
def solveNQueens(n):
    cols, pos_diag, neg_diag = set(), set(), set()
    result, positions = [], [-1] * n
    def backtrack(row):
        if row == n:
            result.append(['.'*c + 'Q' + '.'*(n-c-1) for c in positions])
            return
        for col in range(n):
            if col in cols or (row+col) in pos_diag or (row-col) in neg_diag:
                continue
            cols.add(col); pos_diag.add(row+col); neg_diag.add(row-col)
            positions[row] = col
            backtrack(row + 1)
            cols.remove(col); pos_diag.remove(row+col); neg_diag.remove(row-col)
    backtrack(0)
    return result
</pre>
</details>
</div>`,
        safetyCheck: [
            { label: "ğŸ“‹ COPY the list!", desc: "<code>result.append(path[:])</code> â€” Without copy, all entries point to same mutating list!" },
            { label: "â†©ï¸ ALWAYS undo!", desc: "<code>path.pop()</code> or <code>swap back</code> â€” Forgetting backtrack = corrupted state for other branches." },
            { label: "ğŸ”¢ Index logic!", desc: "Subsets: i+1 both | Permute: swap | Unbounded: PICK stays at i, SKIP goes i+1" },
            { label: "âš¡ Prune early!", desc: "Check constraints BEFORE recursing: <code>if sum > target: return</code>" },
            { label: "ğŸ”„ Short-circuit OR!", desc: "Grid DFS: <code>return dfs(...) or dfs(...)</code> â€” Stop if any path succeeds." },
            { label: "ğŸ“ Mark & Unmark!", desc: "Grid: <code>board[r][c]='#'</code> before, restore original after exploring." }
        ]
    },
    questions: [
        {
            id: "n-queens",
            title: "N-Queens",
            leetcodeUrl: "https://leetcode.com/problems/n-queens/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Classic Backtracking", "Constraint Satisfaction"],
            quiz: {
                description: "Place N queens on NÃ—N board such that no two attack each other. How to check if position is safe in O(1)?",
                options: ["Loop through all queens", "3 Sets (cols, posDiag, negDiag)", "Check 8 directions", "2D visited array"],
                correct: 1,
                explanation: "3 Sets! Track: columns (col), positive diagonals (row+col), negative diagonals (row-col). Each is O(1) lookup!"
            },
            learn: {
                quickAlgo: [
                    "cols, diag, anti_diag = set(), set(), set()",
                    "res = []",
                    "def backtrack(r):",
                    "    if r == n:                     # ğŸ¯ Base Case: All queens placed",
                    "        res.append(board[:])",
                    "        return",
                    "    for c in range(n):             # âš¡ Try all columns in current row",
                    "        if c in cols or (r+c) in diag or (r-c) in anti_diag: # ğŸ”„ Valid?",
                    "            continue",
                    "        cols.add(c); diag.add(r+c); anti_diag.add(r-c) # âœ… Place & Mark",
                    "        board[r] = c",
                    "        backtrack(r + 1)           # ğŸ’¡ Recurse next row",
                    "        cols.remove(c); diag.remove(r+c); anti_diag.remove(r-c) # ğŸ”„ Backtrack logic (Unmark)"
                ],
                metrics: { time: "O(N!)", space: "O(N)" },
                timeExplainer: `<strong>Time Complexity: O(N!)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">Row-by-row placement:</strong><br><br>
â€¢ Row 0: <code>N</code> possible columns<br>
â€¢ Row 1: <code>~N-2</code> safe columns (1 col + 2 diags blocked)<br>
â€¢ Row 2: <code>~N-4</code> safe columns<br>
â€¢ ...<br><br>
<strong style="color:#10b981;">Upper bound â‰ˆ N Ã— (N-2) Ã— (N-4) Ã— ... â‰ˆ N!</strong>
</div>

<div style="background:rgba(245,158,11,0.1); padding:15px; border-radius:8px; margin-top:10px;">
<strong style="color:#fbbf24;">Example N=4:</strong><br>
Row 0: 4 choices â†’ Row 1: ~2 choices â†’ ...<br>
Total â‰ˆ 4! = 24 (actual solutions = 2)
</div>`,

                spaceExplainer: `<strong>Space Complexity: O(N)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<table style="width:100%; color:#e2e8f0;">
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ columns set</strong></td><td>O(N) - max N columns</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ posDiag set</strong></td><td>O(N) - one active per row</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ negDiag set</strong></td><td>O(N) - one active per row</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Recursion Stack</strong></td><td>O(N) - max N rows deep</td></tr>
</table>
</div>

<div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; margin-top:10px;">
<strong style="color:#10b981;">ğŸ’¡ No 2D board needed!</strong><br>
Just track queen column for each row: <code>queen_positions[row] = col</code>
</div>`,

                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.85rem; line-height: 1.6;">
<strong style="color:#fbbf24;">â™› "Laser Beams" Visualization (N=4):</strong>
<pre style="color: var(--text-muted); margin-top:10px;">
When Queen placed at (row=1, col=2):

     0   1   2   3
   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
 0 â”‚   â”‚ â†– â”‚ â†‘ â”‚ â†— â”‚   â† Attacked by diagonals & column
   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 1 â”‚ â† â”‚ â† â”‚ â™› â”‚ â†’ â”‚   â† Queen at (1, 2)
   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 2 â”‚   â”‚ â†™ â”‚ â†“ â”‚ â†˜ â”‚   â† Attacked below
   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 3 â”‚ â†™ â”‚   â”‚ â†“ â”‚   â”‚ â†˜
   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

<strong style="color:#10b981;">3 SETS track these attacks:</strong>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ columns:  {2}        â† Column 2 blocked    â”‚
â”‚ posDiag:  {3}        â† row+col = 1+2 = 3   â”‚
â”‚ negDiag:  {-1}       â† row-col = 1-2 = -1  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Same diagonal formula for ANY cell:
â€¢ (0,1): posDiag = 0+1 = 1, negDiag = 0-1 = -1 â† BLOCKED!
â€¢ (2,3): posDiag = 2+3 = 5, negDiag = 2-3 = -1 â† BLOCKED!
â€¢ (3,1): posDiag = 3+1 = 4, negDiag = 3-1 = 2  â† SAFE âœ“
</pre>
</div>`,

                crux: `<strong>The 3-Sets Constraint Pattern:</strong><br><br>
<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin:15px 0;">
<div style="background:rgba(239,68,68,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">ğŸ“</div>
<strong style="color:#ef4444;">columns</strong><br>
<code style="font-size:0.8rem;">col</code><br>
<small style="color:gray;">Vertical attack</small>
</div>
<div style="background:rgba(16,185,129,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">â†—</div>
<strong style="color:#10b981;">posDiag</strong><br>
<code style="font-size:0.8rem;">row + col</code><br>
<small style="color:gray;">â†— diagonal attack</small>
</div>
<div style="background:rgba(139,92,246,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">â†˜</div>
<strong style="color:#8b5cf6;">negDiag</strong><br>
<code style="font-size:0.8rem;">row - col</code><br>
<small style="color:gray;">â†˜ diagonal attack</small>
</div>
</div>

<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">ğŸ’¡ Why row+col and row-col?</strong><br><br>
<code>â†— Diagonal:</code> All cells have SAME (row + col)<br>
<code>â†˜ Diagonal:</code> All cells have SAME (row - col)<br><br>
<strong style="color:#10b981;">No need to check rows!</strong> We place exactly 1 queen per row.
</div>`,

                trap: `<strong>âš ï¸ Common Mistakes:</strong><br><br>

<div style="background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#f87171;">âŒ Mistake 1: Wrong diagonal formula</strong>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#ef4444;">Wrong:</span><br>
<code style="color:#f87171;">posDiag = row * col</code><br>
<small style="color:gray;">Doesn't identify same diagonal!</small>
</div>
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#10b981;">Correct:</span><br>
<code style="color:#34d399;">posDiag = row + col</code><br>
<code style="color:#34d399;">negDiag = row - col</code>
</div>
</div>
</div>

<div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#fbbf24;">âŒ Mistake 2: Forgetting to remove from sets!</strong><br>
<code style="color:#fbbf24;">columns.remove(col)  # MUST do after recursion!</code><br>
<small style="color:gray;">Without this, sets stay polluted for other branches</small>
</div>

<div style="background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.3); padding:15px; border-radius:8px;">
<strong style="color:#a78bfa;">âŒ Mistake 3: Building board wrong</strong><br>
<code style="color:#a78bfa;">'.' * col + 'Q' + '.' * (n - col - 1)</code><br>
<small style="color:gray;">Queen at position 'col', dots before and after</small>
</div>`,

                dryRun: [
                    "<strong>Input:</strong> N = 4",
                    "Initialize: columns={}, posDiag={}, negDiag={}, queen_positions=[-1,-1,-1,-1]",
                    "<code>backtrack(row=0)</code> â†’ Try each column",
                    "<strong style='color:#10b981;'>row=0, col=0:</strong> Safe! Add to sets",
                    "&nbsp;&nbsp;columns={0}, posDiag={0}, negDiag={0}",
                    "&nbsp;&nbsp;queen_positions=[0,-1,-1,-1]",
                    "&nbsp;&nbsp;<code>backtrack(row=1)</code>",
                    "&nbsp;&nbsp;<strong style='color:#ef4444;'>row=1, col=0:</strong> 0 in columns âŒ",
                    "&nbsp;&nbsp;<strong style='color:#ef4444;'>row=1, col=1:</strong> (1+1)=2 not in posDiag, but (1-1)=0 in negDiag âŒ",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>row=1, col=2:</strong> Safe!",
                    "&nbsp;&nbsp;&nbsp;&nbsp;columns={0,2}, posDiag={0,3}, negDiag={0,-1}",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(row=2)</code>",
                    "&nbsp;&nbsp;&nbsp;&nbsp;... all columns blocked for row 2 âŒ",
                    "&nbsp;&nbsp;Backtrack: Remove col=2 from sets",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>row=1, col=3:</strong> Safe! Continue...",
                    "... eventually finds solution ...",
                    "<strong>Solution 1:</strong> ['.Q..', '...Q', 'Q...', '..Q.']",
                    "<strong>Solution 2:</strong> ['..Q.', 'Q...', '...Q', '.Q..']"
                ],
                codeTitle: "Python Solution (3-Sets)",
                code: `def solveNQueens(n):
    """
    Place N queens on NÃ—N board with no attacks.
    Time: O(N!), Space: O(N)
    """
    columns = set()      # Columns with queens
    pos_diagonals = set()  # row + col values
    neg_diagonals = set()  # row - col values
    
    result = []
    queen_positions = [-1] * n  # queen_positions[row] = col
    
    def backtrack(row):
        # Base case: All queens placed!
        if row == n:
            # Build the board
            board = []
            for r in range(n):
                col = queen_positions[r]
                line = '.' * col + 'Q' + '.' * (n - col - 1)
                board.append(line)
            result.append(board)
            return
        
        # Try each column in current row
        for col in range(n):
            # Check if position is safe
            if (col in columns or 
                (row + col) in pos_diagonals or 
                (row - col) in neg_diagonals):
                continue  # Not safe, skip
            
            # === PLACE QUEEN ===
            columns.add(col)
            pos_diagonals.add(row + col)
            neg_diagonals.add(row - col)
            queen_positions[row] = col
            
            # Recurse to next row
            backtrack(row + 1)
            
            # === REMOVE QUEEN (Backtrack) ===
            columns.remove(col)
            pos_diagonals.remove(row + col)
            neg_diagonals.remove(row - col)
    
    backtrack(0)
    return result`,
                codeDetailed: `def solveNQueens_detailed(n):
    """
    N-QUEENS with 3-Sets O(1) Constraint Check
    
    WHY 3 SETS?
    - Queen attacks: row, column, both diagonals
    - We go row-by-row, so row is automatically unique
    - Need to track: column, â†— diagonal, â†˜ diagonal
    
    DIAGONAL MATH:
    - â†— diagonal: All cells have same (row + col)
      Example: (0,2), (1,1), (2,0) all have row+col = 2
    - â†˜ diagonal: All cells have same (row - col)
      Example: (0,0), (1,1), (2,2) all have row-col = 0
    """
    columns = set()
    pos_diagonals = set()  # row + col
    neg_diagonals = set()  # row - col
    
    result = []
    queen_positions = [-1] * n
    
    def backtrack(current_row):
        # === BASE CASE ===
        # All N rows filled = valid solution!
        if current_row == n:
            board = []
            for row in range(n):
                col = queen_positions[row]
                # Build row string: dots before Q, Q, dots after
                row_str = '.' * col + 'Q' + '.' * (n - col - 1)
                board.append(row_str)
            result.append(board)
            return
        
        # === TRY EACH COLUMN ===
        for col in range(n):
            # O(1) safety check using sets
            pos_diag = current_row + col
            neg_diag = current_row - col
            
            if col in columns:
                continue  # Column attacked
            if pos_diag in pos_diagonals:
                continue  # â†— Diagonal attacked
            if neg_diag in neg_diagonals:
                continue  # â†˜ Diagonal attacked
            
            # === PLACE QUEEN ===
            columns.add(col)
            pos_diagonals.add(pos_diag)
            neg_diagonals.add(neg_diag)
            queen_positions[current_row] = col
            
            # === RECURSE ===
            backtrack(current_row + 1)
            
            # === BACKTRACK ===
            # Remove queen to try other positions
            columns.remove(col)
            pos_diagonals.remove(pos_diag)
            neg_diagonals.remove(neg_diag)
    
    backtrack(0)
    return result

# Test
for solution in solveNQueens_detailed(4):
    for row in solution:
        print(row)
    print()
# Output:
# .Q..
# ...Q
# Q...
# ..Q.
#
# ..Q.
# Q...
# ...Q
# .Q..`
            }
        },
        {
            id: "permutations",
            title: "Permutations",
            leetcodeUrl: "https://leetcode.com/problems/permutations/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Swapping", "In-place"],
            quiz: {
                description: "Generate all permutations of [1,2,3]. Most space-efficient approach?",
                options: ["Iterative with queue", "Backtracking with 'visited' set", "Backtracking with Swapping", "Dynamic Programming"],
                correct: 2,
                explanation: "Swapping is most space efficient! No extra visited set needed. Swap nums[start] with nums[i], recurse, then Swap Back (Backtrack)."
            },
            learn: {
                quickAlgo: [
                    "res = []",
                    "def backtrack(first):",
                    "    if first == n:                 # ğŸ¯ Base Case: Permutation complete",
                    "        res.append(nums[:])",
                    "        return",
                    "    for i in range(first, n):      # âš¡ Swap current with all future pos",
                    "        nums[first], nums[i] = nums[i], nums[first] # ğŸ”„ Swap",
                    "        backtrack(first + 1)       # âœ… Fix 'first' and move on",
                    "        nums[first], nums[i] = nums[i], nums[first] # ğŸ’¡ Undo Swap"
                ],
                metrics: { time: "O(N Ã— N!)", space: "O(N)" },
                timeExplainer: `<strong>Why O(N Ã— N!)?</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px; margin:10px 0;">
<strong style="color:#fbbf24;">Step-by-step breakdown:</strong><br><br>
â€¢ Position 0: <code>N</code> choices<br>
â€¢ Position 1: <code>N-1</code> choices<br>
â€¢ Position 2: <code>N-2</code> choices<br>
â€¢ ...<br>
â€¢ Position N-1: <code>1</code> choice<br><br>
<strong style="color:#10b981;">Total permutations = N Ã— (N-1) Ã— ... Ã— 1 = N!</strong>
</div>

<div style="background:rgba(245,158,11,0.1); padding:15px; border-radius:8px; margin-top:10px;">
<strong style="color:#fbbf24;">+ O(N) per permutation</strong><br>
Each permutation: copy array to result = O(N)<br><br>
<strong>Final: O(N Ã— N!)</strong>
</div>

<strong style="color:#a78bfa;">Example n=3:</strong><br>
â€¢ Permutations = 3! = 6<br>
â€¢ Copy cost = 3 each<br>
â€¢ Total â‰ˆ 6 Ã— 3 = 18 operations`,

                spaceExplainer: `<strong>Space Complexity: O(N)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<table style="width:100%; color:#e2e8f0;">
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Recursion Stack</strong></td><td>O(N) - depth = N levels</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ In-place Swapping</strong></td><td>O(1) - no extra array!</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#8b5cf6;">Output (not counted)</strong></td><td>O(N! Ã— N) - result storage</td></tr>
</table>
</div>

<div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; margin-top:10px;">
<strong style="color:#10b981;">ğŸ’¡ Swapping Advantage:</strong><br>
"Visited set" approach uses O(N) extra space.<br>
Swapping approach: <strong>TRUE in-place!</strong>
</div>`,

                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.85rem; line-height: 1.6;">
<strong style="color:#fbbf24;">ğŸª‘ "Musical Chairs" Visualization:</strong>
<pre style="color: var(--text-muted); margin-top:10px;">
nums = [1, 2, 3]       start = 0

"Position 0 pe kaun baithega?"
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  i=0: Swap(0,0)    i=1: Swap(0,1)    i=2: Swap(0,2)  â”‚
â”‚  [1, 2, 3]         [2, 1, 3]         [3, 2, 1]       â”‚
â”‚      â†“                 â†“                 â†“           â”‚
â”‚  start=1           start=1           start=1        â”‚
â”‚  "Pos 1 pe kaun?"  "Pos 1 pe kaun?" "Pos 1 pe kaun?"â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Taking [1,2,3] branch (start=1):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  i=1: Swap(1,1)    i=2: Swap(1,2)  â”‚
â”‚  [1, 2, 3]         [1, 3, 2]       â”‚
â”‚      â†“                 â†“           â”‚
â”‚  start=2           start=2        â”‚
â”‚  âœ… ADD [1,2,3]    âœ… ADD [1,3,2] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Same process for [2,1,3] and [3,2,1] branches...

<strong style="color:#10b981;">Final 6 permutations:</strong>
[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
</pre>
</div>`,

                crux: `<strong>The Swap-Recurse-Unswap Pattern:</strong><br><br>
<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin:15px 0;">
<div style="background:rgba(16,185,129,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">1ï¸âƒ£</div>
<strong style="color:#10b981;">SWAP</strong><br>
<code style="font-size:0.8rem;">nums[start], nums[i] = nums[i], nums[start]</code><br>
<small style="color:gray;">Position 'start' pe element 'i' try karo</small>
</div>
<div style="background:rgba(139,92,246,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">2ï¸âƒ£</div>
<strong style="color:#8b5cf6;">RECURSE</strong><br>
<code style="font-size:0.8rem;">backtrack(start + 1)</code><br>
<small style="color:gray;">Next position fix karo</small>
</div>
<div style="background:rgba(239,68,68,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">3ï¸âƒ£</div>
<strong style="color:#ef4444;">UNSWAP</strong><br>
<code style="font-size:0.8rem;">nums[start], nums[i] = nums[i], nums[start]</code><br>
<small style="color:gray;">Wapas original state</small>
</div>
</div>

<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">ğŸ’¡ Key Insight:</strong><br>
Loop <code>i</code> from <code>start</code> to <code>n-1</code><br>
â†’ Har element ko ek baar 'start' position pe try karo!
</div>`,

                trap: `<strong>âš ï¸ Common Mistakes:</strong><br><br>

<div style="background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#f87171;">âŒ Mistake 1: Bhool gaye copy banana!</strong>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#ef4444;">Wrong:</span><br>
<code style="color:#f87171;">res.append(nums)</code>
</div>
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#10b981;">Correct:</span><br>
<code style="color:#34d399;">res.append(nums[:])</code>
</div>
</div>
<small style="color:gray;">Without copy, all entries point to same mutating list!</small>
</div>

<div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#fbbf24;">âŒ Mistake 2: Bhool gaye swap back karna!</strong><br>
<code style="color:#fbbf24;">nums[start], nums[i] = nums[i], nums[start]  // Swap BACK!</code><br>
<small style="color:gray;">Without swap back, array corrupted for other branches</small>
</div>

<div style="background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.3); padding:15px; border-radius:8px;">
<strong style="color:#a78bfa;">âŒ Mistake 3: Loop range galat!</strong><br>
<code style="color:#a78bfa;">for i in range(start, len(nums)):</code> âœ…<br>
<code style="color:#ef4444;">for i in range(0, len(nums)):</code> âŒ (duplicates!)<br>
<small style="color:gray;">i=start se start karo, 0 se nahi!</small>
</div>`,

                dryRun: [
                    "<strong>Input:</strong> nums = [1, 2, 3]",
                    "<code>backtrack(0)</code> â†’ Loop i = 0 to 2",
                    "<strong style='color:#10b981;'>i=0:</strong> Swap(0,0) â†’ [1,2,3] (no change)",
                    "&nbsp;&nbsp;<code>backtrack(1)</code> â†’ Loop i = 1 to 2",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>i=1:</strong> Swap(1,1) â†’ [1,2,3]",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(2)</code> â†’ Loop i = 2 to 2",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>i=2:</strong> Swap(2,2) â†’ [1,2,3]",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(3)</code> â†’ start==len âœ… ADD <strong>[1,2,3]</strong>",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Swap back(2,2) â†’ [1,2,3]",
                    "&nbsp;&nbsp;Swap back(1,1) â†’ [1,2,3]",
                    "&nbsp;&nbsp;<strong style='color:#fbbf24;'>i=2:</strong> Swap(1,2) â†’ [1,<strong>3</strong>,<strong>2</strong>]",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(2)</code> â†’ âœ… ADD <strong>[1,3,2]</strong>",
                    "&nbsp;&nbsp;Swap back(1,2) â†’ [1,2,3]",
                    "Swap back(0,0) â†’ [1,2,3]",
                    "<strong style='color:#fbbf24;'>i=1:</strong> Swap(0,1) â†’ [<strong>2</strong>,<strong>1</strong>,3]",
                    "&nbsp;&nbsp;... continues â†’ âœ… ADD <strong>[2,1,3]</strong>, <strong>[2,3,1]</strong>",
                    "<strong style='color:#ef4444;'>i=2:</strong> Swap(0,2) â†’ [<strong>3</strong>,2,<strong>1</strong>]",
                    "&nbsp;&nbsp;... continues â†’ âœ… ADD <strong>[3,2,1]</strong>, <strong>[3,1,2]</strong>",
                    "<strong>Final Result:</strong> [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,2,1], [3,1,2]]"
                ],
                codeTitle: "Python Solution (Swapping)",
                code: `def permute(nums):
    """
    Generate all permutations using in-place swapping
    Time: O(N Ã— N!), Space: O(N) for recursion stack
    """
    res = []

    def backtrack(start):
        # Base case: All positions fixed
        if start == len(nums):
            res.append(nums[:])  # COPY!
            return

        # Try each element at 'start' position
        for i in range(start, len(nums)):
            # 1. SWAP: Put nums[i] at position 'start'
            nums[start], nums[i] = nums[i], nums[start]

            # 2. RECURSE: Fix remaining positions
            backtrack(start + 1)

            # 3. UNSWAP: Restore for next iteration
            nums[start], nums[i] = nums[i], nums[start]

    backtrack(0)
    return res

# Alternative: Using visited set (more space)
def permute_visited(nums):
    res = []
    used = [False] * len(nums)
    path = []
    
    def backtrack():
        if len(path) == len(nums):
            res.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]: continue
            used[i] = True
            path.append(nums[i])
            backtrack()
            path.pop()
            used[i] = False
    
    backtrack()
    return res`,
                codeDetailed: `def permute_detailed(nums):
    """
    Detailed step-by-step explanation
    
    CORE IDEA:
    - "Position 0 pe kaun baithega?"
    - Try each element at position 0
    - Then recursively fill position 1, 2, ...
    
    WHY SWAPPING WORKS:
    - No extra visited set needed!
    - Elements before 'start' are FIXED
    - Elements from 'start' onwards are AVAILABLE
    - Swapping temporarily moves an element to 'start'
    """
    res = []

    def backtrack(start):
        # BASE CASE: All N positions are fixed
        # We have a complete permutation!
        if start == len(nums):
            # CRITICAL: Make a copy!
            # nums is being modified in-place
            res.append(nums[:])
            return

        # RECURSIVE CASE: Try each available element at 'start'
        # Available elements = nums[start], nums[start+1], ..., nums[n-1]
        for i in range(start, len(nums)):
            # === STEP 1: SWAP ===
            # Temporarily place nums[i] at position 'start'
            # Now nums[start] is "fixed" for this branch
            nums[start], nums[i] = nums[i], nums[start]
            
            # === STEP 2: RECURSE ===
            # With nums[start] fixed, fill remaining positions
            backtrack(start + 1)
            
            # === STEP 3: UNSWAP (Backtrack) ===
            # Restore original order before trying next element
            # This is ESSENTIAL - otherwise array stays corrupted!
            nums[start], nums[i] = nums[i], nums[start]

    backtrack(0)
    return res

# Test
print(permute_detailed([1, 2, 3]))
# Output: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]`
            }
        },
        {
            id: "subsets",
            title: "Subsets",
            leetcodeUrl: "https://leetcode.com/problems/subsets/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Pick/No-Pick", "Power Set"],
            quiz: {
                description: "Generate power set of [1,2,3]. Core decision at each element?",
                options: ["Loop n times", "Include or Exclude current element", "Swap adjacent", "Bit manipulation only"],
                correct: 1,
                explanation: "Pick/No-Pick! For every element, you have 2 choices: Include it in current subset OR Skip it. 2^N total subsets."
            },
            learn: {
                quickAlgo: [
                    "res = []",
                    "def backtrack(start, path):",
                    "    res.append(path[:])            # ğŸ¯ Capture EVERY valid subset node",
                    "    for i in range(start, n):      # âš¡ Iterate remaining options",
                    "        path.append(nums[i])       # ğŸ”„ Include nums[i]",
                    "        backtrack(i + 1, path)     # âœ… Move forward (i+1)",
                    "        path.pop()                 # ğŸ’¡ Backtrack (Exclude)"
                ],
                metrics: { time: "O(2^N Ã— N)", space: "O(N)" },
                timeExplainer: `<strong>Exponential Growth:</strong><br>
â€¢ Each element has 2 choices (Pick/No-Pick)<br>
â€¢ Total subsets = <code>2^N</code><br>
â€¢ Copying each subset takes <code>O(N)</code><br><br>
<strong>Total:</strong> <code>O(N Ã— 2^N)</code>`,
                spaceExplainer: `<strong>Space Analysis:</strong><br>
â€¢ Recursion stack depth: <code>O(N)</code><br>
â€¢ Current path array: <code>O(N)</code><br>
â€¢ Output: <code>2^N</code> subsets (not counted as aux)<br><br>
<strong>Aux Space:</strong> <code>O(N)</code>`,
                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.85rem; line-height: 1.8;">
<pre style="color: var(--text-muted);">
                    []
                    |
        "Element 1 ko LUN ya NA LUN?"
                /           \\
            PICK 1        NO-PICK 1
              [1]             []
               |               |
         "2 LUN?"        "2 LUN?"
         /     \\          /     \\
     [1,2]    [1]       [2]     []
       |       |         |       |
   "3 LUN?" "3 LUN?"  "3 LUN?" "3 LUN?"
    / \\      / \\       / \\      / \\
[1,2,3][1,2][1,3][1] [2,3][2] [3] []
</pre>
</div>`,
                crux: `<strong>The 3-Step Pattern:</strong><br>
<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin:15px 0;">
<div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; text-align:center;">
<strong style="color:#10b981;">1. PICK</strong><br>
<code>current.append(nums[i])</code>
</div>
<div style="background:rgba(139,92,246,0.1); padding:12px; border-radius:8px; text-align:center;">
<strong style="color:#8b5cf6;">2. EXPLORE</strong><br>
<code>backtrack(i + 1)</code>
</div>
<div style="background:rgba(239,68,68,0.1); padding:12px; border-radius:8px; text-align:center;">
<strong style="color:#ef4444;">3. UNPICK</strong><br>
<code>current.pop()</code>
</div>
</div>
Then call backtrack(i+1) again for NO-PICK path.`,
                trap: `<strong>âŒ Common Bug: Not Making a COPY!</strong><br><br>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px;">
<div style="background:#0f172a; padding:12px; border-radius:8px;">
<span style="color:#ef4444;">âŒ WRONG:</span><br>
<code style="color:#f87171;">result.append(current)</code><br>
<small style="color:gray;">All entries point to same list!</small>
</div>
<div style="background:#0f172a; padding:12px; border-radius:8px;">
<span style="color:#10b981;">âœ… CORRECT:</span><br>
<code style="color:#34d399;">result.append(current[:])</code><br>
<small style="color:gray;">Independent copy created!</small>
</div>
</div>`,
                dryRun: [
                    "<strong>Input:</strong> nums = [1,2,3]",
                    "<code>backtrack(0, [])</code> â†’ PICK 1 â†’ <code>current = [1]</code>",
                    "<code>backtrack(1, [1])</code> â†’ PICK 2 â†’ <code>current = [1,2]</code>",
                    "<code>backtrack(2, [1,2])</code> â†’ PICK 3 â†’ <code>current = [1,2,3]</code>",
                    "<code>backtrack(3, [1,2,3])</code> â†’ Base case! âœ… ADD <strong>[1,2,3]</strong>",
                    "<code>pop()</code> â†’ <code>current = [1,2]</code>",
                    "<code>backtrack(3, [1,2])</code> â†’ Base case! âœ… ADD <strong>[1,2]</strong>",
                    "<code>pop()</code> â†’ <code>current = [1]</code>, PICK 3 â†’ <code>current = [1,3]</code>",
                    "... continues for all 8 subsets",
                    "<strong>Final:</strong> [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]"
                ],
                codeTitle: "Python Solution (Pick/No-Pick)",
                code: `def subsets(nums):
    """
    Generate all subsets using Pick/No-Pick backtracking
    Time: O(2^n Ã— n), Space: O(n)
    """
    result = []
    
    def backtrack(index, current):
        # Base case: processed all elements
        if index == len(nums):
            result.append(current[:])  # COPY!
            return
        
        # PICK current element
        current.append(nums[index])
        backtrack(index + 1, current)
        current.pop()  # Backtrack
        
        # NO-PICK current element
        backtrack(index + 1, current)
    
    backtrack(0, [])
    return result

# Alternative: Iterative approach
def subsets_iterative(nums):
    result = [[]]
    for num in nums:
        result += [subset + [num] for subset in result]
    return result`,
                codeDetailed: `def subsets_detailed(nums):
    """
    Detailed version with step-by-step explanation
    """
    result = []
    
    def backtrack(index, current):
        # Base case: We've made decisions for all elements
        # Every path through the decision tree is a valid subset
        if index == len(nums):
            # CRITICAL: Append a COPY, not the reference!
            # current is a mutable list - without [:], 
            # all entries in result would point to same list
            result.append(current[:])
            return
        
        # === DECISION 1: PICK current element ===
        current.append(nums[index])  # Add to current subset
        backtrack(index + 1, current)  # Explore with this element
        
        # === BACKTRACK: Undo the choice ===
        current.pop()  # Remove to explore "no-pick" path
        
        # === DECISION 2: NO-PICK current element ===
        # current is now clean (without nums[index])
        backtrack(index + 1, current)  # Explore without this element
    
    # Start from index 0 with empty subset
    backtrack(0, [])
    return result

# Test with dry run
print(subsets_detailed([1, 2, 3]))
# Output: [[], [3], [2], [2,3], [1], [1,3], [2,3], [1,2,3]]`
            }
        },
        {
            id: "combination-sum",
            title: "Combination Sum",
            leetcodeUrl: "https://leetcode.com/problems/combination-sum/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Unbounded Knapsack", "Reuse Allowed"],
            quiz: {
                description: "Candidates = [2,3,6,7], Target = 7. Elements can be reused. Key logic?",
                options: ["Pass index i+1 always", "Pass index i (Stay) when picking", "Use a visited set", "Sort and use binary search"],
                correct: 1,
                explanation: "Pass `i` (Stay)! Since we can reuse the same element unlimited times, we recurse with SAME index when picking. Only increment to i+1 when we SKIP."
            },
            learn: {
                quickAlgo: [
                    "res = []",
                    "def backtrack(start, path, remain):",
                    "    if remain == 0:                # ğŸ¯ Found valid combination!",
                    "        res.append(path[:])",
                    "        return",
                    "    for i in range(start, len(cand)):",
                    "        if cand[i] > remain: break # âš¡ Pruning (sorted array)",
                    "        path.append(cand[i])       # ğŸ”„ Include",
                    "        backtrack(i, path, remain - cand[i]) # âœ… i not i+1 (reuse allowed)",
                    "        path.pop()                 # ğŸ’¡ Backtrack"
                ],
                metrics: { time: "O(N^(T/M))", space: "O(T/M)" },
                timeExplainer: `<strong>Time Complexity: O(N^(T/M))</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">Variables:</strong><br>
â€¢ N = number of candidates<br>
â€¢ T = target sum<br>
â€¢ M = minimum candidate value<br><br>

<strong style="color:#10b981;">Why T/M?</strong><br>
Maximum depth of recursion = T/M<br>
(If min candidate is 2 and target is 7, max depth = 7/2 â‰ˆ 3)
</div>

<div style="background:rgba(245,158,11,0.1); padding:15px; border-radius:8px; margin-top:10px;">
<strong style="color:#fbbf24;">Example: candidates=[2,3], target=7</strong><br>
â€¢ Min = 2, so max depth = 7/2 â‰ˆ 3-4 levels<br>
â€¢ At each level, N choices<br>
â€¢ Total â‰ˆ N^(T/M) = 2^3 = 8 nodes (roughly)
</div>

<strong style="color:#a78bfa;">Note:</strong> Often written as O(2^T) upper bound`,

                spaceExplainer: `<strong>Space Complexity: O(T/M)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<table style="width:100%; color:#e2e8f0;">
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Recursion Stack</strong></td><td>O(T/M) - max elements in a valid combination</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Current Path</strong></td><td>O(T/M) - same bound</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#8b5cf6;">Output</strong></td><td>Varies based on valid combinations</td></tr>
</table>
</div>

<div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; margin-top:10px;">
<strong style="color:#10b981;">ğŸ’¡ Example:</strong><br>
target=7, min candidate=2<br>
Max path length = 7/2 â‰ˆ 3 (like [2,2,3])<br>
So space = O(3) = O(T/M)
</div>`,

                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.85rem; line-height: 1.6;">
<strong style="color:#fbbf24;">ğŸª™ "Unlimited Coins" Visualization:</strong>
<pre style="color: var(--text-muted); margin-top:10px;">
candidates = [2, 3], target = 7

             backtrack(i=0, sum=0)
             "2 LUN ya NA LUN?"
                /           \\
         PICK 2            SKIP 2
        sum=2              (move to i=1)
        i=0 (STAY!)         
           |                  |
    "Phir se 2 LUN?"     "3 LUN ya NA LUN?"
         /     \\              /        \\
    PICK 2   SKIP 2       PICK 3     SKIP 3
    sum=4    (i=1)        sum=3      (done)
    i=0                   i=1
       |                    |
  "Phir se 2?"         "Phir se 3?"
     /    \\                 |
  PICK 2  SKIP           PICK 3
  sum=6                  sum=6
  i=0                    i=1
     |                     |
  PICK 2?              PICK 3?
  sum=8 âŒ             sum=9 âŒ
  (>target)            (>target)
  
âœ… Valid paths: [2,2,3] (sum=7), [7] (if 7 in candidates)
</pre>
</div>`,

                crux: `<strong>The Stay vs Move Pattern (Unbounded Knapsack):</strong><br><br>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:15px; margin:15px 0;">
<div style="background:rgba(16,185,129,0.15); padding:20px; border-radius:12px; border:2px solid rgba(16,185,129,0.3);">
<div style="font-size:1.5rem; margin-bottom:10px;">âœ… PICK (LUN)</div>
<strong style="color:#10b981;">Stay at same index!</strong><br><br>
<code style="font-size:0.85rem; background:#0f172a; padding:8px; border-radius:4px; display:block;">
path.append(candidates[i])<br>
backtrack(<strong style="color:#10b981;">i</strong>, path, sum + candidates[i])<br>
path.pop()
</code><br>
<small style="color:gray;">Element reuse allowed â†’ i stays same</small>
</div>
<div style="background:rgba(239,68,68,0.15); padding:20px; border-radius:12px; border:2px solid rgba(239,68,68,0.3);">
<div style="font-size:1.5rem; margin-bottom:10px;">âŒ SKIP (NA LUN)</div>
<strong style="color:#ef4444;">Move to next index!</strong><br><br>
<code style="font-size:0.85rem; background:#0f172a; padding:8px; border-radius:4px; display:block;">
backtrack(<strong style="color:#ef4444;">i + 1</strong>, path, sum)
</code><br>
<small style="color:gray;">Done with this element forever â†’ i+1</small>
</div>
</div>

<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">âš¡ Key Difference from Subsets:</strong><br>
Subsets: Both paths use <code>i+1</code><br>
Combination Sum: PICK uses <code>i</code>, SKIP uses <code>i+1</code>
</div>`,

                trap: `<strong>âš ï¸ Common Mistakes:</strong><br><br>

<div style="background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#f87171;">âŒ Mistake 1: Using i+1 for PICK call</strong>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#ef4444;">Wrong:</span><br>
<code style="color:#f87171;">backtrack(i+1, sum+val)</code><br>
<small style="color:gray;">Can't reuse elements!</small>
</div>
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#10b981;">Correct:</span><br>
<code style="color:#34d399;">backtrack(i, sum+val)</code><br>
<small style="color:gray;">Stay at i for reuse</small>
</div>
</div>
</div>

<div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#fbbf24;">âŒ Mistake 2: Forgetting sum > target check</strong><br>
<code style="color:#fbbf24;">if sum > target: return  # MUST have this!</code><br>
<small style="color:gray;">Without this, infinite recursion if min candidate taken repeatedly</small>
</div>

<div style="background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.3); padding:15px; border-radius:8px;">
<strong style="color:#a78bfa;">âŒ Mistake 3: Negative candidates</strong><br>
<small style="color:gray;">If candidates had negative numbers â†’ infinite loop!<br>
sum would never exceed target. Problem guarantees positive numbers.</small>
</div>`,

                dryRun: [
                    "<strong>Input:</strong> candidates = [2, 3], target = 7",
                    "<code>backtrack(0, [], 0)</code> â†’ sum=0 < 7, continue",
                    "<strong style='color:#10b981;'>PICK 2:</strong> path=[2], sum=2",
                    "&nbsp;&nbsp;<code>backtrack(0, [2], 2)</code> â†’ stay at i=0",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 2:</strong> path=[2,2], sum=4",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(0, [2,2], 4)</code>",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 2:</strong> path=[2,2,2], sum=6",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>backtrack(0, [2,2,2], 6)</code>",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 2:</strong> sum=8 > 7 âŒ return",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#ef4444;'>SKIP 2:</strong> move to i=1",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 3:</strong> sum=9 > 7 âŒ return",
                    "&nbsp;&nbsp;&nbsp;&nbsp;pop() â†’ path=[2,2]",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#ef4444;'>SKIP 2:</strong> move to i=1, path=[2,2], sum=4",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 3:</strong> path=[2,2,3], sum=7 âœ… <strong>ADD [2,2,3]</strong>",
                    "&nbsp;&nbsp;... backtrack continues ...",
                    "&nbsp;&nbsp;<strong style='color:#ef4444;'>SKIP all 2s:</strong> â†’ try [3,...]",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 3:</strong> path=[3], sum=3",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 3:</strong> path=[3,3], sum=6",
                    "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#10b981;'>PICK 3:</strong> sum=9 > 7 âŒ",
                    "<strong>Final Result:</strong> [[2,2,3], [7]] (if 7 was in candidates)"
                ],
                codeTitle: "Python Solution (Unbounded Knapsack)",
                code: `def combinationSum(candidates, target):
    """
    Find all unique combinations that sum to target.
    Elements can be reused unlimited times.
    Time: O(N^(T/M)), Space: O(T/M)
    """
    res = []

    def backtrack(i, current_path, current_sum):
        # Base Case 1: Found valid combination!
        if current_sum == target:
            res.append(current_path[:])  # COPY!
            return
        
        # Base Case 2: Invalid - out of bounds or exceeded
        if i >= len(candidates) or current_sum > target:
            return

        # CHOICE 1: PICK (LUN) - Stay at index i
        current_path.append(candidates[i])
        backtrack(i, current_path, current_sum + candidates[i])
        
        # BACKTRACK: Undo the choice
        current_path.pop()

        # CHOICE 2: SKIP (NA LUN) - Move to i+1
        backtrack(i + 1, current_path, current_sum)

    backtrack(0, [], 0)
    return res

# Test
print(combinationSum([2,3,6,7], 7))
# Output: [[2,2,3], [7]]`,
                codeDetailed: `def combinationSum_detailed(candidates, target):
    """
    UNBOUNDED KNAPSACK Pattern:
    - Same as 0/1 Knapsack, but elements can be reused
    - Key difference: PICK stays at 'i', doesn't move to 'i+1'
    
    WHY STAY AT i?
    - [2,3], target=7
    - If we need [2,2,3], we must pick '2' multiple times
    - Staying at i=0 allows: pick 2, pick 2 again, then move on
    
    WHY SKIP MOVES TO i+1?
    - Once we decide "no more 2s", we're done with index 0
    - Move to index 1 (element 3) permanently
    """
    res = []

    def backtrack(i, path, current_sum):
        # === BASE CASE 1: SUCCESS ===
        # We found a valid combination!
        if current_sum == target:
            res.append(path[:])  # Make a copy
            return
        
        # === BASE CASE 2: FAILURE ===
        # Out of candidates OR sum exceeded target
        if i >= len(candidates) or current_sum > target:
            return

        # === CHOICE 1: PICK current element ===
        # Key: We can pick it AGAIN, so stay at index i
        path.append(candidates[i])
        backtrack(i, path, current_sum + candidates[i])  # i, not i+1!
        
        # === BACKTRACK ===
        # Remove the element we just added
        path.pop()

        # === CHOICE 2: SKIP current element ===
        # We're done with this element forever, move to next
        backtrack(i + 1, path, current_sum)  # i+1, move on!

    backtrack(0, [], 0)
    return res

# Comparison with Combination Sum II (no reuse):
def combinationSum2(candidates, target):
    """
    In Combination Sum II, each element used ONCE
    So PICK also uses i+1, not i
    """
    candidates.sort()  # Sort to handle duplicates
    res = []
    
    def backtrack(i, path, total):
        if total == target:
            res.append(path[:])
            return
        if total > target:
            return
            
        for j in range(i, len(candidates)):
            # Skip duplicates at same level
            if j > i and candidates[j] == candidates[j-1]:
                continue
            path.append(candidates[j])
            backtrack(j + 1, path, total + candidates[j])  # j+1, not j!
            path.pop()
    
    backtrack(0, [], 0)
    return res`
            }
        },
        {
            id: "word-search",
            title: "Word Search",
            leetcodeUrl: "https://leetcode.com/problems/word-search/",
            difficulty: "Must Do",
            priority: "ğŸ”´",
            tags: ["Grid DFS", "Backtracking"],
            quiz: {
                description: "Find 'ABCCED' in 2D grid. Can same cell be visited twice in one path?",
                options: ["Yes, any cell can be reused", "No, but can use in different paths", "Only adjacent cells matter", "Diagonals allowed"],
                correct: 1,
                explanation: "No reuse in SAME path! Mark cell as visited (#), explore 4 directions, then UNMARK (backtrack). Cell can be used in different paths though."
            },
            learn: {
                quickAlgo: [
                    "def dfs(r, c, k):",
                    "    if k == len(word): return True # ğŸ¯ Word Found!",
                    "    if not (0 <= r < ROWS and 0 <= c < COLS) or board[r][c] != word[k]: return False # âš¡ Mismatch/Off-board",
                    "    temp, board[r][c] = board[r][c], '#' # ğŸ”„ Mark visited",
                    "    found = (dfs(r+1,c,k+1) or dfs(r-1,c,k+1) or dfs(r,c+1,k+1) or dfs(r,c-1,k+1)) # âœ… Try 4 dirs",
                    "    board[r][c] = temp             # ğŸ’¡ Unmark (Backtrack)",
                    "    return found"
                ],
                metrics: { time: "O(MÃ—N Ã— 3^L)", space: "O(L)" },
                timeExplainer: `<strong>Time Complexity: O(MÃ—N Ã— 3^L)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">Breaking it down:</strong><br><br>
â€¢ <strong style="color:#10b981;">M Ã— N</strong> = Grid cells (each can be starting point)<br>
â€¢ <strong style="color:#10b981;">3^L</strong> = DFS branching factor<br><br>

<strong style="color:#a78bfa;">Why 3, not 4?</strong><br>
First cell: 4 directions possible<br>
But after that: 3 directions (can't go back to where we came from!)
</div>

<div style="background:rgba(245,158,11,0.1); padding:15px; border-radius:8px; margin-top:10px;">
<strong style="color:#fbbf24;">Example:</strong><br>
Grid = 3Ã—4, Word = "ABCDEF" (L=6)<br>
Time â‰ˆ 12 Ã— 3^6 = 12 Ã— 729 â‰ˆ 8748 operations
</div>`,

                spaceExplainer: `<strong>Space Complexity: O(L)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<table style="width:100%; color:#e2e8f0;">
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Recursion Stack</strong></td><td>O(L) - max depth = word length</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ In-place Marking</strong></td><td>O(1) - no extra grid needed!</td></tr>
</table>
</div>

<div style="background:rgba(16,185,129,0.1); padding:12px; border-radius:8px; margin-top:10px;">
<strong style="color:#10b981;">ğŸ’¡ Space Optimization:</strong><br>
We mark visited cells by replacing with '#'<br>
No separate visited[][] array needed!
</div>`,

                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.85rem; line-height: 1.6;">
<strong style="color:#fbbf24;">ğŸ "The Snake" Visualization:</strong>
<pre style="color: var(--text-muted); margin-top:10px;">
Grid:                  Finding "ABC"
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ E â”‚      Step 1: Start at (0,0), char='A' âœ“
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤              Mark A â†’ #
â”‚ S â”‚ F â”‚ C â”‚ S â”‚      
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤      â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ D â”‚ E â”‚ E â”‚      â”‚ # â”‚ B â”‚ C â”‚ E â”‚  ğŸ at A
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜      â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
                       â”‚ S â”‚ F â”‚ C â”‚ S â”‚
                       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

Step 2: Move right to (0,1), char='B' âœ“
        Mark B â†’ #
        
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”      Step 3: Move right to (0,2), char='C' âœ“
â”‚ # â”‚ # â”‚ C â”‚ E â”‚              Mark C â†’ #
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤      
â”‚ S â”‚ F â”‚ C â”‚ S â”‚      â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜      â”‚ # â”‚ # â”‚ # â”‚ E â”‚  ğŸ found "ABC" âœ…
                       â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜

If dead end â†’ Unmark and try another direction
(Snake retreats and tries different path)
</pre>
</div>`,

                crux: `<strong>The Mark-Explore-Unmark Pattern:</strong><br><br>
<div style="display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin:15px 0;">
<div style="background:rgba(239,68,68,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.2rem; margin-bottom:8px;">0ï¸âƒ£</div>
<strong style="color:#ef4444;">CHECK</strong><br>
<small style="color:gray;">Bounds & Match</small>
</div>
<div style="background:rgba(16,185,129,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.2rem; margin-bottom:8px;">1ï¸âƒ£</div>
<strong style="color:#10b981;">MARK</strong><br>
<code style="font-size:0.75rem;">board[r][c]='#'</code>
</div>
<div style="background:rgba(139,92,246,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.2rem; margin-bottom:8px;">2ï¸âƒ£</div>
<strong style="color:#8b5cf6;">EXPLORE</strong><br>
<small style="color:gray;">4 Directions</small>
</div>
<div style="background:rgba(245,158,11,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.2rem; margin-bottom:8px;">3ï¸âƒ£</div>
<strong style="color:#fbbf24;">UNMARK</strong><br>
<code style="font-size:0.75rem;">board[r][c]=temp</code>
</div>
</div>

<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">4 Directions:</strong><br>
<code>dfs(r+1, c) or dfs(r-1, c) or dfs(r, c+1) or dfs(r, c-1)</code><br><br>
<strong style="color:#10b981;">ğŸ’¡ Use OR short-circuit:</strong> If any direction returns True, stop immediately!
</div>`,

                trap: `<strong>âš ï¸ Common Mistakes:</strong><br><br>

<div style="background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#f87171;">âŒ Mistake 1: Forgetting to UNMARK!</strong>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#ef4444;">Wrong:</span><br>
<code style="color:#f87171; font-size:0.8rem;">board[r][c] = '#'<br>return dfs(...)</code><br>
<small style="color:gray;">Cell stays marked forever!</small>
</div>
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#10b981;">Correct:</span><br>
<code style="color:#34d399; font-size:0.8rem;">temp = board[r][c]<br>board[r][c] = '#'<br>res = dfs(...)<br>board[r][c] = temp</code>
</div>
</div>
</div>

<div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#fbbf24;">âŒ Mistake 2: Not using short-circuit OR</strong><br>
<code style="color:#fbbf24;">return dfs(r+1,c) or dfs(r-1,c) or ...</code> âœ…<br>
<small style="color:gray;">If first direction works, skip others! Much faster.</small>
</div>

<div style="background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.3); padding:15px; border-radius:8px;">
<strong style="color:#a78bfa;">âŒ Mistake 3: Wrong order of checks</strong><br>
<code style="color:#a78bfa;">if i == len(word): return True  # Check SUCCESS first!</code><br>
<code style="color:#a78bfa;">if out_of_bounds or mismatch: return False</code><br>
<small style="color:gray;">Check base case BEFORE bounds check!</small>
</div>`,

                dryRun: [
                    "<strong>Input:</strong> board = [['A','B'],['C','D']], word = 'ABCD'",
                    "<code>exist(board, 'ABCD')</code> â†’ Try each cell as start",
                    "<strong style='color:#10b981;'>Start (0,0):</strong> board[0][0]='A' == word[0] âœ“",
                    "&nbsp;&nbsp;Mark: board[0][0] = '#'",
                    "&nbsp;&nbsp;<code>dfs(0, 0, 0)</code> â†’ i=0 matches, explore 4 dirs",
                    "&nbsp;&nbsp;<strong style='color:#8b5cf6;'>Try RIGHT (0,1):</strong> board[0][1]='B' == word[1] âœ“",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Mark: board[0][1] = '#'",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<code>dfs(0, 1, 1)</code> â†’ explore from B",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#8b5cf6;'>Try DOWN (1,1):</strong> board[1][1]='D' != word[2]='C' âŒ",
                    "&nbsp;&nbsp;&nbsp;&nbsp;<strong style='color:#8b5cf6;'>Try LEFT (0,0):</strong> board[0][0]='#' (visited) âŒ",
                    "&nbsp;&nbsp;&nbsp;&nbsp;All directions failed from B",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Unmark: board[0][1] = 'B'",
                    "&nbsp;&nbsp;<strong style='color:#ef4444;'>RIGHT failed,</strong> try DOWN (1,0)",
                    "&nbsp;&nbsp;<strong style='color:#8b5cf6;'>Try DOWN (1,0):</strong> board[1][0]='C' == word[1]='B' âŒ",
                    "&nbsp;&nbsp;Unmark: board[0][0] = 'A'",
                    "<strong style='color:#fbbf24;'>Start (0,0) failed.</strong> Try next cell...",
                    "... continues trying other starting positions ...",
                    "<strong>Final:</strong> Return True if any path found, else False"
                ],
                codeTitle: "Python Solution (Grid Backtracking)",
                code: `def exist(board, word):
    """
    Find if word exists in grid via adjacent cells.
    Time: O(MÃ—N Ã— 3^L), Space: O(L)
    """
    ROWS, COLS = len(board), len(board[0])
    
    def dfs(row, col, char_index):
        # Base Case 1: Found complete word!
        if char_index == len(word):
            return True
        
        # Base Case 2: Out of bounds or mismatch
        if (row < 0 or row >= ROWS or 
            col < 0 or col >= COLS or 
            board[row][col] != word[char_index]):
            return False
        
        # MARK: Save char and mark as visited
        original_char = board[row][col]
        board[row][col] = '#'
        
        # EXPLORE: Try all 4 directions (short-circuit OR)
        found = (dfs(row+1, col, char_index+1) or   # Down
                 dfs(row-1, col, char_index+1) or   # Up
                 dfs(row, col+1, char_index+1) or   # Right
                 dfs(row, col-1, char_index+1))     # Left
        
        # UNMARK: Restore for other paths
        board[row][col] = original_char
        
        return found
    
    # Try each cell as starting point
    for row in range(ROWS):
        for col in range(COLS):
            if dfs(row, col, 0):
                return True
    return False`,
                codeDetailed: `def exist_detailed(board, word):
    """
    GRID BACKTRACKING Pattern:
    
    WHY MARK AND UNMARK?
    - Same cell can't be used twice in ONE path
    - But can be used in DIFFERENT paths
    - Mark '#' prevents revisiting in current DFS
    - Unmark allows reuse when we backtrack
    
    WHY SHORT-CIRCUIT OR?
    - dfs(...) or dfs(...) or ...
    - If first returns True, others don't execute
    - Massive optimization for early termination
    """
    ROWS, COLS = len(board), len(board[0])
    
    def dfs(row, col, char_index):
        # === BASE CASE 1: SUCCESS ===
        # We've matched entire word!
        if char_index == len(word):
            return True
        
        # === BASE CASE 2: FAILURE ===
        # Out of grid bounds
        if row < 0 or row >= ROWS or col < 0 or col >= COLS:
            return False
        
        # Current cell doesn't match required char
        if board[row][col] != word[char_index]:
            return False
        
        # === MARK AS VISITED ===
        # Save original char, replace with '#'
        # This prevents revisiting in current path
        original_char = board[row][col]
        board[row][col] = '#'
        
        # === EXPLORE 4 DIRECTIONS ===
        # Use OR for short-circuit evaluation
        # If any direction succeeds, return True immediately
        found = (
            dfs(row + 1, col, char_index + 1) or  # Down
            dfs(row - 1, col, char_index + 1) or  # Up  
            dfs(row, col + 1, char_index + 1) or  # Right
            dfs(row, col - 1, char_index + 1)     # Left
        )
        
        # === UNMARK (BACKTRACK) ===
        # Restore original char for other paths
        # This is CRITICAL - cell can be used in other paths
        board[row][col] = original_char
        
        return found
    
    # Try every cell as potential starting point
    for row in range(ROWS):
        for col in range(COLS):
            # If first char matches, start DFS
            if dfs(row, col, 0):
                return True
    
    return False

# Cleaner version using direction array:
def exist_clean(board, word):
    ROWS, COLS = len(board), len(board[0])
    DIRECTIONS = [(0,1), (1,0), (0,-1), (-1,0)]  # Right, Down, Left, Up
    
    def dfs(row, col, char_index):
        if char_index == len(word): 
            return True
        if not (0 <= row < ROWS and 0 <= col < COLS): 
            return False
        if board[row][col] != word[char_index]: 
            return False
        
        original_char = board[row][col]
        board[row][col] = '#'
        
        for delta_row, delta_col in DIRECTIONS:
            if dfs(row + delta_row, col + delta_col, char_index + 1):
                board[row][col] = original_char
                return True
        
        board[row][col] = original_char
        return False
    
    return any(dfs(row, col, 0) 
               for row in range(ROWS) 
               for col in range(COLS))`
            }
        },
        {
            id: "sudoku-solver",
            title: "Sudoku Solver",
            leetcodeUrl: "https://leetcode.com/problems/sudoku-solver/",
            difficulty: "Bonus",
            priority: "ğŸŸ¡",
            tags: ["Hard", "Constraint Satisfaction"],
            quiz: {
                description: "Fill empty cells in 9Ã—9 Sudoku grid. What's the key constraint to check?",
                options: ["Only row uniqueness", "Row + Column", "Row + Column + 3Ã—3 Box", "Random fill and verify"],
                correct: 2,
                explanation: "3 Constraints! Each number 1-9 must appear exactly once in: (1) Row, (2) Column, (3) 3Ã—3 Box. Backtrack when any constraint violated."
            },
            learn: {
                quickAlgo: [
                    "def solve():",
                    "    for r in range(9):",
                    "        for c in range(9):",
                    "            if board[r][c] == '.': # ğŸ¯ Find empty cell",
                    "                for digit in '123456789': # âš¡ Try digits 1-9",
                    "                    if is_valid(r, c, digit): # ğŸ”„ Check constraints",
                    "                        board[r][c] = digit # âœ… Place digit",
                    "                        if solve(): return True # ğŸ’¡ Recurse & propagate success",
                    "                        board[r][c] = '.' # ğŸ”„ Backtrack",
                    "                return False # No digit works, backtrack",
                    "    return True # All cells filled, solved!"
                ],
                metrics: { time: "O(9^M)", space: "O(M)" },
                timeExplainer: `<strong>Time Complexity: O(9^M)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">Where M = number of empty cells</strong><br><br>
â€¢ Each empty cell: up to 9 choices<br>
â€¢ M empty cells to fill<br>
â€¢ Worst case: try all combinations<br><br>
<strong style="color:#ef4444;">Upper bound = 9^M</strong>
</div>

<div style="background:rgba(16,185,129,0.1); padding:15px; border-radius:8px; margin-top:10px;">
<strong style="color:#10b981;">ğŸ’¡ Pruning helps a LOT!</strong><br>
Early constraint checks eliminate most branches.<br>
Typical Sudoku: ~17 given â†’ ~64 empty â†’ still fast!
</div>`,

                spaceExplainer: `<strong>Space Complexity: O(M)</strong><br><br>
<div style="background:#0f172a; padding:15px; border-radius:8px;">
<table style="width:100%; color:#e2e8f0;">
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ Recursion Stack</strong></td><td>O(M) - max M empty cells deep</td></tr>
<tr><td style="padding:8px 0;"><strong style="color:#10b981;">âœ“ In-place Modification</strong></td><td>O(1) - modify board directly</td></tr>
</table>
</div>

<div style="background:rgba(245,158,11,0.1); padding:12px; border-radius:8px; margin-top:10px;">
<strong style="color:#fbbf24;">Optimization:</strong> Use 3 sets (rows, cols, boxes)<br>
for O(1) validity check instead of O(9) loop.
</div>`,

                visual: `<div style="text-align:left; font-family: monospace; font-size: 0.8rem; line-height: 1.5;">
<strong style="color:#fbbf24;">ğŸ”¢ Sudoku 3-Constraint Visualization:</strong>
<pre style="color: var(--text-muted); margin-top:10px;">
Filling cell (row=0, col=2):

     0   1   2   3   4   5   6   7   8
   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
 0 â”‚ 5 â”‚ 3 â”‚ ? â”‚ . â”‚ 7 â”‚ . â”‚ . â”‚ . â”‚ . â”‚  â† ROW 0: has 5,3,7
   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 1 â”‚ 6 â”‚ . â”‚ . â”‚ 1 â”‚ 9 â”‚ 5 â”‚ . â”‚ . â”‚ . â”‚
   â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
 2 â”‚ . â”‚ 9 â”‚ 8 â”‚ . â”‚ . â”‚ . â”‚ . â”‚ 6 â”‚ . â”‚
   â”œâ”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”¼â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”¤
               â†‘
            COL 2: has 8
   
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚ 5 â”‚ 3 â”‚ ? â”‚  â† BOX 0 (top-left 3Ã—3)
   â”‚ 6 â”‚ . â”‚ . â”‚     Already has: 5, 3, 6, 9, 8
   â”‚ . â”‚ 9 â”‚ 8 â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<strong style="color:#10b981;">Valid choices for (0,2):</strong>
Row 0 blocks: {5, 3, 7}
Col 2 blocks: {8}
Box 0 blocks: {5, 3, 6, 9, 8}
Combined: {3, 5, 6, 7, 8, 9}
<strong style="color:#fbbf24;">Available: {1, 2, 4} â†’ Try 1 first!</strong>

<strong style="color:#a78bfa;">Box Index Formula:</strong>
box_index = (row // 3) * 3 + (col // 3)
For (0, 2): (0//3)*3 + (2//3) = 0*3 + 0 = Box 0
</pre>
</div>`,

                crux: `<strong>The 3-Constraint Check Pattern:</strong><br><br>
<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:10px; margin:15px 0;">
<div style="background:rgba(239,68,68,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">â¡ï¸</div>
<strong style="color:#ef4444;">ROW</strong><br>
<code style="font-size:0.75rem;">board[row][0..8]</code><br>
<small style="color:gray;">Check all 9 columns</small>
</div>
<div style="background:rgba(16,185,129,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">â¬‡ï¸</div>
<strong style="color:#10b981;">COLUMN</strong><br>
<code style="font-size:0.75rem;">board[0..8][col]</code><br>
<small style="color:gray;">Check all 9 rows</small>
</div>
<div style="background:rgba(139,92,246,0.1); padding:15px; border-radius:8px; text-align:center;">
<div style="font-size:1.5rem; margin-bottom:8px;">â¬œ</div>
<strong style="color:#8b5cf6;">3Ã—3 BOX</strong><br>
<code style="font-size:0.7rem;">box_row = 3*(row//3)</code><br>
<code style="font-size:0.7rem;">box_col = 3*(col//3)</code>
</div>
</div>

<div style="background:#0f172a; padding:15px; border-radius:8px;">
<strong style="color:#fbbf24;">ğŸ’¡ Box Cell Access:</strong><br>
<code>for i in range(9):</code><br>
<code>&nbsp;&nbsp;box_row + i // 3, box_col + i % 3</code><br><br>
This iterates all 9 cells in the 3Ã—3 box!
</div>`,

                trap: `<strong>âš ï¸ Common Mistakes:</strong><br><br>

<div style="background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#f87171;">âŒ Mistake 1: Not returning True when solved!</strong>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:10px;">
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#ef4444;">Wrong:</span><br>
<code style="color:#f87171; font-size:0.8rem;">if solve(): pass</code><br>
<small style="color:gray;">Solution gets overwritten!</small>
</div>
<div style="background:#0f172a; padding:10px; border-radius:6px;">
<span style="color:#10b981;">Correct:</span><br>
<code style="color:#34d399; font-size:0.8rem;">if solve(): return True</code><br>
<small style="color:gray;">Propagate success up!</small>
</div>
</div>
</div>

<div style="background:rgba(245,158,11,0.1); border:1px solid rgba(245,158,11,0.3); padding:15px; border-radius:8px; margin-bottom:15px;">
<strong style="color:#fbbf24;">âŒ Mistake 2: Wrong box index formula</strong><br>
<code style="color:#34d399;">box_row = 3 * (row // 3)</code> âœ…<br>
<code style="color:#f87171;">box_row = row // 3</code> âŒ<br>
<small style="color:gray;">Must multiply by 3 to get actual row index!</small>
</div>

<div style="background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.3); padding:15px; border-radius:8px;">
<strong style="color:#a78bfa;">âŒ Mistake 3: Forgetting to reset cell on backtrack</strong><br>
<code style="color:#a78bfa;">board[row][col] = '.'  # MUST reset!</code><br>
<small style="color:gray;">Without this, wrong values stay and corrupt other branches</small>
</div>`,

                dryRun: [
                    "<strong>Input:</strong> 9Ã—9 Sudoku with empty cells marked '.'",
                    "<code>solve()</code> â†’ Find first empty cell",
                    "<strong style='color:#10b981;'>Found empty:</strong> (row=0, col=2)",
                    "Loop: Try digits '1' to '9'",
                    "&nbsp;&nbsp;<strong style='color:#fbbf24;'>Try '1':</strong> isValid(0, 2, '1')?",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Check row 0: '1' not in row âœ“",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Check col 2: '1' not in col âœ“",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Check box 0: '1' not in box âœ“",
                    "&nbsp;&nbsp;<strong style='color:#10b981;'>Valid!</strong> board[0][2] = '1'",
                    "&nbsp;&nbsp;<code>solve()</code> â†’ Find next empty (0, 3)",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Try '1': Already 1 in row 0 âŒ",
                    "&nbsp;&nbsp;&nbsp;&nbsp;Try '2': Valid! Place and recurse...",
                    "&nbsp;&nbsp;&nbsp;&nbsp;... continues recursively ...",
                    "&nbsp;&nbsp;Eventually hits dead end (no valid digit)",
                    "&nbsp;&nbsp;<strong style='color:#ef4444;'>Backtrack:</strong> board[0][2] = '.'",
                    "&nbsp;&nbsp;<strong style='color:#fbbf24;'>Try '2':</strong> Continue with next digit...",
                    "... continues until solved ...",
                    "<strong>All cells filled:</strong> return True âœ…"
                ],
                codeTitle: "Python Solution (Backtracking)",
                code: `def solveSudoku(board):
    """
    Solve Sudoku by filling empty cells with valid digits.
    Time: O(9^M), Space: O(M) where M = empty cells
    """
    
    def is_valid(row, col, digit):
        # Check row
        for c in range(9):
            if board[row][c] == digit:
                return False
        
        # Check column
        for r in range(9):
            if board[r][col] == digit:
                return False
        
        # Check 3x3 box
        box_row = 3 * (row // 3)
        box_col = 3 * (col // 3)
        for i in range(9):
            r = box_row + i // 3
            c = box_col + i % 3
            if board[r][c] == digit:
                return False
        
        return True
    
    def solve():
        # Find next empty cell
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    # Try each digit 1-9
                    for digit in '123456789':
                        if is_valid(row, col, digit):
                            # Place digit
                            board[row][col] = digit
                            
                            # Recurse
                            if solve():
                                return True  # Solved!
                            
                            # Backtrack
                            board[row][col] = '.'
                    
                    # No valid digit found
                    return False
        
        # No empty cells = solved!
        return True
    
    solve()`,
                codeDetailed: `def solveSudoku_detailed(board):
    """
    SUDOKU SOLVER with Backtracking
    
    STRATEGY:
    1. Find first empty cell ('.')
    2. Try digits 1-9
    3. For each digit, check 3 constraints
    4. If valid, place and recurse
    5. If recursion fails, backtrack (reset to '.')
    6. If no digit works, return False
    7. If no empty cells, puzzle solved!
    
    WHY BACKTRACKING WORKS:
    - We explore all possibilities systematically
    - Early pruning via constraint checks
    - Guaranteed to find solution if exists
    """
    
    def is_valid(row, col, digit):
        """
        Check if placing 'digit' at (row, col) is valid.
        Must check: row, column, and 3x3 box.
        """
        # === CHECK ROW ===
        # Scan all columns in this row
        for c in range(9):
            if board[row][c] == digit:
                return False
        
        # === CHECK COLUMN ===
        # Scan all rows in this column
        for r in range(9):
            if board[r][col] == digit:
                return False
        
        # === CHECK 3x3 BOX ===
        # Find top-left corner of box
        box_row_start = 3 * (row // 3)  # 0, 3, or 6
        box_col_start = 3 * (col // 3)  # 0, 3, or 6
        
        # Check all 9 cells in box
        for delta_row in range(3):
            for delta_col in range(3):
                r = box_row_start + delta_row
                c = box_col_start + delta_col
                if board[r][c] == digit:
                    return False
        
        return True
    
    def solve():
        """
        Main backtracking function.
        Returns True if puzzle solved, False otherwise.
        """
        # Find next empty cell
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    # Try each digit 1-9
                    for digit in '123456789':
                        if is_valid(row, col, digit):
                            # === PLACE DIGIT ===
                            board[row][col] = digit
                            
                            # === RECURSE ===
                            if solve():
                                return True  # Puzzle solved!
                            
                            # === BACKTRACK ===
                            # Solution not found, undo placement
                            board[row][col] = '.'
                    
                    # Tried all digits, none worked
                    return False
        
        # No empty cells left = puzzle solved!
        return True
    
    solve()

# Optimized version using sets for O(1) lookup:
def solveSudoku_optimized(board):
    rows = [set() for _ in range(9)]
    cols = [set() for _ in range(9)]
    boxes = [set() for _ in range(9)]
    
    # Initialize sets with existing values
    for row in range(9):
        for col in range(9):
            if board[row][col] != '.':
                digit = board[row][col]
                rows[row].add(digit)
                cols[col].add(digit)
                boxes[(row // 3) * 3 + col // 3].add(digit)
    
    def solve():
        for row in range(9):
            for col in range(9):
                if board[row][col] == '.':
                    box_idx = (row // 3) * 3 + col // 3
                    for digit in '123456789':
                        if (digit not in rows[row] and 
                            digit not in cols[col] and 
                            digit not in boxes[box_idx]):
                            # Place
                            board[row][col] = digit
                            rows[row].add(digit)
                            cols[col].add(digit)
                            boxes[box_idx].add(digit)
                            
                            if solve(): return True
                            
                            # Backtrack
                            board[row][col] = '.'
                            rows[row].remove(digit)
                            cols[col].remove(digit)
                            boxes[box_idx].remove(digit)
                    return False
        return True
    
    solve()`
            }
        }
    ]
}


// ========== data/concepts/dp_concepts.js ==========
// Dp Concepts data
// Extracted from data.js

const topic_dp_concepts = {
    id: "dp_concepts",
    title: "DP Mastery: Complete Guide",
    description: "From Zero to Hero - Master Every DP Pattern",
    color: "#8b5cf6",
    icon: "fas fa-brain",
    type: "guide",
    sections: [
        {
            id: "philosophy",
            title: "ğŸ§  Philosophy",
            icon: "fas fa-lightbulb",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-lightbulb"></i>
                            The "Lun Na Lun" Philosophy
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#ef4444; color:white;">CORE CONCEPT</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(34, 211, 238, 0.1)); border-radius: 12px; border: 2px solid var(--border); margin: 30px 0; line-height: 1.8;">
                            "Har element pe do options: <span style='color:#8b5cf6; font-weight:800;'>LUN</span> (include karo) ya <span style='color:#8b5cf6; font-weight:800;'>NA LUN</span> (skip karo)"
                        </div>
                        
                        <div style="background: rgba(139, 92, 246, 0.1); padding: 25px; border-radius: 12px; border-left: 4px solid #8b5cf6; margin: 25px 0;">
                            <h4 style="margin-bottom:15px; color:#a78bfa;"><i class="fas fa-star"></i> Why This Pattern is Powerful</h4>
                            <ul style="list-style:none; padding-left:0; line-height:2;">
                                <li>âœ… <strong>Natural Thinking:</strong> Dimag automatically "should I include this?" sochta hai</li>
                                <li>âœ… <strong>Universal Template:</strong> 80% DP problems is pattern pe fit hote hain</li>
                                <li>âœ… <strong>Interview-Friendly:</strong> 5 min mein code likh sakte ho</li>
                                <li>âœ… <strong>Easy Complexity:</strong> States count karna simple hai</li>
                            </ul>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #a78bfa;">
                            <i class="fas fa-brain"></i> The 3-Step DP Approach
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin: 20px 0;">
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                <div style="font-size:2rem; margin-bottom:10px;">1ï¸âƒ£</div>
                                <strong style="color:#ef4444;">Write Recursion</strong>
                                <p style="font-size:0.9rem; color:gray; margin-top:8px;">Sab se pehle brute force likho</p>
                            </div>
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                <div style="font-size:2rem; margin-bottom:10px;">2ï¸âƒ£</div>
                                <strong style="color:#f59e0b;">Add Memoization</strong>
                                <p style="font-size:0.9rem; color:gray; margin-top:8px;">memo dict add karo</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                <div style="font-size:2rem; margin-bottom:10px;">3ï¸âƒ£</div>
                                <strong style="color:#10b981;">Convert to DP</strong>
                                <p style="font-size:0.9rem; color:gray; margin-top:8px;">Bottom-up tabulation (Optional)</p>
                            </div>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #a78bfa;">
                            <i class="fas fa-code"></i> Universal Template
                        </h3>
                        
                        <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.9rem; line-height: 1.6;">def solve(arr):
memo = {}

def dfs(index, state):
    # 1. Base Case
    if index >= len(arr):
        return 0  # or appropriate base value
    
    # 2. Check Memo
    if (index, state) in memo:
        return memo[(index, state)]
    
    # 3. LUN (Take current element)
    take = arr[index] + dfs(index + 1, new_state)
    
    # 4. NA LUN (Skip current element)
    skip = dfs(index + 1, state)
    
    # 5. Choose best & store
    memo[(index, state)] = max(take, skip)
    return memo[(index, state)]

return dfs(0, initial_state)</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "roadmap",
            title: "ğŸ—ºï¸ Roadmap",
            icon: "fas fa-route",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-route"></i>
                            DP Learning Roadmap
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">7 QUESTIONS</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            In order practice karo. Har question ek naya pattern sikhata hai!
                        </p>
                        
                        <div style="display: flex; flex-direction: column; gap: 15px;">
                            
                            <a href="learn.html?topic=dp&q=house-robber" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3); transition: transform 0.2s;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #ef4444; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 1</span>
                                            <strong style="color: white; font-size: 1.1rem;">House Robber</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Simple Take/Not-Take with gap constraint
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #ef4444;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=longest-increasing-subsequence" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(245, 158, 11, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #f59e0b; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 2</span>
                                            <strong style="color: white; font-size: 1.1rem;">LIS (Longest Increasing Subsequence)</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Take/Not-Take with comparison constraint
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #f59e0b;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=coin-change" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(245, 158, 11, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #f59e0b; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 3</span>
                                            <strong style="color: white; font-size: 1.1rem;">Coin Change</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Unbounded Knapsack (infinite supply)
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #f59e0b;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=partition-equal-subset-sum" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(139, 92, 246, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #8b5cf6; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 4</span>
                                            <strong style="color: white; font-size: 1.1rem;">0/1 Knapsack (Partition Equal Subset)</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Classic 0/1 Knapsack with target sum
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #8b5cf6;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=longest-common-subsequence" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(139, 92, 246, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(139, 92, 246, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #8b5cf6; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 5</span>
                                            <strong style="color: white; font-size: 1.1rem;">LCS (Longest Common Subsequence)</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Two-String DP (Match or Skip)
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #8b5cf6;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=word-break" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #10b981; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 6</span>
                                            <strong style="color: white; font-size: 1.1rem;">Word Break</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> String partition + Dictionary lookup
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #10b981;"></i>
                                </div>
                            </a>
                            
                            <a href="learn.html?topic=dp&q=edit-distance" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #10b981; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">BOSS</span>
                                            <strong style="color: white; font-size: 1.1rem;">Edit Distance</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Pattern:</strong> Two-String DP with 3 operations
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #10b981;"></i>
                                </div>
                            </a>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "patterns",
            title: "ğŸ§© 5 Patterns",
            icon: "fas fa-puzzle-piece",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-puzzle-piece"></i>
                            The 5 DP Patterns
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            <strong>90% DP problems</strong> in 5 patterns ke andar aate hain. Pattern pehchaan lo, problem solve ho jayegi!
                        </p>
                        
                        <!-- Pattern 1: Take/Not-Take -->
                        <div style="background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #8b5cf6; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">1</span>
                                <h3 style="color: #a78bfa; margin: 0;">Take / Not-Take (Lun Na Lun)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Maximum/Minimum value subset select karo"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                take = arr[i] + dfs(i+1, new_state)<br>
                                skip = dfs(i+1, state)<br>
                                return max(take, skip)
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> House Robber, LIS, Subset Sum
                            </p>
                        </div>
                        
                        <!-- Pattern 2: 0/1 Knapsack -->
                        <div style="background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #f59e0b; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">2</span>
                                <h3 style="color: #fbbf24; margin: 0;">0/1 Knapsack</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Target sum tak pahunchna hai, items <strong>ek baar</strong> use kar sakte ho"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                # State: (index, remaining_capacity/sum)<br>
                                take = dfs(i+1, target - arr[i])  # Move to next<br>
                                skip = dfs(i+1, target)           # Move to next
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Partition Equal Subset, Target Sum
                            </p>
                        </div>
                        
                        <!-- Pattern 3: Unbounded Knapsack -->
                        <div style="background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #ef4444; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">3</span>
                                <h3 style="color: #f87171; margin: 0;">Unbounded Knapsack</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Target sum tak pahunchna hai, items <strong>baar baar</strong> use kar sakte ho"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                # Key difference: STAY at same index when taking!<br>
                                take = 1 + dfs(i, target - coins[i])  # Stay at i<br>
                                skip = dfs(i+1, target)               # Move to next
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Coin Change, Rod Cutting, Coin Change II
                            </p>
                        </div>
                        
                        <!-- Pattern 4: Two-String DP -->
                        <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #10b981; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">4</span>
                                <h3 style="color: #34d399; margin: 0;">Two-String DP (Match/Skip)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Do strings compare karna hai"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                if s1[i] == s2[j]:  # MATCH<br>
                                &nbsp;&nbsp;return 1 + dfs(i+1, j+1)  # Diagonal<br>
                                else:  # NO MATCH<br>
                                &nbsp;&nbsp;return max(dfs(i+1, j), dfs(i, j+1))  # Skip one
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> LCS, Edit Distance, Longest Palindromic Subseq
                            </p>
                        </div>
                        
                        <!-- Pattern 5: String Partition -->
                        <div style="background: rgba(34, 211, 238, 0.05); border: 1px solid rgba(34, 211, 238, 0.2); border-radius: 16px; padding: 25px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #22d3ee; color: black; padding: 6px 12px; border-radius: 8px; font-weight: 700;">5</span>
                                <h3 style="color: #22d3ee; margin: 0;">String Partition</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "String ko valid parts mein todna hai"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                for end in range(start, len(s)):<br>
                                &nbsp;&nbsp;if s[start:end+1] in wordDict:<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;if dfs(end + 1): return True<br>
                                return False
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Word Break, Palindrome Partitioning
                            </p>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "complexity",
            title: "â±ï¸ Complexity",
            icon: "fas fa-clock",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-clock"></i>
                            Time Complexity: The Truth
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#ef4444; color:white;">CRITICAL</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div style="background:rgba(245, 158, 11, 0.1); padding:25px; text-align:center; border-radius:12px; margin:20px 0; border: 2px solid rgba(245, 158, 11, 0.3);">
                            <code style="font-size: 1.5em; color: #f59e0b; font-weight: 700;">Time = (Unique States) Ã— (Work per State)</code>
                            <br><br>
                            <span style="color: gray;">NOT total recursive calls! Memoization changes everything!</span>
                        </div>
                        
                        <h3 style="color: #a78bfa; margin: 25px 0 15px;">Complexity by Problem</h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #8b5cf6, #a78bfa);">
                                    <th style="padding: 15px; text-align: left; color: white;">Problem</th>
                                    <th style="padding: 15px; text-align: left; color: white;">States</th>
                                    <th style="padding: 15px; text-align: left; color: white;">Time</th>
                                    <th style="padding: 15px; text-align: left; color: white;">Space</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">House Robber</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc; font-family: Consolas;">(i)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #34d399;">O(N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #34d399;">O(1)*</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">LIS</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc; font-family: Consolas;">(i, prev_i)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">O(NÂ²)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">O(NÂ²)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Coin Change</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc; font-family: Consolas;">(amt) or (i, amt)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">O(A Ã— C)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #34d399;">O(A)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">LCS</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc; font-family: Consolas;">(i, j)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">O(M Ã— N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">O(M Ã— N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px;">Edit Distance</td>
                                    <td style="padding: 12px; color: #7dd3fc; font-family: Consolas;">(i, j)</td>
                                    <td style="padding: 12px; color: #f59e0b;">O(M Ã— N)</td>
                                    <td style="padding: 12px; color: #f59e0b;">O(M Ã— N)</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <p style="color: gray; font-size: 0.85rem; margin-top: 10px;">* Space optimized using rolling variables</p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 25px;">
                            <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #ef4444;">âŒ WITHOUT Memo</h4>
                                <p>Exponential: O(2â¿)</p>
                                <p><strong>Result: TLE! âŒ</strong></p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); border-left: 4px solid #10b981; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #10b981;">âœ… WITH Memo</h4>
                                <p>Polynomial: O(NÂ²) etc.</p>
                                <p><strong>Result: AC! âœ…</strong></p>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "mistakes",
            title: "âš ï¸ Mistakes",
            icon: "fas fa-exclamation-triangle",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Common DP Mistakes (Must Avoid!)
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#ef4444; color:white;">TRAPS</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Mistake 1 -->
                        <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #ef4444; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">1</span>
                                <strong style="color: #f87171; font-size: 1.1rem;">Memo Key Galat Liya</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Agar tumne state mein kuch parameter miss kiya, multiple calls same key pe store honge â†’ Wrong Answer!</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #ef4444; margin-bottom: 8px; font-size: 0.85rem;">âŒ WRONG</p>
                                    <code style="color: #f87171; font-family: Consolas; font-size: 0.85rem;">memo[index] = result</code>
                                </div>
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #10b981; margin-bottom: 8px; font-size: 0.85rem;">âœ… RIGHT</p>
                                    <code style="color: #34d399; font-family: Consolas; font-size: 0.85rem;">memo[(index, remaining)] = result</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mistake 2 -->
                        <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #f59e0b; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">2</span>
                                <strong style="color: #fbbf24; font-size: 1.1rem;">Base Case Wrong Value</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Min problem mein 0 return karna ya Max problem mein infinity use karna â†’ Wrong Answer!</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #f59e0b; font-family: Consolas; font-size: 0.85rem;">
                                    # For MIN problems (Coin Change)<br>
                                    if target == 0: return 0  # Valid<br>
                                    if target < 0: return float('inf')  # Invalid<br><br>
                                    # For MAX problems (House Robber)<br>
                                    if index >= len(arr): return 0  # No more to take
                                </code>
                            </div>
                        </div>
                        
                        <!-- Mistake 3 -->
                        <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #8b5cf6; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">3</span>
                                <strong style="color: #a78bfa; font-size: 1.1rem;">0/1 vs Unbounded Confusion</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Jab item baar baar use kar sakte ho, index SAME rehna chahiye!</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #a78bfa; margin-bottom: 8px; font-size: 0.85rem;">0/1 Knapsack (Use once)</p>
                                    <code style="color: #c4b5fd; font-family: Consolas; font-size: 0.85rem;">take = dfs(i<strong>+1</strong>, ...)</code>
                                </div>
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #22d3ee; margin-bottom: 8px; font-size: 0.85rem;">Unbounded (Use infinite)</p>
                                    <code style="color: #67e8f9; font-family: Consolas; font-size: 0.85rem;">take = dfs(<strong>i</strong>, ...)  # Stay!</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mistake 4 -->
                        <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #10b981; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">4</span>
                                <strong style="color: #34d399; font-size: 1.1rem;">State Design Galat</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">LIS mein prev_index track karna bhool gaye â†’ Can't compare correctly!</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #34d399; font-family: Consolas; font-size: 0.85rem;">
                                    # LIS needs TWO parameters:<br>
                                    def dfs(curr_idx, prev_idx):  # âœ…<br>
                                    &nbsp;&nbsp;if nums[curr_idx] > nums[prev_idx]:  # Compare<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;take = 1 + dfs(curr_idx+1, curr_idx)
                                </code>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "visualizers",
            title: "ğŸ® Visualizers",
            icon: "fas fa-play-circle",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-play-circle"></i>
                            Interactive DP Visualizers
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">LEARN BY DOING</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            Step-by-step dekho ki DP table kaise bharta hai. Best way to understand!
                        </p>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <a href="visualizers/lcs.html" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(139, 92, 246, 0.05)); padding: 30px; border-radius: 16px; border: 1px solid rgba(139, 92, 246, 0.3); text-align: center; transition: transform 0.2s;">
                                <i class="fas fa-th" style="font-size: 2.5rem; color: #a78bfa; margin-bottom: 15px;"></i>
                                <h4 style="color: white; margin-bottom: 8px;">LCS Visualizer</h4>
                                <p style="color: gray; font-size: 0.9rem; margin: 0;">See 2D grid fill up</p>
                            </a>
                            
                            <a href="visualizers/lis.html" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(245, 158, 11, 0.05)); padding: 30px; border-radius: 16px; border: 1px solid rgba(245, 158, 11, 0.3); text-align: center;">
                                <i class="fas fa-chart-line" style="font-size: 2.5rem; color: #fbbf24; margin-bottom: 15px;"></i>
                                <h4 style="color: white; margin-bottom: 8px;">LIS Visualizer</h4>
                                <p style="color: gray; font-size: 0.9rem; margin: 0;">Watch sequence build</p>
                            </a>
                            
                            <a href="visualizers/min_coins.html" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(16, 185, 129, 0.05)); padding: 30px; border-radius: 16px; border: 1px solid rgba(16, 185, 129, 0.3); text-align: center;">
                                <i class="fas fa-coins" style="font-size: 2.5rem; color: #34d399; margin-bottom: 15px;"></i>
                                <h4 style="color: white; margin-bottom: 8px;">Coin Change Visualizer</h4>
                                <p style="color: gray; font-size: 0.9rem; margin: 0;">Unbounded knapsack in action</p>
                            </a>
                            
                            <a href="visualizers/word_break.html" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.05)); padding: 30px; border-radius: 16px; border: 1px solid rgba(239, 68, 68, 0.3); text-align: center;">
                                <i class="fas fa-font" style="font-size: 2.5rem; color: #f87171; margin-bottom: 15px;"></i>
                                <h4 style="color: white; margin-bottom: 8px;">Word Break Visualizer</h4>
                                <p style="color: gray; font-size: 0.9rem; margin: 0;">String partition demo</p>
                            </a>
                        </div>
                    </div>
                </div>`
        }
    ]
};


// ========== data/concepts/arrays_concepts.js ==========
// Arrays Concepts data
// Extracted from data.js

const topic_arrays_concepts = {
    id: "arrays_concepts",
    title: "Arrays Mastery: Pattern Bible",
    description: "Sliding Window, Two Pointers, and Prefix Sum Patterns",
    color: "#6366f1",
    icon: "fas fa-layer-group",
    type: "guide",
    sections: [
        {
            id: "sliding-window",
            title: "Sliding Window",
            icon: "fas fa-window-maximize",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-window-maximize"></i>
                            Sliding Window Pattern
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#ef4444; color:white;">CORE PATTERN</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(34, 211, 238, 0.1)); border-radius: 12px; border: 2px solid var(--border); margin: 30px 0; line-height: 1.8;">
                            "Jab <span style='color:#6366f1'>Contiguous Subarray/Substring</span> bole, Sliding Window Laga Do!"
                        </div>
                        
                        <h3 style="color: #818cf8; margin: 20px 0;">When to Use</h3>
                        <ul style="list-style: none; padding: 0; line-height: 2;">
                            <li>âœ… Find max/min subarray of size K</li>
                            <li>âœ… Longest substring with condition (unique, at most K distinct)</li>
                            <li>âœ… Sum/product of subarrays</li>
                        </ul>
                        
                        <h3 style="color: #818cf8; margin: 30px 0 15px;">Fixed vs Variable Window</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div style="background: rgba(99, 102, 241, 0.1); padding: 20px; border-radius: 12px;">
                                <h4>Fixed Size (K)</h4>
                                <p>Max sum of K elements</p>
                                <code>while right < n: expand, shrink when size > K</code>
                            </div>
                            <div style="background: rgba(34, 211, 153, 0.1); padding: 20px; border-radius: 12px;">
                                <h4>Variable Size</h4>
                                <p>Longest valid window</p>
                                <code>Expand right, shrink left while invalid</code>
                            </div>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px; color: #818cf8;">Universal Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">def sliding_window(arr):
left = 0
window_state = {}  # or sum, count, etc.
result = 0

for right in range(len(arr)):
    # EXPAND: Add arr[right] to window
    window_state[arr[right]] = window_state.get(arr[right], 0) + 1
    
    # SHRINK: While window is invalid
    while invalid_condition(window_state):
        window_state[arr[left]] -= 1
        if window_state[arr[left]] == 0:
            del window_state[arr[left]]
        left += 1
    
    # UPDATE: Record result
    result = max(result, right - left + 1)

return result</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "two-pointers",
            title: "Two Pointers",
            icon: "fas fa-arrows-alt-h",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-arrows-alt-h"></i>
                            Two Pointers Pattern  
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(34, 211, 238, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "Sorted Array + Pair/Triplet Problem = Two Pointers"
                        </div>
                        
                        <h3 style="color: #818cf8; margin: 20px 0; font-size: 1.3rem; font-weight: 700;">Types of Two Pointers</h3>
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #6366f1, #818cf8);">
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Type</th>
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Use Case</th>
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; border-bottom: 1px solid #334155;">Opposite Ends</td>
                                    <td style="padding: 16px 20px; color: #a5b4fc; border-bottom: 1px solid #334155;">Sum to target</td>
                                    <td style="padding: 16px 20px; color: #94a3b8; border-bottom: 1px solid #334155;">Two Sum II, Container with Water</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; border-bottom: 1px solid #334155;">Same Direction</td>
                                    <td style="padding: 16px 20px; color: #a5b4fc; border-bottom: 1px solid #334155;">Merge, remove duplicates</td>
                                    <td style="padding: 16px 20px; color: #94a3b8; border-bottom: 1px solid #334155;">Merge Sorted Array</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600;">Fast-Slow</td>
                                    <td style="padding: 16px 20px; color: #a5b4fc;">Cycle detection</td>
                                    <td style="padding: 16px 20px; color: #94a3b8;">Linked List Cycle</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="margin: 30px 0 15px; color: #818cf8;">3Sum Template (Anchor + Squeeze)</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">def three_sum(nums, target):
nums.sort()  # CRITICAL: Must sort first!
result = []

for i in range(len(nums) - 2):
    # Skip duplicates for anchor
    if i > 0 and nums[i] == nums[i-1]:
        continue
    
    left, right = i + 1, len(nums) - 1
    
    while left < right:
        total = nums[i] + nums[left] + nums[right]
        
        if total < target:
            left += 1
        elif total > target:
            right -= 1
        else:
            result.append([nums[i], nums[left], nums[right]])
            left += 1
            while left < right and nums[left] == nums[left-1]:
                left += 1

return result</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "prefix-sum",
            title: "Prefix Sum",
            icon: "fas fa-calculator",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-calculator"></i>
                            Prefix Sum Pattern
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(244, 114, 182, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "Range Sum Query? Precompute Prefix, Answer in O(1)!"
                        </div>
                        
                        <div style="background: rgba(99, 102, 241, 0.1); padding: 20px; border-radius: 12px; margin: 20px 0;">
                            <h4 style="color: #818cf8;">Core Idea</h4>
                            <p><code>prefix[i] = arr[0] + arr[1] + ... + arr[i]</code></p>
                            <p><code>sum(i, j) = prefix[j] - prefix[i-1]</code></p>
                        </div>
                        
                        <h3 style="color: #818cf8; margin: 20px 0;">Subarray Sum Equals K (with HashMap)</h3>
                        <p>Count subarrays with sum = K</p>
                        <p><strong>Trick:</strong> If <code>prefix[j] - prefix[i] = K</code>, then <code>prefix[i] = prefix[j] - K</code></p>
                        
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px; margin-top: 20px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">def subarray_sum(nums, k):
prefix_count = {0: 1}  # Base case
prefix_sum = 0
count = 0

for num in nums:
    prefix_sum += num
    
    # Check if (prefix_sum - k) exists
    if prefix_sum - k in prefix_count:
        count += prefix_count[prefix_sum - k]
    
    prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1

return count</pre>
                        </div>
                    </div>
                </div>`
        }
    ]
};


// ========== data/concepts/graphs_concepts.js ==========
// Graphs Concepts data
// Extracted from data.js

const topic_graphs_concepts = {
    id: "graphs_concepts",
    title: "Graphs Mastery: The Complete Guide",
    description: "BFS, DFS, Topological Sort, and Union-Find Patterns",
    color: "#c026d3",
    icon: "fas fa-project-diagram",
    type: "guide",
    sections: [
        {
            id: "bfs-dfs",
            title: "BFS vs DFS",
            icon: "fas fa-sitemap",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-sitemap"></i>
                            BFS vs DFS: When to Use What
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#c026d3; color:white;">CORE PATTERN</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.2rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(192, 38, 211, 0.1), rgba(34, 211, 238, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "<span style='color:#c026d3'>Shortest Path (Unweighted)</span> â†’ BFS &nbsp;&nbsp;|&nbsp;&nbsp; <span style='color:#22d3ee'>Explore All</span> â†’ DFS"
                        </div>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #c026d3, #e879f9);">
                                    <th style="padding: 16px 20px; text-align: center; color: white; font-weight: 700; font-size: 1rem;">BFS</th>
                                    <th style="padding: 16px 20px; text-align: center; color: white; font-weight: 700; font-size: 1rem;">DFS</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; text-align: center; border-bottom: 1px solid #334155;">Uses Queue (FIFO)</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9; text-align: center; border-bottom: 1px solid #334155;">Uses Stack/Recursion</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; text-align: center; border-bottom: 1px solid #334155;">Level by Level</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9; text-align: center; border-bottom: 1px solid #334155;">Go Deep First</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #34d399; text-align: center; font-weight: 600; border-bottom: 1px solid #334155;">âœ… Shortest Path</td>
                                    <td style="padding: 16px 20px; color: #34d399; text-align: center; font-weight: 600; border-bottom: 1px solid #334155;">âœ… Cycle Detection</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #34d399; text-align: center; font-weight: 600;">âœ… Multi-source spread</td>
                                    <td style="padding: 16px 20px; color: #34d399; text-align: center; font-weight: 600;">âœ… Backtracking</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="margin: 30px 0 15px; color: #c026d3;">BFS Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">from collections import deque

def bfs(graph, start):
visited = {start}
queue = deque([start])
distance = 0

while queue:
    # Process level by level
    for _ in range(len(queue)):
        node = queue.popleft()
        
        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)  # Mark BEFORE pushing!
                queue.append(neighbor)
    distance += 1

return distance</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "topo-sort",
            title: "Topological Sort",
            icon: "fas fa-sort-amount-down",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-sort-amount-down"></i>
                            Topological Sort (Kahn's Algorithm)
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.2rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(192, 38, 211, 0.1), rgba(245, 158, 11, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "Dependencies? Prerequisites? <span style='color:#c026d3'>Topo Sort</span> is the Answer!"
                        </div>
                        
                        <h3 style="color: #c026d3; margin: 20px 0;">When to Use</h3>
                        <ul style="list-style: none; padding: 0; line-height: 2;">
                            <li>âœ… Course Schedule (prerequisites)</li>
                            <li>âœ… Build Order (dependencies)</li>
                            <li>âœ… Alien Dictionary</li>
                            <li>âœ… Task Scheduling</li>
                        </ul>
                        
                        <h3 style="margin: 30px 0 15px; color: #c026d3;">Kahn's Algorithm Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">from collections import deque, defaultdict

def topo_sort(n, edges):
graph = defaultdict(list)
indegree = [0] * n

# Build graph and indegrees
for src, dst in edges:
    graph[src].append(dst)
    indegree[dst] += 1

# Start with nodes having 0 indegree
queue = deque([i for i in range(n) if indegree[i] == 0])
order = []

while queue:
    node = queue.popleft()
    order.append(node)
    
    for neighbor in graph[node]:
        indegree[neighbor] -= 1
        if indegree[neighbor] == 0:
            queue.append(neighbor)

# Cycle check
return order if len(order) == n else []</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "union-find",
            title: "Union-Find",
            icon: "fas fa-users",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-users"></i>
                            Union-Find (Disjoint Set Union)
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.2rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(192, 38, 211, 0.1), rgba(52, 211, 153, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "Connectivity? Grouping? Components? <span style='color:#34d399'>Union-Find!</span>"
                        </div>
                        
                        <h3 style="color: #c026d3; margin: 20px 0;">When to Use</h3>
                        <ul style="list-style: none; padding: 0; line-height: 2;">
                            <li>âœ… Number of connected components</li>
                            <li>âœ… Detect cycle in undirected graph</li>
                            <li>âœ… Friends in network</li>
                            <li>âœ… Kruskal's MST</li>
                        </ul>
                        
                        <h3 style="margin: 30px 0 15px; color: #c026d3;">DSU Template (with Path Compression + Rank)</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">class DSU:
def __init__(self, n):
    self.parent = list(range(n))
    self.rank = [0] * n
    self.count = n  # Number of components

def find(self, x):
    if self.parent[x] != x:
        self.parent[x] = self.find(self.parent[x])  # Path compression
    return self.parent[x]

def union(self, x, y):
    px, py = self.find(x), self.find(y)
    if px == py:
        return False  # Already connected
    
    # Union by rank
    if self.rank[px] < self.rank[py]:
        px, py = py, px
    self.parent[py] = px
    if self.rank[px] == self.rank[py]:
        self.rank[px] += 1
    
    self.count -= 1
    return True</pre>
                        </div>
                    </div>
                </div>`
        }
    ]
};



// ========== data/concepts/trees_concepts.js ==========
// Trees Concepts data
// Extracted from data.js

const topic_trees_concepts = {
    id: "trees_concepts",
    title: "Trees Mastery: The Recursion Bible",
    description: "DFS, BFS, Path Problems, and Tree Construction Patterns",
    color: "#16a34a",
    icon: "fas fa-tree",
    type: "guide",
    sections: [
        {
            id: "recursion-patterns",
            title: "Recursion Patterns",
            icon: "fas fa-sync",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-sync"></i>
                            Tree Recursion: The Leap of Faith
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#16a34a; color:white;">CORE PATTERN</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(22, 163, 74, 0.1), rgba(34, 211, 238, 0.1)); border-radius: 12px; margin: 30px 0; line-height: 1.8;">
                            "Trust that <span style='color:#16a34a'>solve(root.left)</span> and <span style='color:#16a34a'>solve(root.right)</span> work perfectly!"
                        </div>
                        
                        <h3 style="color: #16a34a; margin: 20px 0;">The Pattern</h3>
                        <ol style="line-height: 2;">
                            <li><strong>Base Case:</strong> <code>if not root: return base_value</code></li>
                            <li><strong>Recurse Left:</strong> <code>left_result = solve(root.left)</code></li>
                            <li><strong>Recurse Right:</strong> <code>right_result = solve(root.right)</code></li>
                            <li><strong>Combine:</strong> <code>return combine(root.val, left_result, right_result)</code></li>
                        </ol>
                        
                        <h3 style="margin: 30px 0 15px; color: #16a34a;">Universal Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">def solve_tree(root):
# 1. Base Case
if not root:
    return 0  # or None, True, etc.

# 2. LEAP OF FAITH: Trust left/right work!
left_result = solve_tree(root.left)
right_result = solve_tree(root.right)

# 3. Combine at current node
return root.val + left_result + right_result</pre>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px; color: #16a34a; font-size: 1.3rem; font-weight: 700;">Common Examples</h3>
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #16a34a, #22c55e);">
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem; letter-spacing: 0.5px;">Problem</th>
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem; letter-spacing: 0.5px;">Combine Logic</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; font-size: 1rem; border-bottom: 1px solid #334155;">Tree Height</td>
                                    <td style="padding: 16px 20px; border-bottom: 1px solid #334155;"><code style="background: #0f172a; color: #7dd3fc; padding: 6px 12px; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.95rem; font-weight: 600;">1 + max(left, right)</code></td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; font-size: 1rem; border-bottom: 1px solid #334155;">Tree Sum</td>
                                    <td style="padding: 16px 20px; border-bottom: 1px solid #334155;"><code style="background: #0f172a; color: #7dd3fc; padding: 6px 12px; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.95rem; font-weight: 600;">root.val + left + right</code></td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; font-size: 1rem; border-bottom: 1px solid #334155;">Count Nodes</td>
                                    <td style="padding: 16px 20px; border-bottom: 1px solid #334155;"><code style="background: #0f172a; color: #7dd3fc; padding: 6px 12px; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.95rem; font-weight: 600;">1 + left + right</code></td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #f1f5f9; font-weight: 600; font-size: 1rem;">Is Balanced?</td>
                                    <td style="padding: 16px 20px;"><code style="background: #0f172a; color: #7dd3fc; padding: 6px 12px; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.95rem; font-weight: 600;">abs(left - right) &lt;= 1</code></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>`
        },
        {
            id: "path-problems",
            title: "Path Problems",
            icon: "fas fa-route",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-route"></i>
                            Path Problems: Global vs Local
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.2rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(22, 163, 74, 0.1), rgba(244, 114, 182, 0.1)); border-radius: 12px; margin: 30px 0;">
                            "Split at node (root + left + right) vs Flow through node (root + max(left, right))"
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
                            <div style="background: rgba(22, 163, 74, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid #16a34a;">
                                <h4 style="color: #16a34a;">Global (The Arch)</h4>
                                <p>Path ENDS at this node</p>
                                <p>Used for: Max Path Sum</p>
                                <code>global_max = max(global, root + left + right)</code>
                            </div>
                            <div style="background: rgba(99, 102, 241, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid #6366f1;">
                                <h4 style="color: #6366f1;">Local (The Flow)</h4>
                                <p>Path CONTINUES upward</p>
                                <p>Returned to parent</p>
                                <code>return root + max(left, right)</code>
                            </div>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px; color: #16a34a;">Max Path Sum Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">def maxPathSum(root):
global_max = float('-inf')

def dfs(node):
    nonlocal global_max
    if not node:
        return 0
    
    # Get best paths from children (clamp negatives to 0)
    left = max(dfs(node.left), 0)
    right = max(dfs(node.right), 0)
    
    # GLOBAL: Path that SPLITS here (arch)
    global_max = max(global_max, node.val + left + right)
    
    # LOCAL: Path that FLOWS upward (return to parent)
    return node.val + max(left, right)

dfs(root)
return global_max</pre>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "traversals",
            title: "Traversals",
            icon: "fas fa-stream",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-stream"></i>
                            Tree Traversals: When to Use What
                        </div>
                    </div>
                    <div class="card-body">
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3); margin: 20px 0;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #16a34a, #22c55e);">
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Traversal</th>
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Order</th>
                                    <th style="padding: 16px 20px; text-align: left; color: white; font-weight: 700; font-size: 0.95rem;">Use Case</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #4ade80; font-weight: 700; border-bottom: 1px solid #334155;">Preorder</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9; border-bottom: 1px solid #334155;">Root â†’ Left â†’ Right</td>
                                    <td style="padding: 16px 20px; color: #94a3b8; border-bottom: 1px solid #334155;">Serialize tree, copy tree</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #4ade80; font-weight: 700; border-bottom: 1px solid #334155;">Inorder</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9; border-bottom: 1px solid #334155;">Left â†’ Root â†’ Right</td>
                                    <td style="padding: 16px 20px; color: #94a3b8; border-bottom: 1px solid #334155;">BST sorted order</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #4ade80; font-weight: 700; border-bottom: 1px solid #334155;">Postorder</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9; border-bottom: 1px solid #334155;">Left â†’ Right â†’ Root</td>
                                    <td style="padding: 16px 20px; color: #94a3b8; border-bottom: 1px solid #334155;">Delete tree, height calc</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 16px 20px; color: #4ade80; font-weight: 700;">Level Order</td>
                                    <td style="padding: 16px 20px; color: #f1f5f9;">BFS (Queue)</td>
                                    <td style="padding: 16px 20px; color: #94a3b8;">Level-wise processing</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="margin: 30px 0 15px; color: #16a34a;">Level Order (BFS) Template</h3>
                        <div class="code-block" style="background: #0f172a; border-radius: 12px; padding: 15px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace;">from collections import deque

def levelOrder(root):
if not root:
    return []

result = []
queue = deque([root])

while queue:
    level = []
    for _ in range(len(queue)):  # Process one level
        node = queue.popleft()
        level.append(node.val)
        
        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)
    
    result.append(level)

return result</pre>
                        </div>
                    </div>
                </div>`
        }
    ]
}


// ========== data/concepts/complexity_concepts.js ==========
// Time & Space Complexity Mastery Guide
// The complete guide to understanding complexity analysis

const topic_complexity_concepts = {
    id: "complexity_concepts",
    title: "Time & Space Mastery: The Complete Guide",
    description: "Recursion Trees, Memoization Magic, and Real Number Analysis",
    color: "#f59e0b",
    icon: "fas fa-clock",
    type: "guide",
    sections: [
        {
            id: "philosophy",
            title: "ğŸ§  Philosophy",
            icon: "fas fa-lightbulb",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-lightbulb"></i>
                            The Golden Formula
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#ef4444; color:white;">CORE CONCEPT</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.6rem; font-weight: 700; text-align: center; padding: 40px; background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(239, 68, 68, 0.1)); border-radius: 16px; border: 2px solid rgba(245, 158, 11, 0.4); margin: 30px 0; line-height: 1.6;">
                            Time = <span style="color:#f59e0b;">(Unique States)</span> Ã— <span style="color:#22d3ee;">(Work per State)</span>
                        </div>
                        
                        <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid #ef4444; padding: 20px; border-radius: 8px; margin: 25px 0;">
                            <h4 style="color: #f87171; margin-bottom: 10px;">âš ï¸ Common Misconception</h4>
                            <p style="color: #fca5a5;">Time complexity â‰  Total recursive calls!</p>
                            <p style="color: gray;">Many students count all recursive calls, but with memoization, we only count <strong>unique states</strong>.</p>
                        </div>
                        
                        <h3 style="color: #fbbf24; margin: 30px 0 15px;">The Two Questions</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div style="background: rgba(245, 158, 11, 0.1); padding: 25px; border-radius: 12px; text-align: center;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">1ï¸âƒ£</div>
                                <h4 style="color: #fbbf24;">How many UNIQUE states?</h4>
                                <p style="color: gray; font-size: 0.9rem; margin-top: 10px;">Count the possible combinations of your memo key parameters</p>
                            </div>
                            <div style="background: rgba(34, 211, 238, 0.1); padding: 25px; border-radius: 12px; text-align: center;">
                                <div style="font-size: 2.5rem; margin-bottom: 15px;">2ï¸âƒ£</div>
                                <h4 style="color: #22d3ee;">How much WORK per state?</h4>
                                <p style="color: gray; font-size: 0.9rem; margin-top: 10px;">What happens inside each recursive call (loops, string ops, etc.)</p>
                            </div>
                        </div>
                        
                        <h3 style="color: #fbbf24; margin: 30px 0 15px;">Quick Examples</h3>
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #f59e0b, #fbbf24);">
                                    <th style="padding: 15px; text-align: left; color: black;">Problem</th>
                                    <th style="padding: 15px; text-align: left; color: black;">States</th>
                                    <th style="padding: 15px; text-align: left; color: black;">Work/State</th>
                                    <th style="padding: 15px; text-align: left; color: black;">Total</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">House Robber</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc;">N indices</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #22d3ee;">O(1)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #34d399; font-weight: 700;">O(N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">LCS</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc;">M Ã— N pairs</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #22d3ee;">O(1)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b; font-weight: 700;">O(MÃ—N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px;">Word Break</td>
                                    <td style="padding: 12px; color: #7dd3fc;">N positions</td>
                                    <td style="padding: 12px; color: #22d3ee;">O(NÂ²) loop + slice</td>
                                    <td style="padding: 12px; color: #ef4444; font-weight: 700;">O(NÂ³)</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>`
        },
        {
            id: "recursion-trees",
            title: "ğŸŒ³ Recursion Trees",
            icon: "fas fa-tree",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-tree"></i>
                            Visualizing Recursion: The Tree
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">VISUAL GUIDE</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.3rem; font-weight: 600; text-align: center; padding: 25px; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(245, 158, 11, 0.1)); border-radius: 12px; margin: 20px 0;">
                            "Every recursive call = A node in the tree"
                        </div>
                        
                        <!-- Fibonacci Tree -->
                        <h3 style="color: #ef4444; margin: 30px 0 15px;">
                            <i class="fas fa-fire"></i> Fibonacci WITHOUT Memo: O(2^N)
                        </h3>
                        <p style="color: gray; margin-bottom: 15px;">Each call splits into 2 more calls = Exponential explosion!</p>
                        
                        <div style="background: #0f172a; padding: 25px; border-radius: 12px; font-family: 'Consolas', monospace; overflow-x: auto;">
                            <pre style="color: #e2e8f0; margin: 0; line-height: 1.4;">
                         fib(5)
                        /      \\
                   fib(4)        fib(3)
                   /    \\        /    \\
              fib(3)  fib(2)  fib(2)  fib(1)
              /   \\    /  \\    /  \\      |
          fib(2) fib(1) ...  ...  ...    1
           / \\      |
        fib(1) fib(0)
           |      |
           1      0
           
    Total Nodes: 2^5 - 1 = 31 calls for fib(5)!
    For fib(50): 2^50 = 1,125,899,906,842,624 calls ğŸ’€</pre>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 25px 0;">
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);">
                                <h4 style="color: #ef4444;">âŒ Without Memo</h4>
                                <p style="color: #fca5a5; font-size: 1.5rem; font-weight: 700; margin: 10px 0;">O(2^N)</p>
                                <p style="color: gray; font-size: 0.9rem;">fib(3) is called 3 times!</p>
                                <p style="color: gray; font-size: 0.9rem;">fib(2) is called 5 times!</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.3);">
                                <h4 style="color: #10b981;">âœ… With Memo</h4>
                                <p style="color: #34d399; font-size: 1.5rem; font-weight: 700; margin: 10px 0;">O(N)</p>
                                <p style="color: gray; font-size: 0.9rem;">Each fib(k) computed only ONCE!</p>
                                <p style="color: gray; font-size: 0.9rem;">Stored and reused instantly</p>
                            </div>
                        </div>
                        
                        <!-- LIS Recursion Tree -->
                        <h3 style="color: #f59e0b; margin: 30px 0 15px;">
                            <i class="fas fa-chart-line"></i> LIS: Why O(2^N) Without Memo
                        </h3>
                        
                        <div style="background: #0f172a; padding: 25px; border-radius: 12px; font-family: 'Consolas', monospace; overflow-x: auto;">
                            <pre style="color: #e2e8f0; margin: 0; line-height: 1.4;">
    Array: [3, 1, 2, 4]     Starting from index 0, prev = -1

                      lis(0, -1)
                     /          \\
               TAKE 3          SKIP 3
              lis(1, 0)        lis(1, -1)
              /      \\         /       \\
         SKIP 1    [X]      TAKE 1    SKIP 1
        lis(2, 0)  can't   lis(2, 1)  lis(2, -1)
         /    \\   (1<3)     /    \\     /     \\
      SKIP   TAKE        TAKE  SKIP  TAKE   SKIP
        ...    ...         ...   ...   ...    ...

    Every element: 2 choices (take/skip)
    = 2 Ã— 2 Ã— 2 Ã— 2 = 2^N possibilities</pre>
                        </div>
                        
                        <h3 style="color: #22d3ee; margin: 30px 0 15px;">
                            <i class="fas fa-lightbulb"></i> Why Memo Makes It O(NÂ²)
                        </h3>
                        <div style="background: rgba(34, 211, 238, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid #22d3ee;">
                            <p style="margin-bottom: 15px;"><strong>Memo Key:</strong> <code style="background: #0f172a; padding: 4px 8px; border-radius: 4px; color: #7dd3fc;">(current_index, prev_index)</code></p>
                            <p style="margin-bottom: 10px;"><strong>How many unique pairs?</strong></p>
                            <ul style="list-style: none; padding-left: 0; line-height: 2;">
                                <li>â€¢ current_index: 0 to N-1 â†’ <strong>N</strong> values</li>
                                <li>â€¢ prev_index: -1 to N-1 â†’ <strong>N+1</strong> values</li>
                                <li>â€¢ Total states: <strong style="color: #22d3ee;">N Ã— (N+1) â‰ˆ O(NÂ²)</strong></li>
                            </ul>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "memo-magic",
            title: "âš¡ Memo Magic",
            icon: "fas fa-magic",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-magic"></i>
                            Before vs After Memoization
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#8b5cf6; color:white;">TRANSFORMATIVE</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.3rem; font-weight: 600; text-align: center; padding: 25px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(16, 185, 129, 0.1)); border-radius: 12px; margin: 20px 0;">
                            "Memoization converts EXPONENTIAL â†’ POLYNOMIAL"
                        </div>
                        
                        <h3 style="color: #a78bfa; margin: 25px 0 15px;">The Transformation Table</h3>
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #8b5cf6, #a78bfa);">
                                    <th style="padding: 15px; text-align: left; color: white;">Problem</th>
                                    <th style="padding: 15px; text-align: center; color: white;">Without Memo</th>
                                    <th style="padding: 15px; text-align: center; color: white;">â†’</th>
                                    <th style="padding: 15px; text-align: center; color: white;">With Memo</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; font-weight: 600;">Fibonacci</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #ef4444; font-weight: 700;">O(2^N)</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #10b981; font-weight: 700;">O(N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; font-weight: 600;">House Robber</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #ef4444; font-weight: 700;">O(2^N)</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #10b981; font-weight: 700;">O(N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; font-weight: 600;">LIS</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #ef4444; font-weight: 700;">O(2^N)</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #f59e0b; font-weight: 700;">O(NÂ²)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; font-weight: 600;">LCS</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #ef4444; font-weight: 700;">O(2^(M+N))</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #f59e0b; font-weight: 700;">O(MÃ—N)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; font-weight: 600;">Coin Change</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #ef4444; font-weight: 700;">O(C^Amount)</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; border-bottom: 1px solid #334155; text-align: center; color: #f59e0b; font-weight: 700;">O(CÃ—Amount)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 15px; font-weight: 600;">Edit Distance</td>
                                    <td style="padding: 15px; text-align: center; color: #ef4444; font-weight: 700;">O(3^(M+N))</td>
                                    <td style="padding: 15px; text-align: center; font-size: 1.5rem;">â†’</td>
                                    <td style="padding: 15px; text-align: center; color: #f59e0b; font-weight: 700;">O(MÃ—N)</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="color: #a78bfa; margin: 30px 0 15px;">Visual: How Memo Prunes the Tree</h3>
                        
                        <div style="background: #0f172a; padding: 25px; border-radius: 12px; font-family: 'Consolas', monospace; overflow-x: auto;">
                            <pre style="color: #e2e8f0; margin: 0; line-height: 1.4;">
    <span style="color: #ef4444;">WITHOUT MEMO:</span> Every node is computed
    
                      fib(5)
                     /      \\
                fib(4)        fib(3)  â† <span style="color: #ef4444;">Recomputed!</span>
               /    \\        /    \\
           fib(3)  fib(2)  fib(2)  fib(1)  â† <span style="color: #ef4444;">Recomputed!</span>
              â†“       â†“       â†“
            (more recomputation...)
    
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    
    <span style="color: #10b981;">WITH MEMO:</span> Reuse cached results (shown as â–£)
    
                      fib(5)
                     /      \\
                fib(4)       â–£ fib(3)  â† <span style="color: #10b981;">Cached! O(1)</span>
               /    \\        
           fib(3)   â–£ fib(2)  â† <span style="color: #10b981;">Cached! O(1)</span>
           /    \\
       fib(2)   â–£ fib(1)  â† <span style="color: #10b981;">Cached! O(1)</span>
       /    \\
   fib(1)   fib(0)
   
   Only 6 actual computations instead of 31!</pre>
                        </div>
                        
                        <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 12px; margin-top: 25px; border-left: 4px solid #10b981;">
                            <h4 style="color: #10b981; margin-bottom: 10px;">ğŸ’¡ Key Insight</h4>
                            <p style="color: #a7f3d0;">Memoization doesn't change the algorithm logic - it just avoids redundant work by remembering previous results!</p>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "time-patterns",
            title: "ğŸ“Š Time Patterns",
            icon: "fas fa-chart-bar",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-chart-bar"></i>
                            Every DP Pattern's Complexity
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Pattern 1: Simple Linear -->
                        <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #10b981; color: white; padding: 8px 14px; border-radius: 8px; font-weight: 700;">O(N)</span>
                                <h3 style="color: #34d399; margin: 0;">Simple Take/Not-Take</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">State: Only index | Work: O(1) decisions</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: Consolas;">
                                <code style="color: #7dd3fc;">memo[(index)] = result  # N unique states</code>
                            </div>
                            <p style="margin-top: 15px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Fibonacci, House Robber, Climbing Stairs
                            </p>
                        </div>
                        
                        <!-- Pattern 2: Two Parameter -->
                        <div style="background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #f59e0b; color: white; padding: 8px 14px; border-radius: 8px; font-weight: 700;">O(NÂ²)</span>
                                <h3 style="color: #fbbf24; margin: 0;">Two-Parameter State</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">State: (index, prev_index) or (index, remaining) | Work: O(1)</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: Consolas;">
                                <code style="color: #7dd3fc;">memo[(i, prev)] = result  # N Ã— N = NÂ² states</code>
                            </div>
                            <p style="margin-top: 15px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> LIS, Partition Equal Subset Sum
                            </p>
                        </div>
                        
                        <!-- Pattern 3: Two Strings -->
                        <div style="background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #8b5cf6; color: white; padding: 8px 14px; border-radius: 8px; font-weight: 700;">O(MÃ—N)</span>
                                <h3 style="color: #a78bfa; margin: 0;">Two-String DP</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">State: (i in string1, j in string2) | Work: O(1)</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: Consolas;">
                                <code style="color: #7dd3fc;">memo[(i, j)] = result  # M Ã— N states</code>
                            </div>
                            <p style="margin-top: 15px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> LCS, Edit Distance, Interleaving String
                            </p>
                        </div>
                        
                        <!-- Pattern 4: With Extra Work -->
                        <div style="background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #ef4444; color: white; padding: 8px 14px; border-radius: 8px; font-weight: 700;">O(NÂ³)</span>
                                <h3 style="color: #f87171; margin: 0;">String Partition</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">State: N positions | Work: O(N) loop + O(N) string slice!</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px; font-family: Consolas;">
                                <code style="color: #ef4444;"># N states Ã— (N loop Ã— N slice) = O(NÂ³)!</code><br>
                                <code style="color: #7dd3fc;">for end in range(start, n):  # O(N) loop</code><br>
                                <code style="color: #7dd3fc;">    s[start:end+1]  # O(N) string slice!</code>
                            </div>
                            <p style="margin-top: 15px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Word Break, Palindrome Partitioning
                            </p>
                        </div>
                        
                        <!-- Pattern 5: Knapsack -->
                        <div style="background: rgba(34, 211, 238, 0.05); border: 1px solid rgba(34, 211, 238, 0.2); border-radius: 16px; padding: 25px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #22d3ee; color: black; padding: 8px 14px; border-radius: 8px; font-weight: 700;">O(NÃ—Target)</span>
                                <h3 style="color: #22d3ee; margin: 0;">Knapsack Variants</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">State: (index, remaining_capacity) | Work: O(1)</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                    <p style="color: #22d3ee; margin-bottom: 8px; font-size: 0.85rem;">0/1 Knapsack</p>
                                    <code style="color: #7dd3fc; font-size: 0.85rem;">O(N Ã— Capacity)</code>
                                </div>
                                <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                    <p style="color: #f59e0b; margin-bottom: 8px; font-size: 0.85rem;">Unbounded (Coin Change)</p>
                                    <code style="color: #7dd3fc; font-size: 0.85rem;">O(Coins Ã— Amount)</code>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "space-analysis",
            title: "ğŸ“¦ Space Deep Dive",
            icon: "fas fa-memory",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-memory"></i>
                            Space Complexity: The Full Picture
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#c026d3; color:white;">DEEP DIVE</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.2rem; font-weight: 600; text-align: center; padding: 25px; background: linear-gradient(135deg, rgba(192, 38, 211, 0.1), rgba(139, 92, 246, 0.1)); border-radius: 12px; margin: 20px 0;">
                            Space = <span style="color:#c026d3;">Recursion Stack</span> + <span style="color:#a78bfa;">Memoization Table</span>
                        </div>
                        
                        <h3 style="color: #c026d3; margin: 25px 0 15px;">
                            <i class="fas fa-layer-group"></i> Part 1: Recursion Stack
                        </h3>
                        
                        <div style="background: #0f172a; padding: 25px; border-radius: 12px; font-family: 'Consolas', monospace; margin-bottom: 20px; overflow-x: auto;">
                            <pre style="color: #e2e8f0; margin: 0; line-height: 1.5;">
    Call Stack Visualization for fib(5):
    
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  fib(0) â† Currently executing       â”‚  â† Max Depth = N
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  fib(1)                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  fib(2)                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  fib(3)                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  fib(4)                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  fib(5) â† First call                â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    Stack grows DOWN as we recurse deeper
    Each frame stores: local vars + return address</pre>
                        </div>
                        
                        <div style="background: rgba(192, 38, 211, 0.1); padding: 20px; border-radius: 12px; border-left: 4px solid #c026d3; margin-bottom: 25px;">
                            <h4 style="color: #c026d3; margin-bottom: 10px;">Stack Depth Formula</h4>
                            <p><strong>Max Stack Depth = Longest path from root to leaf in recursion tree</strong></p>
                            <ul style="line-height: 2; margin-top: 10px;">
                                <li><strong>Fibonacci:</strong> O(N) - goes fib(n) â†’ fib(n-1) â†’ ... â†’ fib(0)</li>
                                <li><strong>LCS:</strong> O(M+N) - at most M+N recursive calls deep</li>
                                <li><strong>Binary Tree:</strong> O(H) where H = height of tree</li>
                            </ul>
                        </div>
                        
                        <h3 style="color: #a78bfa; margin: 30px 0 15px;">
                            <i class="fas fa-table"></i> Part 2: Memoization Table
                        </h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #8b5cf6, #a78bfa);">
                                    <th style="padding: 15px; text-align: left; color: white;">Problem</th>
                                    <th style="padding: 15px; text-align: left; color: white;">Memo Table Size</th>
                                    <th style="padding: 15px; text-align: left; color: white;">Optimizable?</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Fibonacci</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc;">O(N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #10b981;">âœ… O(1) - only need last 2</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">House Robber</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc;">O(N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #10b981;">âœ… O(1) - rolling variables</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">LCS</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #7dd3fc;">O(MÃ—N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #f59e0b;">ğŸ”¶ O(min(M,N)) - 1 row</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px;">Coin Change</td>
                                    <td style="padding: 12px; color: #7dd3fc;">O(Amount)</td>
                                    <td style="padding: 12px; color: #ef4444;">âŒ Can't reduce further</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="color: #ef4444; margin: 30px 0 15px;">
                            <i class="fas fa-exclamation-triangle"></i> Stack Overflow Warning!
                        </h3>
                        <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);">
                            <p style="margin-bottom: 15px;">Python default recursion limit: <strong style="color: #ef4444;">1000 calls</strong></p>
                            <p style="margin-bottom: 10px;">For N > 1000, you'll get:</p>
                            <code style="background: #0f172a; padding: 8px 12px; border-radius: 6px; color: #f87171; display: block; margin: 10px 0;">RecursionError: maximum recursion depth exceeded</code>
                            <p style="margin-top: 15px;"><strong>Solutions:</strong></p>
                            <ul style="line-height: 2;">
                                <li><code>import sys; sys.setrecursionlimit(10000)</code></li>
                                <li>Convert to iterative DP (bottom-up)</li>
                            </ul>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "real-numbers",
            title: "ğŸ”¢ Real Numbers",
            icon: "fas fa-calculator",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-calculator"></i>
                            What The Numbers Actually Mean
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#ef4444; color:white;">REALITY CHECK</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.3rem; font-weight: 600; text-align: center; padding: 25px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(245, 158, 11, 0.1)); border-radius: 12px; margin: 20px 0;">
                            LeetCode judges: ~10â¸ operations/second
                        </div>
                        
                        <h3 style="color: #f59e0b; margin: 25px 0 15px;">2^N Growth - The Horror Show</h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #ef4444, #f87171);">
                                    <th style="padding: 15px; text-align: center; color: white;">N</th>
                                    <th style="padding: 15px; text-align: right; color: white;">2^N Operations</th>
                                    <th style="padding: 15px; text-align: right; color: white;">Time @ 10â¸/sec</th>
                                    <th style="padding: 15px; text-align: center; color: white;">Result</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155;">10</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155; color: #7dd3fc;">1,024</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155;">0.00001 sec</td>
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155; color: #10b981;">âœ… Fast</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155;">20</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155; color: #7dd3fc;">1,048,576</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155;">0.01 sec</td>
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155; color: #10b981;">âœ… OK</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155;">30</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155; color: #fbbf24;">1,073,741,824</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155;">10.7 sec</td>
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155; color: #ef4444;">âŒ TLE</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155;">40</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155; color: #ef4444;">1,099,511,627,776</td>
                                    <td style="padding: 12px; text-align: right; border-bottom: 1px solid #334155;">3 hours</td>
                                    <td style="padding: 12px; text-align: center; border-bottom: 1px solid #334155; color: #ef4444;">ğŸ’€ Dead</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; text-align: center;">50</td>
                                    <td style="padding: 12px; text-align: right; color: #ef4444;">1,125,899,906,842,624</td>
                                    <td style="padding: 12px; text-align: right;">130 days</td>
                                    <td style="padding: 12px; text-align: center; color: #ef4444;">â˜ ï¸ RIP</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="color: #10b981; margin: 30px 0 15px;">What Complexity Can Handle What N?</h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; margin-top: 15px;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #10b981, #34d399);">
                                    <th style="padding: 15px; text-align: left; color: white;">Complexity</th>
                                    <th style="padding: 15px; text-align: center; color: white;">Max N for 1 sec</th>
                                    <th style="padding: 15px; text-align: left; color: white;">Typical Problems</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; font-weight: 600;">O(N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; text-align: center; color: #10b981; font-weight: 700;">10â¸</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: gray;">House Robber, Fibonacci</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; font-weight: 600;">O(N log N)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; text-align: center; color: #10b981; font-weight: 700;">10â·</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: gray;">LIS (Binary Search)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; font-weight: 600;">O(NÂ²)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; text-align: center; color: #f59e0b; font-weight: 700;">10â´</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: gray;">LIS, LCS, Edit Distance</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; font-weight: 600;">O(NÂ³)</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; text-align: center; color: #f59e0b; font-weight: 700;">500</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: gray;">Word Break, Matrix Chain</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; font-weight: 600;">O(2^N)</td>
                                    <td style="padding: 12px; text-align: center; color: #ef4444; font-weight: 700;">20-25</td>
                                    <td style="padding: 12px; color: gray;">Subsets, Permutations</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 12px; margin-top: 25px; border-left: 4px solid #8b5cf6;">
                            <h4 style="color: #a78bfa; margin-bottom: 10px;">ğŸ’¡ Quick Check Rule</h4>
                            <p>Look at constraints in problem:</p>
                            <ul style="line-height: 2;">
                                <li>N â‰¤ 20 â†’ O(2^N) might work (brute force ok)</li>
                                <li>N â‰¤ 10â´ â†’ Need at least O(NÂ²)</li>
                                <li>N â‰¤ 10âµ â†’ Need O(N log N) or O(N)</li>
                                <li>N â‰¤ 10â¸ â†’ Must be O(N) or O(1)</li>
                            </ul>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "mistakes",
            title: "âš ï¸ Mistakes",
            icon: "fas fa-exclamation-triangle",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Common Complexity Mistakes
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#ef4444; color:white;">AVOID THESE!</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Mistake 1 -->
                        <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #ef4444; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">1</span>
                                <strong style="color: #f87171; font-size: 1.1rem;">Counting Recursive Calls Instead of States</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">"My function calls itself twice, so it's O(2^N)"</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                    <p style="color: #ef4444; margin-bottom: 8px; font-size: 0.85rem;">âŒ WRONG Thinking</p>
                                    <code style="color: #f87171; font-size: 0.85rem;">2 calls per state = O(2^N)</code>
                                </div>
                                <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                    <p style="color: #10b981; margin-bottom: 8px; font-size: 0.85rem;">âœ… RIGHT Thinking</p>
                                    <code style="color: #34d399; font-size: 0.85rem;">N unique states Ã— O(1) = O(N)</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mistake 2 -->
                        <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #f59e0b; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">2</span>
                                <strong style="color: #fbbf24; font-size: 1.1rem;">Forgetting String Slicing Cost</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">String slicing in Python creates a NEW string = O(length) time!</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <code style="color: #f59e0b;">
                                    # Word Break: s[start:end+1]<br>
                                    # This is O(end - start), NOT O(1)!<br><br>
                                    # Total: N states Ã— N loop Ã— N slice = O(NÂ³)
                                </code>
                            </div>
                            <p style="color: gray; font-size: 0.9rem;"><strong>Fix:</strong> Use index comparisons or hash the string</p>
                        </div>
                        
                        <!-- Mistake 3 -->
                        <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #8b5cf6; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">3</span>
                                <strong style="color: #a78bfa; font-size: 1.1rem;">Ignoring Hidden Loops</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">Some operations have hidden loops you might miss:</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                <code style="color: #a78bfa;">
                                    word in wordSet  # O(len(word)) for hashing!<br>
                                    list(set)        # O(N) to convert<br>
                                    string + string  # O(N) - creates new string<br>
                                    arr.copy()       # O(N) - copies all elements<br>
                                    "x" * n          # O(N) - creates n-length string
                                </code>
                            </div>
                        </div>
                        
                        <!-- Mistake 4 -->
                        <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #10b981; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">4</span>
                                <strong style="color: #34d399; font-size: 1.1rem;">Not Recognizing State Dependencies</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;">Different parameters = Different states!</p>
                            <div style="background: #0f172a; padding: 15px; border-radius: 8px;">
                                <code style="color: #34d399;">
                                    # LIS: memo[index] is WRONG!<br>
                                    # Because result depends on prev_index too<br><br>
                                    # Correct: memo[(index, prev_index)]<br>
                                    # States: N Ã— N = O(NÂ²)
                                </code>
                            </div>
                        </div>
                        
                        <div style="background: rgba(245, 158, 11, 0.1); padding: 20px; border-radius: 12px; margin-top: 25px; border-left: 4px solid #f59e0b;">
                            <h4 style="color: #fbbf24; margin-bottom: 10px;">ğŸ’¡ Pro Tip</h4>
                            <p>When calculating complexity, always ask:</p>
                            <ol style="line-height: 2; margin-top: 10px;">
                                <li>What are the state parameters? (memo key)</li>
                                <li>How many unique combinations exist?</li>
                                <li>What work happens INSIDE each state? (loops, string ops)</li>
                                <li>Multiply: States Ã— Work per State = Answer</li>
                            </ol>
                        </div>
                    </div>
                </div>`
        }
    ]
};


// ========== data/concepts/stack_concepts.js ==========
// Stack Concepts data
// Extracted from data.js

const topic_stack_concepts = {
    id: "stack_concepts",
    title: "Stack Mastery: The Monotonic Framework",
    description: "Master the Art of 'Waiting Room' Logic",
    color: "#7c3aed",
    icon: "fas fa-layer-group",
    type: "guide",
    sections: [
        {
            id: "philosophy",
            title: "ğŸ§  Philosophy",
            icon: "fas fa-lightbulb",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-lightbulb"></i>
                            The "Waiting Room" Philosophy
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#7c3aed; color:white;">CORE CONCEPT</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(139, 92, 246, 0.1)); border-radius: 12px; border: 2px solid var(--border); margin: 30px 0; line-height: 1.8;">
                            "Stack ek <span style='color:#7c3aed; font-weight:800;'>Waiting Room</span> hai. Elements tab tak wait karte hain jab tak unhe koi 'Resolve' karne wala na mil jaye."
                        </div>
                        
                        <div style="background: rgba(124, 58, 237, 0.1); padding: 25px; border-radius: 12px; border-left: 4px solid #7c3aed; margin: 25px 0;">
                            <h4 style="margin-bottom:15px; color:#a78bfa;"><i class="fas fa-star"></i> Why It Works</h4>
                            <ul style="list-style:none; padding-left:0; line-height:2;">
                                <li>âœ… <strong>Time Travel:</strong> Hum past ke un elements ko access kar sakte hain jo abhi "unresolved" hain.</li>
                                <li>âœ… <strong>O(N) Magic:</strong> Each element is pushed ONCE and popped ONCE. Linear time guaranteed!</li>
                                <li>âœ… <strong>Structure:</strong> Nested problems (brackets, recursive calls) ko linear way mein handle karta hai.</li>
                            </ul>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #a78bfa;">
                            <i class="fas fa-layer-group"></i> The Monotonic Stack Rule
                        </h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                            <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                <div style="font-size:2rem; margin-bottom:10px;">ğŸ“‰</div>
                                <strong style="color:#ef4444;">Decreasing Stack</strong>
                                <p style="font-size:0.9rem; color:gray; margin-top:8px;">Find <strong>Next Greater</strong></p>
                                <p style="font-size:0.8rem; color:gray;">Jab tak chote hain, wait karo. Bada aaya toh pop!</p>
                            </div>
                            <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                <div style="font-size:2rem; margin-bottom:10px;">ğŸ“ˆ</div>
                                <strong style="color:#10b981;">Increasing Stack</strong>
                                <p style="font-size:0.9rem; color:gray; margin-top:8px;">Find <strong>Next Smaller</strong></p>
                                <p style="font-size:0.8rem; color:gray;">Jab tak bade hain, wait karo. Chota aaya toh pop!</p>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "roadmap",
            title: "ğŸ—ºï¸ Roadmap",
            icon: "fas fa-route",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-route"></i>
                            Stack Mastery Roadmap
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">4 LEVELS</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            Start from basics and climb to the top.
                        </p>
                        
                        <div style="display: flex; flex-direction: column; gap: 15px;">
                            
                            <!-- Level 1 -->
                            <a href="learn.html?topic=stack&q=next-greater-element" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), rgba(124, 58, 237, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(124, 58, 237, 0.3); transition: transform 0.2s;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #7c3aed; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 1</span>
                                            <strong style="color: white; font-size: 1.1rem;">Next Greater Element</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Learn:</strong> The basic Monotonic Decreasing Stack.
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #7c3aed;"></i>
                                </div>
                            </a>

                            <!-- Level 2 -->
                            <a href="learn.html?topic=stack&q=asteroid-collision" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3); transition: transform 0.2s;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #ef4444; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 2</span>
                                            <strong style="color: white; font-size: 1.1rem;">Asteroid Collision</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Learn:</strong> Collision Logic & Left/Right interactions.
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #ef4444;"></i>
                                </div>
                            </a>

                            <!-- Level 3 -->
                            <a href="learn.html?topic=stack&q=largest-rectangle-in-histogram" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(245, 158, 11, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #f59e0b; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">LEVEL 3</span>
                                            <strong style="color: white; font-size: 1.1rem;">Histogram Area</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Learn:</strong> Finding Expansion Limits (Left & Right).
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #f59e0b;"></i>
                                </div>
                            </a>
                            
                            <!-- Level 4 -->
                            <a href="learn.html?topic=stack&q=trapping-rain-water" style="text-decoration: none; display: block; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(16, 185, 129, 0.05)); padding: 20px; border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.3);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <span style="background: #10b981; color: white; padding: 4px 10px; border-radius: 6px; font-size: 0.8rem; font-weight: 700;">BOSS</span>
                                            <strong style="color: white; font-size: 1.1rem;">Trapping Rain Water</strong>
                                        </div>
                                        <p style="color: gray; font-size: 0.9rem; margin: 0;">
                                            <strong style="color:#a78bfa;">Learn:</strong> 3-Bar Logic (Left, Right, Base) - "The Bowl".
                                        </p>
                                    </div>
                                    <i class="fas fa-arrow-right" style="color: #10b981;"></i>
                                </div>
                            </a>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "patterns",
            title: "ğŸ§© 3 Patterns",
            icon: "fas fa-puzzle-piece",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-puzzle-piece"></i>
                            The 3 Stack Patterns
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            Ye 3 patterns samajh liye toh Stack ke 80% questions solved!
                        </p>
                        
                        <!-- Pattern 1: NGE -->
                        <div style="background: rgba(124, 58, 237, 0.05); border: 1px solid rgba(124, 58, 237, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #7c3aed; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">1</span>
                                <h3 style="color: #a78bfa; margin: 0;">The Monotonic Decreasing Stack</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Next Greater Element dhoondo"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                while stack and arr[stack[-1]] < arr[i]:<br>
                                &nbsp;&nbsp;smaller_index = stack.pop()<br>
                                &nbsp;&nbsp;result[smaller_index] = arr[i]  # Founded Next Greater!<br>
                                stack.append(i)
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Logic:</strong> Chote wale wait karenge, Bada aayega toh sabko pop kar dega.
                            </p>
                        </div>
                        
                        <!-- Pattern 2: Expansion Limits -->
                        <div style="background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #f59e0b; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">2</span>
                                <h3 style="color: #fbbf24; margin: 0;">The Expansion Limits (Previous Smaller)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Area, Rectangle, ya Span dhoondo"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                while stack and arr[stack[-1]] >= arr[i]:<br>
                                &nbsp;&nbsp;h = arr[stack.pop()]  # Height is fully determined<br>
                                &nbsp;&nbsp;w = i - stack[-1] - 1  # Right Limit - Left Limit - 1<br>
                                &nbsp;&nbsp;max_area = max(max_area, h * w)
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Logic:</strong> Jab chota element aata hai, toh current height ka raaj khatam. Calculate kar lo!
                            </p>
                        </div>
                        
                        <!-- Pattern 3: Collision / Matching -->
                        <div style="background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 16px; padding: 25px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #ef4444; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">3</span>
                                <h3 style="color: #f87171; margin: 0;">Collision & Matching</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Brackets, Asteroids, ya adjacent pair removal"</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                if stack and matches(stack[-1], current):<br>
                                &nbsp;&nbsp;stack.pop()  # Destroy/Match/Resolves<br>
                                else:<br>
                                &nbsp;&nbsp;stack.append(current)  # Wait for partner
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Logic:</strong> Aane wala element stack ke top se react karta hai.
                            </p>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "mistakes",
            title: "âš ï¸ Mistakes",
            icon: "fas fa-exclamation-triangle",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Common Stack Mistakes
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#ef4444; color:white;">TRAPS</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Mistake 1 -->
                        <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #ef4444; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">1</span>
                                <strong style="color: #f87171; font-size: 1.1rem;">Storing Values Instead of Indices</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Values store karne se aap original position lose kar dete ho. Width kaise nikaloge?</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #ef4444; margin-bottom: 8px; font-size: 0.85rem;">âŒ WRONG</p>
                                    <code style="color: #f87171; font-family: Consolas; font-size: 0.85rem;">stack.append(arr[i])</code>
                                </div>
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #10b981; margin-bottom: 8px; font-size: 0.85rem;">âœ… RIGHT</p>
                                    <code style="color: #34d399; font-family: Consolas; font-size: 0.85rem;">stack.append(i)</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mistake 2 -->
                        <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #f59e0b; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">2</span>
                                <strong style="color: #fbbf24; font-size: 1.1rem;">Infinite Loop / TLE</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">While loop condition galat likhne se stack kabhi empty nahi hota ya infinite loop chalta hai.</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #f59e0b; font-family: Consolas; font-size: 0.85rem;">
                                    # Always check stack is not empty FIRST<br>
                                    while stack and arr[stack[-1]] < arr[i]:<br>
                                    &nbsp;&nbsp;stack.pop()
                                </code>
                            </div>
                        </div>

                    </div>
                </div>`
        }
    ]
};


// ========== data/concepts/backtracking_concepts.js ==========
// Backtracking Concepts data
// Complete Mastery Guide

const topic_backtracking_concepts = {
    id: "backtracking_concepts",
    title: "ğŸ”¥ Backtracking Mastery",
    description: "The Ultimate Guide - Hamesha Ke Liye!",
    color: "#f59e0b",
    icon: "fas fa-undo",
    type: "guide",
    sections: [
        {
            id: "core-concept",
            title: "ğŸ¯ Core Concept",
            icon: "fas fa-bullseye",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-bullseye"></i>
                            What is Backtracking?
                        </div>
                        <div class="badges">
                            <span class="badge badge-must" style="background:#ef4444; color:white;">FOUNDATION</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="big-quote" style="font-size: 1.4rem; font-weight: 600; text-align: center; padding: 30px; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1)); border-radius: 12px; border: 2px solid var(--border); margin: 30px 0; line-height: 1.8;">
                            "Try karo â†’ Agar galat raha toh wapas aao â†’ Doosra option try karo"
                        </div>
                        
                        <div style="background: rgba(245, 158, 11, 0.1); padding: 25px; border-radius: 12px; border-left: 4px solid #f59e0b; margin: 25px 0;">
                            <h4 style="margin-bottom:15px; color:#fbbf24;"><i class="fas fa-star"></i> The 3-Step Pattern (ALWAYS!)</h4>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;">
                                <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                    <div style="font-size:2rem; margin-bottom:10px;">1ï¸âƒ£</div>
                                    <strong style="color:#10b981;">CHOOSE</strong>
                                    <p style="font-size:0.9rem; color:gray; margin-top:8px;">Make a decision</p>
                                </div>
                                <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                    <div style="font-size:2rem; margin-bottom:10px;">2ï¸âƒ£</div>
                                    <strong style="color:#8b5cf6;">EXPLORE</strong>
                                    <p style="font-size:0.9rem; color:gray; margin-top:8px;">Recursively explore</p>
                                </div>
                                <div style="background: rgba(239, 68, 68, 0.1); padding: 20px; border-radius: 12px; text-align:center;">
                                    <div style="font-size:2rem; margin-bottom:10px;">3ï¸âƒ£</div>
                                    <strong style="color:#ef4444;">UNCHOOSE</strong>
                                    <p style="font-size:0.9rem; color:gray; margin-top:8px;">Undo (backtrack)</p>
                                </div>
                            </div>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #fbbf24;">
                            <i class="fas fa-code"></i> Universal Template
                        </h3>
                        
                        <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                            <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.9rem; line-height: 1.6;">def backtrack(state):
    if is_solution(state):
        process_solution(state)
        return
    
    for choice in get_choices(state):
        # CHOOSE
        make_choice(choice, state)
        
        # EXPLORE
        backtrack(state)
        
        # UNCHOOSE (backtrack)
        undo_choice(choice, state)</pre>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #fbbf24;">
                            <i class="fas fa-balance-scale"></i> Backtracking vs Other Techniques
                        </h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #f59e0b, #fbbf24);">
                                    <th style="padding: 15px; text-align: left; color: black;">Technique</th>
                                    <th style="padding: 15px; text-align: left; color: black;">When to Use</th>
                                    <th style="padding: 15px; text-align: left; color: black;">Example</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #fbbf24;"><strong>Backtracking</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Generate ALL possibilities</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Permutations, N-Queens</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; border-bottom: 1px solid #334155; color: #8b5cf6;"><strong>DP</strong></td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Overlapping subproblems</td>
                                    <td style="padding: 12px; border-bottom: 1px solid #334155;">Knapsack, LCS</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 12px; color: #10b981;"><strong>Greedy</strong></td>
                                    <td style="padding: 12px;">Local optimal â†’ Global</td>
                                    <td style="padding: 12px;">Activity selection</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>`
        },
        {
            id: "pattern-recognition",
            title: "ğŸ§  5 Patterns",
            icon: "fas fa-puzzle-piece",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-puzzle-piece"></i>
                            The 5 Backtracking Patterns
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            <strong>95% backtracking problems</strong> in 5 patterns ke andar aate hain. Pattern pehchaan lo!
                        </p>
                        
                        <!-- Pattern 1: Subset -->
                        <div style="background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #8b5cf6; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">1</span>
                                <h3 style="color: #a78bfa; margin: 0;">SUBSET Pattern (Pick/No-Pick)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Find all subsets/combinations" | Each element: include OR exclude</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                current.append(arr[index])  # PICK<br>
                                backtrack(index + 1, current)<br>
                                current.pop()               # Backtrack<br><br>
                                backtrack(index + 1, current)  # NO-PICK
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Subsets, Subset Sum, Combination Sum
                            </p>
                            <p style="color: #a78bfa; font-size: 0.85rem;"><strong>Time:</strong> O(2^n) | <strong>Space:</strong> O(n)</p>
                        </div>
                        
                        <!-- Pattern 2: Permutation -->
                        <div style="background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #f59e0b; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">2</span>
                                <h3 style="color: #fbbf24; margin: 0;">PERMUTATION Pattern (Swapping)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Find all arrangements" | Order MATTERS | All elements used</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                for i in range(index, len(arr)):<br>
                                &nbsp;&nbsp;arr[index], arr[i] = arr[i], arr[index]  # Swap<br>
                                &nbsp;&nbsp;backtrack(index + 1)<br>
                                &nbsp;&nbsp;arr[index], arr[i] = arr[i], arr[index]  # Swap back
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Permutations, Permutations II, Letter Case Permutation
                            </p>
                            <p style="color: #fbbf24; font-size: 0.85rem;"><strong>Time:</strong> O(n! Ã— n) | <strong>Space:</strong> O(n)</p>
                        </div>
                        
                        <!-- Pattern 3: Combination -->
                        <div style="background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #ef4444; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">3</span>
                                <h3 style="color: #f87171; margin: 0;">COMBINATION Pattern (Start Index)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> "Find combinations of size k" | Order doesn't matter | Avoid duplicates</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                for i in range(start, len(arr)):<br>
                                &nbsp;&nbsp;current.append(arr[i])<br>
                                &nbsp;&nbsp;backtrack(i + 1, current)  # i+1: no reuse<br>
                                &nbsp;&nbsp;# backtrack(i, ...)       # i: unlimited use<br>
                                &nbsp;&nbsp;current.pop()
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Combinations, Combination Sum I/II, Generate Parentheses
                            </p>
                            <p style="color: #f87171; font-size: 0.85rem;"><strong>Time:</strong> O(C(n,k) Ã— k) | <strong>Space:</strong> O(k)</p>
                        </div>
                        
                        <!-- Pattern 4: Grid -->
                        <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2); border-radius: 16px; padding: 25px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #10b981; color: white; padding: 6px 12px; border-radius: 8px; font-weight: 700;">4</span>
                                <h3 style="color: #34d399; margin: 0;">GRID Pattern (DFS Backtracking)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> 2D matrix | Explore paths/neighbors | 4 directions</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                visited[r][c] = True  # Mark<br>
                                for dr, dc in [(0,1),(1,0),(0,-1),(-1,0)]:<br>
                                &nbsp;&nbsp;backtrack(r + dr, c + dc, state)<br>
                                visited[r][c] = False  # Unmark (backtrack)
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> Word Search, Number of Islands, Rat in Maze
                            </p>
                            <p style="color: #34d399; font-size: 0.85rem;"><strong>Time:</strong> O(4^(mÃ—n)) | <strong>Space:</strong> O(mÃ—n)</p>
                        </div>
                        
                        <!-- Pattern 5: Constraint -->
                        <div style="background: rgba(34, 211, 238, 0.05); border: 1px solid rgba(34, 211, 238, 0.2); border-radius: 16px; padding: 25px;">
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px;">
                                <span style="background: #22d3ee; color: black; padding: 6px 12px; border-radius: 8px; font-weight: 700;">5</span>
                                <h3 style="color: #22d3ee; margin: 0;">CONSTRAINT Pattern (Validation)</h3>
                            </div>
                            <p style="color: gray; margin-bottom: 15px;"><strong>Pehchaan:</strong> Multiple rules to satisfy | Check validity at each step | Early pruning</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px; font-family: Consolas; color: #7dd3fc; font-size: 0.9rem;">
                                for col in range(n):<br>
                                &nbsp;&nbsp;if is_valid(row, col):  # Check constraints<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;place(row, col)<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;backtrack(row + 1)<br>
                                &nbsp;&nbsp;&nbsp;&nbsp;remove(row, col)
                            </div>
                            <p style="margin-top: 12px; color: gray; font-size: 0.9rem;">
                                <strong>Problems:</strong> N-Queens, Sudoku Solver, Graph Coloring
                            </p>
                            <p style="color: #22d3ee; font-size: 0.85rem;"><strong>Time:</strong> O(n!) with pruning | <strong>Space:</strong> O(nÂ²)</p>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "decision-tree",
            title: "ğŸŒ³ Decision Tree",
            icon: "fas fa-sitemap",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-sitemap"></i>
                            Pattern Selection Guide
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">INTERVIEW QUICK-PICK</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div style="background: #0f172a; padding: 25px; border-radius: 12px; font-family: Consolas; color: #e2e8f0; line-height: 2;">
                            <pre style="color: #e2e8f0;">
                     START
                       |
        "Problem mein kya chahiye?"
                       |
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â†“                               â†“
  ALL possibilities              OPTIMAL solution
       |                               |
       â†“                               â†“
  BACKTRACKING                     DP/GREEDY
       |
       â”œâ”€â”€ Order matters? â”€â”€â”€â”€â”€â†’ PERMUTATION
       â”‚
       â”œâ”€â”€ Size k select? â”€â”€â”€â”€â”€â†’ COMBINATION  
       â”‚
       â”œâ”€â”€ All subsets? â”€â”€â”€â”€â”€â”€â”€â†’ SUBSET (Pick/No-Pick)
       â”‚
       â”œâ”€â”€ Grid/Path explore? â”€â†’ GRID DFS
       â”‚
       â””â”€â”€ Rules/Constraints? â”€â†’ CONSTRAINT SATISFACTION
                            </pre>
                        </div>
                        
                        <h3 style="margin: 30px 0 15px 0; color: #fbbf24;">
                            <i class="fas fa-key"></i> Quick Keywords Mapping
                        </h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #f59e0b, #fbbf24);">
                                    <th style="padding: 12px; text-align: left; color: black;">Keyword in Problem</th>
                                    <th style="padding: 12px; text-align: left; color: black;">â†’ Pattern</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;"><td style="padding: 10px; border-bottom: 1px solid #334155;">"all subsets", "power set"</td><td style="padding: 10px; border-bottom: 1px solid #334155; color: #a78bfa;">SUBSET</td></tr>
                                <tr style="background: #1e293b;"><td style="padding: 10px; border-bottom: 1px solid #334155;">"all permutations", "arrangements"</td><td style="padding: 10px; border-bottom: 1px solid #334155; color: #fbbf24;">PERMUTATION</td></tr>
                                <tr style="background: #1e293b;"><td style="padding: 10px; border-bottom: 1px solid #334155;">"combinations of size k", "choose k"</td><td style="padding: 10px; border-bottom: 1px solid #334155; color: #f87171;">COMBINATION</td></tr>
                                <tr style="background: #1e293b;"><td style="padding: 10px; border-bottom: 1px solid #334155;">"find path", "word exists in grid"</td><td style="padding: 10px; border-bottom: 1px solid #334155; color: #34d399;">GRID DFS</td></tr>
                                <tr style="background: #1e293b;"><td style="padding: 10px;">"place n items", "satisfy rules"</td><td style="padding: 10px; color: #22d3ee;">CONSTRAINT</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>`
        },
        {
            id: "templates",
            title: "ğŸ“ Templates",
            icon: "fas fa-file-code",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-file-code"></i>
                            Ready-to-Use Templates
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#8b5cf6; color:white;">COPY-PASTE</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Template 1: Subsets -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #a78bfa; margin-bottom: 15px;"><i class="fas fa-layer-group"></i> Template 1: Subset Generation</h4>
                            <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                                <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.85rem; line-height: 1.6;">def subsets(nums):
    result = []
    
    def backtrack(index, current):
        if index == len(nums):
            result.append(current[:])  # COPY!
            return
        
        # PICK
        current.append(nums[index])
        backtrack(index + 1, current)
        current.pop()  # Backtrack
        
        # NO-PICK
        backtrack(index + 1, current)
    
    backtrack(0, [])
    return result
# Time: O(2^n Ã— n), Space: O(n)</pre>
                            </div>
                        </div>
                        
                        <!-- Template 2: Permutations -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #fbbf24; margin-bottom: 15px;"><i class="fas fa-random"></i> Template 2: Permutation (Swapping)</h4>
                            <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                                <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.85rem; line-height: 1.6;">def permute(nums):
    result = []
    
    def backtrack(index):
        if index == len(nums):
            result.append(nums[:])  # COPY!
            return
        
        for i in range(index, len(nums)):
            nums[index], nums[i] = nums[i], nums[index]  # Swap
            backtrack(index + 1)
            nums[index], nums[i] = nums[i], nums[index]  # Swap back
    
    backtrack(0)
    return result
# Time: O(n! Ã— n), Space: O(n)</pre>
                            </div>
                        </div>
                        
                        <!-- Template 3: Combinations -->
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #f87171; margin-bottom: 15px;"><i class="fas fa-th"></i> Template 3: Combination (Size k)</h4>
                            <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                                <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.85rem; line-height: 1.6;">def combine(n, k):
    result = []
    
    def backtrack(start, current):
        if len(current) == k:
            result.append(current[:])
            return
        
        for i in range(start, n + 1):
            current.append(i)
            backtrack(i + 1, current)  # i+1: avoid reuse
            current.pop()
    
    backtrack(1, [])
    return result
# Time: O(C(n,k) Ã— k), Space: O(k)</pre>
                            </div>
                        </div>
                        
                        <!-- Template 4: Grid DFS -->
                        <div>
                            <h4 style="color: #34d399; margin-bottom: 15px;"><i class="fas fa-border-all"></i> Template 4: Grid DFS (Word Search)</h4>
                            <div style="background: #0f172a; border-radius: 12px; padding: 20px;">
                                <pre style="color: #e2e8f0; font-family: 'Consolas', monospace; font-size: 0.85rem; line-height: 1.6;">def exist(board, word):
    rows, cols = len(board), len(board[0])
    
    def backtrack(r, c, idx):
        if idx == len(word): return True
        if r < 0 or r >= rows or c < 0 or c >= cols: return False
        if board[r][c] != word[idx]: return False
        
        temp = board[r][c]
        board[r][c] = '#'  # Mark visited
        
        found = (backtrack(r+1, c, idx+1) or
                 backtrack(r-1, c, idx+1) or
                 backtrack(r, c+1, idx+1) or
                 backtrack(r, c-1, idx+1))
        
        board[r][c] = temp  # Restore (backtrack)
        return found
    
    for i in range(rows):
        for j in range(cols):
            if backtrack(i, j, 0): return True
    return False
# Time: O(mÃ—n Ã— 4^L), Space: O(L)</pre>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "problems",
            title: "ğŸ¯ Problems",
            icon: "fas fa-tasks",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-tasks"></i>
                            Practice Roadmap
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#10b981; color:white;">LEVEL-WISE</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <p style="color: gray; margin-bottom: 25px;">
                            In order practice karo. Har level ek naya complexity add karta hai!
                        </p>
                        
                        <!-- Level 1 -->
                        <div style="background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #10b981; color: white; padding: 4px 12px; border-radius: 6px; font-weight: 700;">LEVEL 1</span>
                                <strong style="color: #34d399;">Easy - Basic Patterns</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                                <a href="learn.html?topic=backtracking&q=subsets" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#34d399;">Subsets</a>
                                <a href="learn.html?topic=backtracking&q=permutations" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#34d399;">Permutations</a>
                                <a href="learn.html?topic=backtracking&q=combinations" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#34d399;">Combinations</a>
                            </div>
                        </div>
                        
                        <!-- Level 2 -->
                        <div style="background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #f59e0b; color: white; padding: 4px 12px; border-radius: 6px; font-weight: 700;">LEVEL 2</span>
                                <strong style="color: #fbbf24;">Medium - Variations</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <a href="learn.html?topic=backtracking&q=combination-sum" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#fbbf24;">Combination Sum</a>
                                <a href="learn.html?topic=backtracking&q=permutations-ii" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#fbbf24;">Permutations II</a>
                                <a href="learn.html?topic=backtracking&q=subsets-ii" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#fbbf24;">Subsets II</a>
                                <a href="learn.html?topic=backtracking&q=generate-parentheses" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#fbbf24;">Generate ()</a>
                            </div>
                        </div>
                        
                        <!-- Level 3 -->
                        <div style="background: rgba(139, 92, 246, 0.05); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 15px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #8b5cf6; color: white; padding: 4px 12px; border-radius: 6px; font-weight: 700;">LEVEL 3</span>
                                <strong style="color: #a78bfa;">Medium-Hard - Grid & Strings</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <a href="learn.html?topic=backtracking&q=word-search" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#a78bfa;">Word Search</a>
                                <a href="learn.html?topic=backtracking&q=letter-combinations" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#a78bfa;">Letter Combos</a>
                            </div>
                        </div>
                        
                        <!-- Level 4 -->
                        <div style="background: rgba(239, 68, 68, 0.05); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #ef4444; color: white; padding: 4px 12px; border-radius: 6px; font-weight: 700;">BOSS</span>
                                <strong style="color: #f87171;">Hard - Constraint Satisfaction</strong>
                            </div>
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                                <a href="learn.html?topic=backtracking&q=n-queens" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#f87171;">N-Queens ğŸ‘‘</a>
                                <a href="learn.html?topic=backtracking&q=sudoku-solver" style="text-decoration:none; background:#1e293b; padding:12px; border-radius:8px; text-align:center; color:#f87171;">Sudoku Solver</a>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "mistakes",
            title: "âš ï¸ Mistakes",
            icon: "fas fa-exclamation-triangle",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-exclamation-triangle"></i>
                            Common Backtracking Mistakes
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#ef4444; color:white;">MUST AVOID</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <!-- Mistake 1 -->
                        <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #ef4444; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">1</span>
                                <strong style="color: #f87171; font-size: 1.1rem;">Not Making a COPY!</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">current list is a reference. Sab entries same list point karengi!</p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #ef4444; margin-bottom: 8px; font-size: 0.85rem;">âŒ WRONG</p>
                                    <code style="color: #f87171; font-size: 0.85rem;">result.append(current)</code>
                                </div>
                                <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                    <p style="color: #10b981; margin-bottom: 8px; font-size: 0.85rem;">âœ… RIGHT</p>
                                    <code style="color: #34d399; font-size: 0.85rem;">result.append(current[:])</code>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Mistake 2 -->
                        <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #f59e0b; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">2</span>
                                <strong style="color: #fbbf24; font-size: 1.1rem;">Forgetting to BACKTRACK!</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Agar undo nahi kiya, state corrupt ho jayegi!</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #fbbf24; font-size: 0.85rem;">
                                    nums[i], nums[j] = nums[j], nums[i]  # Swap<br>
                                    backtrack(i + 1)<br>
                                    nums[i], nums[j] = nums[j], nums[i]  # Swap BACK! âœ…
                                </code>
                            </div>
                        </div>
                        
                        <!-- Mistake 3 -->
                        <div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #8b5cf6; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">3</span>
                                <strong style="color: #a78bfa; font-size: 1.1rem;">Not Handling Duplicates</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">[1,1,2] â†’ duplicate permutations without proper check!</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #a78bfa; font-size: 0.85rem;">
                                    nums.sort()  # Sort first!<br>
                                    if i > start and nums[i] == nums[i-1]:<br>
                                    &nbsp;&nbsp;continue  # Skip duplicate
                                </code>
                            </div>
                        </div>
                        
                        <!-- Mistake 4 -->
                        <div style="background: rgba(16, 185, 129, 0.1); border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 12px; padding: 20px;">
                            <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                                <span style="background: #10b981; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">4</span>
                                <strong style="color: #34d399; font-size: 1.1rem;">Infinite Loop in Grid</strong>
                            </div>
                            <p style="color: gray; margin-bottom: 12px;">Grid DFS mein visited check bhool gaye â†’ infinite recursion!</p>
                            <div style="background: #0f172a; padding: 12px; border-radius: 8px;">
                                <code style="color: #34d399; font-size: 0.85rem;">
                                    if visited[r][c]: return  # MUST check!<br>
                                    visited[r][c] = True<br>
                                    # ... explore ...<br>
                                    visited[r][c] = False  # Backtrack
                                </code>
                            </div>
                        </div>
                    </div>
                </div>`
        },
        {
            id: "cheatsheet",
            title: "ğŸ“Š Cheatsheet",
            icon: "fas fa-clipboard-list",
            content: `
                <div class="flashcard">
                    <div class="card-header">
                        <div class="card-title">
                            <i class="fas fa-clipboard-list"></i>
                            Quick Reference Cheatsheet
                        </div>
                        <div class="badges">
                            <span class="badge" style="background:#22d3ee; color:black;">INTERVIEW READY</span>
                        </div>
                    </div>
                    <div class="card-body">
                        
                        <h3 style="color: #fbbf24; margin-bottom: 15px;"><i class="fas fa-bolt"></i> Pattern Summary</h3>
                        
                        <table style="width:100%; border-collapse: collapse; border-radius: 12px; overflow: hidden; margin-bottom: 30px;">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #f59e0b, #fbbf24);">
                                    <th style="padding: 12px; text-align: left; color: black;">Pattern</th>
                                    <th style="padding: 12px; text-align: left; color: black;">Key Code</th>
                                    <th style="padding: 12px; text-align: left; color: black;">Time</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; color: #a78bfa;">Subset</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; font-family: Consolas; font-size: 0.8rem;">pick/no-pick, INDEX+1</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155;">O(2^n)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; color: #fbbf24;">Permutation</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; font-family: Consolas; font-size: 0.8rem;">for i in range(idx, n): swap</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155;">O(n!)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; color: #f87171;">Combination</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; font-family: Consolas; font-size: 0.8rem;">for i in range(start, n): i+1</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155;">O(C(n,k))</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; color: #34d399;">Grid DFS</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155; font-family: Consolas; font-size: 0.8rem;">visited + 4 directions</td>
                                    <td style="padding: 10px; border-bottom: 1px solid #334155;">O(4^L)</td>
                                </tr>
                                <tr style="background: #1e293b;">
                                    <td style="padding: 10px; color: #22d3ee;">Constraint</td>
                                    <td style="padding: 10px; font-family: Consolas; font-size: 0.8rem;">is_valid() + pruning</td>
                                    <td style="padding: 10px;">O(n!)</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3 style="color: #fbbf24; margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Debug Checklist</h3>
                        
                        <div style="background: #0f172a; padding: 20px; border-radius: 12px;">
                            <ul style="list-style: none; padding: 0; line-height: 2.2; color: #e2e8f0;">
                                <li>â˜ Am I making a <strong style="color:#10b981;">COPY</strong> when adding to result?</li>
                                <li>â˜ Am I <strong style="color:#fbbf24;">BACKTRACKING</strong> (undoing choices)?</li>
                                <li>â˜ Is my <strong style="color:#a78bfa;">BASE CASE</strong> correct?</li>
                                <li>â˜ Am I handling <strong style="color:#f87171;">DUPLICATES</strong> if needed?</li>
                                <li>â˜ Are my <strong style="color:#22d3ee;">LOOP RANGES</strong> correct (start vs index)?</li>
                                <li>â˜ Have I added <strong style="color:#34d399;">VISITED CHECK</strong> for grid problems?</li>
                            </ul>
                        </div>
                        
                        <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1)); padding: 25px; border-radius: 12px; border: 2px solid rgba(245, 158, 11, 0.3); margin-top: 25px; text-align: center;">
                            <h3 style="color: #fbbf24; margin-bottom: 10px;">ğŸ¯ The 3 Golden Rules</h3>
                            <p style="font-size: 1.2rem; line-height: 2;">
                                <strong style="color:#10b981;">1. CHOOSE</strong> â†’ Make a decision<br>
                                <strong style="color:#8b5cf6;">2. EXPLORE</strong> â†’ Recurse with that decision<br>
                                <strong style="color:#ef4444;">3. UNCHOOSE</strong> â†’ Backtrack (undo)
                            </p>
                        </div>
                    </div>
                </div>`
        }
    ]
};


// ========== data/index.js ==========
// data/index.js
// Main entry point that loads all topic files and combines them into prepData
// This file is loaded AFTER all the individual topic files

// Combine all topics into prepData
const prepData = {
    // DSA Topics
    arrays: topic_arrays,
    binary_search: topic_binary_search,
    linked_list: topic_linked_list,
    stack: topic_stack,
    trees: topic_trees,
    graphs: topic_graphs,
    dp: topic_dp,
    heap_trie: topic_heap_trie,
    backtracking: topic_backtracking,

    // Concept Guides
    dp_concepts: topic_dp_concepts,
    arrays_concepts: topic_arrays_concepts,
    graphs_concepts: topic_graphs_concepts,
    trees_concepts: topic_trees_concepts,
    complexity_concepts: topic_complexity_concepts,
    stack_concepts: topic_stack_concepts,
    backtracking_concepts: topic_backtracking_concepts
};

